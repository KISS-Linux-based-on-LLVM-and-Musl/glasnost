

# diff --git a/clang/lib/Basic/Targets/PPC.h b/clang/lib/Basic/Targets/PPC.h
# index ac52eb219..8cf7f8f77 100644
# --- a/clang/lib/Basic/Targets/PPC.h
# +++ b/clang/lib/Basic/Targets/PPC.h
# @@ -424,11 +424,10 @@ public:
#        LongDoubleFormat = &llvm::APFloat::IEEEdouble();
#      } else if ((Triple.getArch() == llvm::Triple::ppc64le)) {
#        DataLayout = "e-m:e-i64:64-n32:64";
# -      ABI = "elfv2";
#      } else {
#        DataLayout = "E-m:e-i64:64-n32:64";
# -      ABI = "elfv1";
#      }
# +    ABI = "elfv2";
# 
#      if (Triple.isOSFreeBSD() || Triple.isOSOpenBSD() || Triple.isMusl()) {
#        LongDoubleWidth = LongDoubleAlign = 64;

# diff --git a/clang/lib/CodeGen/TargetInfo.cpp b/clang/lib/CodeGen/TargetInfo.cpp
# index 9af3004eb..2b71c282c 100644
# --- a/clang/lib/CodeGen/TargetInfo.cpp
# +++ b/clang/lib/CodeGen/TargetInfo.cpp
# @@ -11342,9 +11342,9 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
#        return SetCGInfo(new AIXTargetCodeGenInfo(Types, /*Is64Bit*/ true));
# 
#      if (Triple.isOSBinFormatELF()) {
# -      PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv1;
# -      if (getTarget().getABI() == "elfv2")
# -        Kind = PPC64_SVR4_ABIInfo::ELFv2;
# +      PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv2;
# +      if (getTarget().getABI() == "elfv1")
# +        Kind = PPC64_SVR4_ABIInfo::ELFv1;
#        bool IsSoftFloat = CodeGenOpts.FloatABI == "soft";
# 
#        return SetCGInfo(

# diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
# index e7ba91240..d81f652cb 100644
# --- a/clang/lib/Driver/ToolChains/Clang.cpp
# +++ b/clang/lib/Driver/ToolChains/Clang.cpp
# @@ -2006,11 +2006,11 @@ void Clang::AddPPCTargetArgs(const ArgList &Args,
#    if (T.isOSBinFormatELF()) {
#      switch (getToolChain().getArch()) {
#      case llvm::Triple::ppc64: {
# -      if ((T.isOSFreeBSD() && T.getOSMajorVersion() >= 13) ||
# -          T.isOSOpenBSD() || T.isMusl())
# +      //if ((T.isOSFreeBSD() && T.getOSMajorVersion() >= 13) ||
# +      //    T.isOSOpenBSD() || T.isMusl())
#          ABIName = "elfv2";
# -      else
# -        ABIName = "elfv1";
# +      // else
# +      //   ABIName = "elfv1";
#        break;
#      }
#      case llvm::Triple::ppc64le:


# diff --git a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# index 3e86cf63c..0b3f17d50 100644
# --- a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# +++ b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# @@ -1,12 +1,12 @@
# -set(ARM64 aarch64)
# -set(ARM32 arm armhf)
# +set(ARM64 aarch64 aarch64_be)
# +set(ARM32 arm armhf armv6m)
#  set(HEXAGON hexagon)
#  set(X86 i386)
#  set(X86_64 x86_64)
#  set(LOONGARCH64 loongarch64)
#  set(MIPS32 mips mipsel)
#  set(MIPS64 mips64 mips64el)
# -set(PPC32 powerpc powerpcspe)
# +set(PPC32 powerpc powerpcspe powerpcle)
#  set(PPC64 powerpc64 powerpc64le)
#  set(RISCV32 riscv32)
#  set(RISCV64 riscv64)
# @@ -75,7 +75,7 @@ if(APPLE)
#  set(ALL_XRAY_SUPPORTED_ARCH ${X86_64})
#  else()
#  set(ALL_XRAY_SUPPORTED_ARCH ${X86_64} ${ARM32} ${ARM64} ${MIPS32} ${MIPS64}
# -		powerpc64le ${HEXAGON})
# +		${PPC64} ${HEXAGON})
#  endif()
#  set(ALL_SHADOWCALLSTACK_SUPPORTED_ARCH ${ARM64})

diff --git a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
index d14745ef9d13..41ed9c2c28ea 100644
--- a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
+++ b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
@@ -1,12 +1,12 @@
-set(ARM64 aarch64)
-set(ARM32 arm armhf)
+set(ARM64 aarch64 aarch64_be)
+set(ARM32 arm armhf armv6m)
 set(HEXAGON hexagon)
 set(X86 i386)
 set(X86_64 x86_64)
 set(LOONGARCH64 loongarch64)
 set(MIPS32 mips mipsel)
 set(MIPS64 mips64 mips64el)
-set(PPC32 powerpc powerpcspe)
+set(PPC32 powerpc powerpcspe powerpcle)
 set(PPC64 powerpc64 powerpc64le)
 set(RISCV32 riscv32)
 set(RISCV64 riscv64)

diff --git a/compiler-rt/cmake/base-config-ix.cmake b/compiler-rt/cmake/base-config-ix.cmake
index 0ad95d57f..8af4a0ff4 100644
--- a/compiler-rt/cmake/base-config-ix.cmake
+++ b/compiler-rt/cmake/base-config-ix.cmake
@@ -210,8 +210,10 @@ macro(test_targets)
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpc64le|ppc64le")
       test_target_arch(powerpc64le "" "-m64")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpc")
-      test_target_arch(powerpc "" "-m32")
+      test_target_arch(powerpc "" "-m32" "-mbig-endian" )
       test_target_arch(powerpc64 "" "-m64")
+    elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpcle|ppcle")
+      test_target_arch(powerpcle "" "-m32" "-mlittle-endian" )
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "s390x")
       test_target_arch(s390x "" "")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "sparc")
@@ -247,6 +249,8 @@ macro(test_targets)
       test_target_arch(aarch32 "" "-march=armv8-a")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "aarch64")
       test_target_arch(aarch64 "" "-march=armv8-a")
+    elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "aarch64_be")
+      test_target_arch(aarch64_be "" "-march=armv8-a" "-mbig-endian" )
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "riscv32")
       test_target_arch(riscv32 "" "")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "riscv64")

# diff --git a/compiler-rt/cmake/builtin-config-ix.cmake b/compiler-rt/cmake/builtin-config-ix.cmake
# index c422ad45e..8aa50fc19 100644
# --- a/compiler-rt/cmake/builtin-config-ix.cmake
# +++ b/compiler-rt/cmake/builtin-config-ix.cmake
# @@ -44,7 +44,7 @@
#  asm(\"cas w0, w1, [x2]\");
#  ")
# 
# -set(ARM64 aarch64)
# +set(ARM64 aarch64 aarch64_be)
#  set(ARM32 arm armhf armv4t armv5te armv6 armv6m armv7m armv7em armv7 armv7s armv7k armv8m.main armv8.1m.main)
#  set(AVR avr)
#  set(HEXAGON hexagon)
# @@ -53,7 +53,7 @@
#  set(LOONGARCH64 loongarch64)
#  set(MIPS32 mips mipsel)
#  set(MIPS64 mips64 mips64el)
# -set(PPC32 powerpc powerpcspe)
# +set(PPC32 powerpc powerpcspe powerpcle)
#  set(PPC64 powerpc64 powerpc64le)
#  set(RISCV32 riscv32)
#  set(RISCV64 riscv64)

diff --git a/compiler-rt/cmake/crt-config-ix.cmake b/compiler-rt/cmake/crt-config-ix.cmake
index dc3265e60984..983f12f8a727 100644
--- a/compiler-rt/cmake/crt-config-ix.cmake
+++ b/compiler-rt/cmake/crt-config-ix.cmake
@@ -18,7 +18,7 @@ else()
   set(OS_NAME "${CMAKE_SYSTEM_NAME}")
 endif()
 
-set(ARM64 aarch64)
+set(ARM64 aarch64 aarch64_be)
 set(ARM32 arm armhf)
 set(HEXAGON hexagon)
 set(X86 i386)
@@ -26,7 +26,7 @@ set(X86_64 x86_64)
 set(LOONGARCH64 loongarch64)
 set(MIPS32 mips mipsel)
 set(MIPS64 mips64 mips64el)
-set(PPC32 powerpc powerpcspe)
+set(PPC32 powerpc powerpcspe powerpcle)
 set(PPC64 powerpc64 powerpc64le)
 set(RISCV32 riscv32)
 set(RISCV64 riscv64)


# diff --git a/compiler-rt/lib/CMakeLists.txt b/compiler-rt/lib/CMakeLists.txt
# index 1437e37b8..6cf957e48 100644
# --- a/compiler-rt/lib/CMakeLists.txt
# +++ b/compiler-rt/lib/CMakeLists.txt
# @@ -17,9 +17,9 @@ if(COMPILER_RT_BUILD_BUILTINS)
#    add_subdirectory(builtins)
#  endif()
# 
# -if(COMPILER_RT_BUILD_CRT)
# +#if(COMPILER_RT_BUILD_CRT)
#    add_subdirectory(crt)
# -endif()
# +#endif()
# 
#  function(compiler_rt_build_runtime runtime)
#    string(TOUPPER ${runtime} runtime_uppercase)

# diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
# index ea5ad9cdb..886ff1afd 100644
# --- a/compiler-rt/lib/builtins/CMakeLists.txt
# +++ b/compiler-rt/lib/builtins/CMakeLists.txt
# @@ -223,7 +223,7 @@
# 
#  option(COMPILER_RT_EXCLUDE_ATOMIC_BUILTIN
#    "Skip the atomic builtin (these should normally be provided by a shared library)"
# -  On)
# +  OFF)
# 
#  if(NOT FUCHSIA AND NOT COMPILER_RT_BAREMETAL_BUILD)
#    set(GENERIC_SOURCES
# @@ -568,6 +568,7 @@
#  set(arm64_SOURCES ${aarch64_SOURCES})
#  set(arm64e_SOURCES ${aarch64_SOURCES})
#  set(arm64_32_SOURCES ${aarch64_SOURCES})
# +set(aarch64_be_SOURCES ${aarch64_SOURCES})
# 
#  # macho_embedded archs
#  set(armv6m_SOURCES ${thumb1_SOURCES})
# @@ -628,6 +629,7 @@
#  set(mips64el_SOURCES ${GENERIC_TF_SOURCES}
#                       ${mips_SOURCES})
# 
# +set(powerpcle_SOURCES ${GENERIC_SOURCES})
#  set(powerpc_SOURCES ${GENERIC_SOURCES})
# 
#  set(powerpcspe_SOURCES ${GENERIC_SOURCES})
# @@ -775,6 +777,16 @@
#          )
# 
#          set(deps_aarch64 lse_builtin_symlinks)
# +      endif()
# +
# +      if(arch STREQUAL "aarch64_be")
# +        add_custom_target(
# +          lse_builtin_symlinks
# +          BYPRODUCTS ${lse_builtins}
# +          ${arm64_lse_commands}
# +        )
# +
# +        set(deps_aarch64_be lse_builtin_symlinks)
#        endif()
# 
#        add_compiler_rt_runtime(clang_rt.builtins

diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
index 7f00391d1dce..0743df4224f6 100644
--- a/compiler-rt/lib/builtins/CMakeLists.txt
+++ b/compiler-rt/lib/builtins/CMakeLists.txt
@@ -220,7 +220,7 @@ set(GENERIC_TF_SOURCES
 
 option(COMPILER_RT_EXCLUDE_ATOMIC_BUILTIN
   "Skip the atomic builtin (these should normally be provided by a shared library)"
-  On)
+  ON)
 
 if(NOT FUCHSIA AND NOT COMPILER_RT_BAREMETAL_BUILD)
   set(GENERIC_SOURCES
@@ -600,6 +600,7 @@ set(armv7k_SOURCES ${arm_SOURCES})
 set(arm64_SOURCES ${aarch64_SOURCES})
 set(arm64e_SOURCES ${aarch64_SOURCES})
 set(arm64_32_SOURCES ${aarch64_SOURCES})
+set(aarch64_be_SOURCES ${aarch64_SOURCES})
 
 # macho_embedded archs
 set(armv6m_SOURCES ${thumb1_SOURCES})
@@ -669,6 +670,7 @@ set(mips64_SOURCES ${GENERIC_TF_SOURCES}
 set(mips64el_SOURCES ${GENERIC_TF_SOURCES}
                      ${mips_SOURCES})
 
+set(powerpcle_SOURCES ${GENERIC_SOURCES})
 set(powerpc_SOURCES ${GENERIC_SOURCES})
 
 set(powerpcspe_SOURCES ${GENERIC_SOURCES})
@@ -839,6 +841,16 @@ else ()
         set(deps_aarch64 lse_builtin_symlinks)
       endif()
 
+      if(arch STREQUAL "aarch64_be")
+        add_custom_target(
+          lse_builtin_symlinks
+          BYPRODUCTS ${lse_builtins}
+          ${arm64_lse_commands}
+        )
+
+        set(deps_aarch64_be lse_builtin_symlinks)
+      endif()
+
       add_compiler_rt_runtime(clang_rt.builtins
                               STATIC
                               ARCHS ${arch}

diff --git a/compiler-rt/lib/builtins/clear_cache.c b/compiler-rt/lib/builtins/clear_cache.c
index 8993761eb3d4..783edf766936 100644
--- a/compiler-rt/lib/builtins/clear_cache.c
+++ b/compiler-rt/lib/builtins/clear_cache.c
@@ -183,7 +183,7 @@ void __clear_cache(void *start, void *end) {
   const register void *end_reg __asm("a1") = end;
   // "0" means that we clear cache for all threads (SYS_RISCV_FLUSH_ICACHE_ALL)
   const register long flags __asm("a2") = 0;
-  const register long syscall_nr __asm("a7") = __NR_riscv_flush_icache;
+  const register long syscall_nr __asm("a7") = 259; // JD
   __asm __volatile("ecall"
                    : "=r"(start_reg)
                    : "r"(start_reg), "r"(end_reg), "r"(flags), "r"(syscall_nr));
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
index 2e4d57d87..094ba7a73 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
@@ -74,6 +74,10 @@
 #include <sys/utsname.h>
 #endif

+#if SANITIZER_LINUX && defined(__powerpc__)
+#include <asm/ptrace.h>
+#endif
+
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
 #include <sys/personality.h>
 #endif
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
index 32b8f47ed..e56d1c877 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -94,7 +94,7 @@
 # include <utime.h>
 # include <sys/ptrace.h>
 #    if defined(__mips64) || defined(__aarch64__) || defined(__arm__) || \
-        defined(__hexagon__) || defined(__loongarch__) ||SANITIZER_RISCV64
+        defined(__hexagon__) || defined(__powerpc__) || defined(__loongarch__) || SANITIZER_RISCV64
 #      include <asm/ptrace.h>
 #      ifdef __arm__
 typedef struct user_fpregs elf_fpregset_t;

diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
index 403bda117..b8f454e2f 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
@@ -31,7 +31,7 @@
 #include <sys/types.h> // for pid_t
 #include <sys/uio.h> // for iovec
 #include <elf.h> // for NT_PRSTATUS
-#if (defined(__aarch64__) || SANITIZER_RISCV64 || SANITIZER_LOONGARCH64) && \
+#if (defined(__aarch64__) || defined(__powerpc__) || SANITIZER_RISCV64 || SANITIZER_LOONGARCH64) && \
      !SANITIZER_ANDROID
 // GLIBC 2.20+ sys/user does not include asm/ptrace.h
 # include <asm/ptrace.h>

diff --git a/compiler-rt/lib/xray/xray_powerpc64.inc b/compiler-rt/lib/xray/xray_powerpc64.inc
index 7e872b5b4..0fc24c203 100644
--- a/compiler-rt/lib/xray/xray_powerpc64.inc
+++ b/compiler-rt/lib/xray/xray_powerpc64.inc
@@ -13,7 +13,7 @@
 #include <cstdint>
 #include <mutex>
 #ifdef __linux__
-#include <sys/platform/ppc.h>
+// #include <sys/platform/ppc.h>
 #elif defined(__FreeBSD__)
 #include <sys/types.h>
 #include <sys/sysctl.h>

# diff --git a/compiler-rt/lib/xray/xray_powerpc64.inc b/compiler-rt/lib/xray/xray_powerpc64.inc
# index e4e16d5b2..c9590e1fe 100644
# --- a/compiler-rt/lib/xray/xray_powerpc64.inc
# +++ b/compiler-rt/lib/xray/xray_powerpc64.inc
# @@ -12,22 +12,26 @@
# 
#  #include <cstdint>
#  #include <mutex>
# -#ifdef __linux__
# +#ifdef __GLIBC__
#  #include <sys/platform/ppc.h>
#  #elif defined(__FreeBSD__)
#  #include <sys/types.h>
#  #include <sys/sysctl.h>
# 
#  #define __ppc_get_timebase __builtin_ppc_get_timebase
# 
#  uint64_t __ppc_get_timebase_freq (void)
#  {
#    uint64_t tb_freq = 0;
#    size_t length = sizeof(tb_freq);
#    sysctlbyname("kern.timecounter.tc.timebase.frequency", &tb_freq, &length, nullptr, 0);
#    return tb_freq;
#  }
# +#else
# +#include <cctype>
# +#include <cstring>
# +#include <cstdlib>
#  #endif
# 
#  #include "xray_defs.h"
# 
# @@ -35,13 +39,45 @@ namespace __xray {
# 
#  ALWAYS_INLINE uint64_t readTSC(uint8_t &CPU) XRAY_NEVER_INSTRUMENT {
#    CPU = 0;
# +#ifdef __GLIBC__
#    return __ppc_get_timebase();
# +#else
# +  return __builtin_ppc_get_timebase();
# +#endif
#  }
# 
#  inline uint64_t getTSCFrequency() XRAY_NEVER_INSTRUMENT {
#    static std::mutex M;
#    std::lock_guard<std::mutex> Guard(M);
# +#ifdef __GLIBC__
#    return __ppc_get_timebase_freq();
# +#else
# +  /* FIXME: a less dirty implementation? */
# +  static uint64_t base;
# +  if (!base) {
# +    FILE *f = fopen("/proc/cpuinfo", "rb");
# +    if (f) {
# +      ssize_t nr;
# +      /* virtually always big enough to hold the line */
# +      char buf[512];
# +      while (fgets(buf, sizeof(buf), f)) {
# +        char *ret = strstr(buf, "timebase");
# +        if (!ret) {
# +          continue;
# +        }
# +        ret += sizeof("timebase") - 1;
# +        ret = strchr(ret, ':');
# +        if (!ret) {
# +          continue;
# +        }
# +        base = strtoul(ret + 1, nullptr, 10);
# +        break;
# +      }
# +      fclose(f);
# +    }
# +  }
# +  return base;
# +#endif
#  }
# 
#  inline bool probeRequiredCPUFeatures() XRAY_NEVER_INSTRUMENT {
diff --git a/libcxx/include/limits b/libcxx/include/limits
index 245c84eea..9fbbffb72 100644
--- a/libcxx/include/limits
+++ b/libcxx/include/limits
@@ -430,8 +430,14 @@
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}

-#if defined(__powerpc__) && defined(__LONG_DOUBLE_IBM128__)
+#if (defined(__powerpc__) || defined(__powerpc64__)) && defined(__LONG_DOUBLE_IBM128__)
+#if (__LDBL_MAX_EXP__ > __DBL_MAX_EXP__) || (__LDBL_MANT_DIG__ == __DBL_MANT_DIG__)
+    /* IEEE 754 quadruple or double precision */
+    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
+#else
+    /* 128-bit IBM double-double */
     static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
+#endif
 #else
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
 #endif

# diff --git a/libcxx/include/locale b/libcxx/include/locale
# index 7c2d2361f..1d6811b6f 100644
# --- a/libcxx/include/locale
# +++ b/libcxx/include/locale
# @@ -758,7 +758,7 @@
#          __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
#          errno = 0;
#          char *__p2;
# -        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
# +        long long __ll = strtoll_l(__a, &__p2, __base);
#          __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
#          if (__current_errno == 0)
#              errno = __save_errno;
# @@ -798,7 +798,7 @@
#          __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
#          errno = 0;
#          char *__p2;
# -        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
# +        unsigned long long __ll = strtoull_l(__a, &__p2, __base);
#          __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
#          if (__current_errno == 0)
#              errno = __save_errno;

# diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
# index 660bbadb2..82d9f02f2 100644
# --- a/libunwind/CMakeLists.txt
# +++ b/libunwind/CMakeLists.txt
# @@ -182,7 +182,7 @@ set(CMAKE_RUNTIME_OUTPUT_FOLDERECTORY ${LIBUNWIND_LIBRARY_DIR})
# 
#  set(LIBUNWIND_C_FLAGS "")
#  set(LIBUNWIND_CXX_FLAGS "")
# -set(LIBUNWIND_COMPILE_FLAGS "")
# +set(LIBUNWIND_COMPILE_FLAGS "$ENV{KISS_LIBUNWIND_FLAGS}")
#  set(LIBUNWIND_LINK_FLAGS "")
# 
#  # Include macros for adding and removing libunwind flags.


# diff --git a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# index b1de8d00f..988bf275b 100644
# --- a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# +++ b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# @@ -225,9 +225,7 @@ static std::unique_ptr<TargetLoweringObjectFile> createTLOF(const Triple &TT) {
# 
#  static PPCTargetMachine::PPCABI computeTargetABI(const Triple &TT,
#                                                   const TargetOptions &Options) {
# -  if (Options.MCOptions.getABIName().startswith("elfv1"))
# -    return PPCTargetMachine::PPC_ABI_ELFv1;
# -  else if (Options.MCOptions.getABIName().startswith("elfv2"))
# +  if (Options.MCOptions.getABIName().startswith("elfv2"))
#      return PPCTargetMachine::PPC_ABI_ELFv2;
# 
#    assert(Options.MCOptions.getABIName().empty() &&
# @@ -237,7 +235,7 @@ static PPCTargetMachine::PPCABI computeTargetABI(const Triple &TT,
#    case Triple::ppc64le:
#      return PPCTargetMachine::PPC_ABI_ELFv2;
#    case Triple::ppc64:
# -    return PPCTargetMachine::PPC_ABI_ELFv1;
# +    return PPCTargetMachine::PPC_ABI_ELFv2;
#    default:
#      return PPCTargetMachine::PPC_ABI_UNKNOWN;
#    }

# Ignore it temporarily
# diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
# index 195dba9d2..770b3bfbb 100644
# --- a/llvm/runtimes/CMakeLists.txt
# +++ b/llvm/runtimes/CMakeLists.txt
# @@ -64,7 +64,7 @@ macro(set_enable_per_target_runtime_dir)
#    # May have been set by llvm/CMakeLists.txt.
#    if (NOT DEFINED LLVM_ENABLE_PER_TARGET_RUNTIME_DIR)
#      # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -    if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +    if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{KISS_XHOST_TRIPLE}")
#        set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR OFF)
#      else()
#        set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON)
# @@ -86,6 +86,16 @@ function(builtin_default_target compiler_rt_path)
#                                        -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${BUILTINS_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES COMPILER_RT
# @@ -113,14 +123,28 @@ function(builtin_register_target compiler_rt_path target)
# 
#    llvm_ExternalProject_Add(builtins-${target}
#                             ${compiler_rt_path}/lib/builtins
# +                           ${compiler_rt_path}
#                             DEPENDS ${ARG_DEPENDS}
#                             CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
#                                        -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCMAKE_CXX_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=-nostdlib
# +                                      -DCMAKE_CXX_FLAGS=-nostdlib
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${target}_extra_args}
#                             USE_TOOLCHAIN
# @@ -218,6 +242,11 @@ function(runtime_default_target)
#      set_property(GLOBAL APPEND PROPERTY LLVM_ALL_LIT_TESTSUITES "@${LLVM_BINARY_DIR}/runtimes/runtimes-bins/lit.tests")
#      list(APPEND test_targets runtimes-test-depends check-runtimes)
#    endif()
# +  set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
# +
# +  set(RT_C_FLAGS "${CMAKE_C_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_CXX_FLAGS "${CMAKE_CXX_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_ASM_FLAGS "${CMAKE_ASM_FLAGS} --sysroot=${KISS_ROOT}")
# 
#    set_enable_per_target_runtime_dir()
# 
# @@ -234,6 +263,17 @@ function(runtime_default_target)
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=${RT_C_FLAGS}
# +                                      -DCMAKE_CXX_FLAGS=${RT_CXX_FLAGS}
# +                                      -DCMAKE_ASM_FLAGS=${RT_ASM_FLAGS}
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${RUNTIMES_CMAKE_ARGS}
#                                        ${ARG_CMAKE_ARGS}
# @@ -362,6 +402,16 @@ function(runtime_register_target name target)
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        -DLLVM_RUNTIMES_TARGET=${name}
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${name}_extra_args}
# 

# diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
# index 5e2274d52256..e66ce23701e1 100644
# --- a/compiler-rt/lib/builtins/CMakeLists.txt
# +++ b/compiler-rt/lib/builtins/CMakeLists.txt
# @@ -1,4 +1,4 @@
# -# This directory contains a large amount of C code which provides
# +# This
#  # generic implementations of the core runtime library along with optimized
#  # architecture-specific code in various subdirectories.

# Temporarily closed

# diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
# index 694f346ee8e9..f47fc2cebd03 100644
# --- a/llvm/runtimes/CMakeLists.txt
# +++ b/llvm/runtimes/CMakeLists.txt
# @@ -65,7 +65,7 @@ function(builtin_default_target compiler_rt_path)
# 
#    set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON)
#    # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -  if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +  if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{KISS_XHOST_TRIPLE}")
#      set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
#    endif()
# 
# @@ -78,6 +78,16 @@ function(builtin_default_target compiler_rt_path)
#                                        -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${BUILTINS_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES COMPILER_RT
# @@ -105,14 +115,28 @@ function(builtin_register_target compiler_rt_path target)
# 
#    llvm_ExternalProject_Add(builtins-${target}
#                             ${compiler_rt_path}/lib/builtins
# +                           ${compiler_rt_path}
#                             DEPENDS ${ARG_DEPENDS}
#                             CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
#                                        -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCMAKE_CXX_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=-nostdlib
# +                                      -DCMAKE_CXX_FLAGS=-nostdlib
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${target}_extra_args}
#                             USE_TOOLCHAIN
# @@ -219,10 +243,14 @@ function(runtime_default_target)
# 
#    set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON)
#    # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -  if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +  if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{KISS_XHOST_TRIPLE}")
#      set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
#    endif()
# 
# +  set(RT_C_FLAGS "${CMAKE_C_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_CXX_FLAGS "${CMAKE_CXX_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_ASM_FLAGS "${CMAKE_ASM_FLAGS} --sysroot=${KISS_ROOT}")
# +
#    llvm_ExternalProject_Add(runtimes
#                             ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
#                             DEPENDS ${ARG_DEPENDS}
# @@ -236,6 +264,17 @@ function(runtime_default_target)
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=${RT_C_FLAGS}
# +                                      -DCMAKE_CXX_FLAGS=${RT_CXX_FLAGS}
# +                                      -DCMAKE_ASM_FLAGS=${RT_ASM_FLAGS}
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${RUNTIMES_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES LLVM_ENABLE_RUNTIMES
# @@ -356,11 +395,21 @@ function(runtime_register_target name target)
#                                        -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
#                                        -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        -DLLVM_RUNTIMES_TARGET=${name}
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${name}_extra_args}



diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
index 75256c1326be..fd48c1b35a0b 100644
--- a/llvm/runtimes/CMakeLists.txt
+++ b/llvm/runtimes/CMakeLists.txt
@@ -64,11 +64,11 @@ macro(set_enable_per_target_runtime_dir)
   # May have been set by llvm/CMakeLists.txt.
   if (NOT DEFINED LLVM_ENABLE_PER_TARGET_RUNTIME_DIR)
     # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
-    if (LLVM_TARGET_TRIPLE MATCHES "aix")
+    # if (LLVM_TARGET_TRIPLE MATCHES "aix")
       set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR OFF)
-    else()
-      set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON)
-    endif()
+    # else()
+    #   set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON)
+    # endif()
   endif()
 endmacro()
 
@@ -86,11 +86,13 @@ function(builtin_default_target compiler_rt_path)
                                       -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${BUILTINS_CMAKE_ARGS}
                            PASSTHROUGH_PREFIXES COMPILER_RT
                                                 DARWIN
-                                                SANITIZER
                            USE_TOOLCHAIN
                            TARGET_TRIPLE ${LLVM_TARGET_TRIPLE}
                            ${EXTRA_ARGS})
@@ -99,7 +101,12 @@ endfunction()
 function(builtin_register_target compiler_rt_path name)
   cmake_parse_arguments(ARG "" "" "DEPENDS;CMAKE_ARGS;EXTRA_ARGS" ${ARGN})
 
+  message(WARNING "\${compiler_rt_path}:  ${compiler_rt_path}")
+  message(WARNING "\${COMMON_CMAKE_ARGS}:  ${COMMON_CMAKE_ARGS}")
+  message(WARNING "target \${name}:  ${name}")
+  message(WARNING "\${ARG_CMAKE_ARGS}:  ${ARG_CMAKE_ARGS}")
   set(${name}_extra_args ${ARG_CMAKE_ARGS})
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
   get_cmake_property(variable_names VARIABLES)
   foreach(variable_name ${variable_names})
     string(FIND "${variable_name}" "BUILTINS_${name}" out)
@@ -110,15 +117,22 @@ function(builtin_register_target compiler_rt_path name)
     endif()
   endforeach()
 
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
+  message(WARNING "\${EXTRA_ARGS}:  ${EXTRA_ARGS}")
+  message(WARNING "\${ARG_EXTRA_ARGS}:  ${ARG_EXTRA_ARGS}")
+
   llvm_ExternalProject_Add(builtins-${name}
                            ${compiler_rt_path}/lib/builtins
                            DEPENDS ${ARG_DEPENDS}
                            CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
                                       -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
-                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=${COMPILER_RT_DEFAULT_TARGET_ONLY}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${${name}_extra_args}
                            USE_TOOLCHAIN
@@ -230,7 +244,7 @@ function(runtime_default_target)
                            ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
                            DEPENDS ${ARG_DEPENDS}
                            # Builtins were built separately above
-                           CMAKE_ARGS -DCOMPILER_RT_BUILD_BUILTINS=Off
+                           CMAKE_ARGS -DCOMPILER_RT_BUILD_BUILTINS=OFF
                                       -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
@@ -239,11 +253,13 @@ function(runtime_default_target)
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${RUNTIMES_CMAKE_ARGS}
                                       ${ARG_CMAKE_ARGS}
                            PASSTHROUGH_PREFIXES LLVM_ENABLE_RUNTIMES
-                                                LLVM_USE_LINKER
                                                 ${ARG_PREFIXES}
                            EXTRA_TARGETS ${extra_targets}
                                          ${test_targets}
@@ -318,7 +334,7 @@ function(runtime_register_target name)
   set(${name}_extra_args ${ARG_CMAKE_ARGS})
   string(REPLACE ";" "|" LLVM_ENABLE_RUNTIMES_PASSTHROUGH "${LLVM_ENABLE_RUNTIMES}")
   list(APPEND ${name}_extra_args -DLLVM_ENABLE_RUNTIMES=${LLVM_ENABLE_RUNTIMES_PASSTHROUGH})
-  list(APPEND ${name}_extra_args -DLLVM_USE_LINKER=${LLVM_USE_LINKER})
+  # list(APPEND ${name}_extra_args -DLLVM_USE_LINKER=${LLVM_USE_LINKER})
 
   get_cmake_property(variable_names VARIABLES)
   foreach(extra_name IN ITEMS ${ARG_BASE_NAME} ${name})
@@ -334,6 +350,10 @@ function(runtime_register_target name)
 
   set_enable_per_target_runtime_dir()
 
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
+  message(WARNING "\${EXTRA_ARGS}:  ${EXTRA_ARGS}")
+  message(WARNING "\${ARG_EXTRA_ARGS}:  ${ARG_EXTRA_ARGS}")
+
   llvm_ExternalProject_Add(runtimes-${name}
                            ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
                            DEPENDS ${ARG_DEPENDS}
@@ -345,8 +365,11 @@ function(runtime_register_target name)
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
-                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=${COMPILER_RT_DEFAULT_TARGET_ONLY}
                                       -DLLVM_RUNTIMES_TARGET=${name}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${${name}_extra_args}
                            EXTRA_TARGETS ${${name}_extra_targets}
@@ -367,7 +390,7 @@ if(runtimes)
       endif()
     endforeach()
   endif()
-  if("libc" IN_LIST LLVM_ENABLE_RUNTIMES AND 
+  if("libc" IN_LIST LLVM_ENABLE_RUNTIMES AND
       (LLVM_LIBC_FULL_BUILD OR LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES))
     if(TARGET libc-hdrgen)
       set(libc_tools libc-hdrgen)


diff --git a/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll b/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
index 8b1cf6b58..296a2afa6 100644
--- a/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
+++ b/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
@@ -1,4 +1,5 @@
-; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv1
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv2
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-musl < %s | FileCheck %s -check-prefix=CHECK-ELFv2
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu -target-abi elfv1 < %s | FileCheck %s -check-prefix=CHECK-ELFv1
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu -target-abi elfv2 < %s | FileCheck %s -check-prefix=CHECK-ELFv2
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64le-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv2
# diff --git a/llvm/cmake/modules/LLVMInstallSymlink.cmake b/llvm/cmake/modules/LLVMInstallSymlink.cmake
# index 1400233b7..0a7b38737 100644
# --- a/llvm/cmake/modules/LLVMInstallSymlink.cmake
# +++ b/llvm/cmake/modules/LLVMInstallSymlink.cmake
# @@ -2,6 +2,9 @@
#  # DESTDIR environment variable may be unset at configuration time.
#  # See PR8397.
# 
# +# Set to an arbitrary directory to silence GNUInstallDirs warnings
# +# regarding being unable to determine libdir.
# +set(CMAKE_INSTALL_LIBDIR "lib")
#  include(GNUInstallDirs)
# 
#  function(install_symlink name target outdir)

# @@ -454,7 +458,8 @@
#  # LIBCXX_COMPILE_FLAGS: Compile only flags.
#  # LIBCXX_LINK_FLAGS: Linker only flags.
#  # LIBCXX_LIBRARIES: libraries libc++ is linked to.
# -set(LIBCXX_COMPILE_FLAGS "")
# +set(LIBCXX_COMPILE_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +set(CMAKE_CXX_FLAGS "${LIBCXX_COMPILE_FLAGS}")
#  set(LIBCXX_LINK_FLAGS "")
#  set(LIBCXX_LIBRARIES "")

# diff --git a/runtimes/CMakeLists.txt b/runtimes/CMakeLists.txt
# index 1400233b7..0a7b38737 100644
# --- a/runtimes/CMakeLists.txt
# +++ b/runtimes/CMakeLists.txt
# @@ -23,7 +23,7 @@
#  # We order libraries to mirror roughly how they are layered, except that compiler-rt can depend
#  # on libc++, so we put it after.
#  set(LLVM_DEFAULT_RUNTIMES "libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp")
# -set(LLVM_SUPPORTED_RUNTIMES "${LLVM_DEFAULT_RUNTIMES};llvm-libgcc")
# +# set(LLVM_SUPPORTED_RUNTIMES "${LLVM_DEFAULT_RUNTIMES};llvm-libgcc")
#  set(LLVM_ENABLE_RUNTIMES "" CACHE STRING
#    "Semicolon-separated list of runtimes to build, or \"all\" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.")
#  if(LLVM_ENABLE_RUNTIMES STREQUAL "all" )
# @@ -149,6 +149,8 @@
#    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
#  endif()
# 
# +set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} --sysroot=${KISS_ROOT}")
# +
#  # Avoid checking whether the compiler is working.
#  set(LLVM_COMPILER_CHECKED ON)
# 
# @@ -164,8 +166,8 @@
#  set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
#    "Default target for which the runtimes will be built.")
# 
# -option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
# -option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
# +option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." OFF)
# +option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." OFF)
#  option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)
# 
#  # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.
# 

diff --git a/cmake/Modules/CMakePolicy.cmake b/cmake/Modules/CMakePolicy.cmake
index 0ec32ad8637f..5ea248692216 100644
--- a/cmake/Modules/CMakePolicy.cmake
+++ b/cmake/Modules/CMakePolicy.cmake
@@ -2,11 +2,11 @@
 
 # CMP0114: ExternalProject step targets fully adopt their steps.
 # New in CMake 3.19: https://cmake.org/cmake/help/latest/policy/CMP0114.html
-if(POLICY CMP0114)
-  cmake_policy(SET CMP0114 OLD)
-endif()
+# if(POLICY CMP0114)
+#   cmake_policy(SET CMP0114 OLD)
+# endif()
 # CMP0116: Ninja generators transform `DEPFILE`s from `add_custom_command()`
 # New in CMake 3.20. https://cmake.org/cmake/help/latest/policy/CMP0116.html
-if(POLICY CMP0116)
-  cmake_policy(SET CMP0116 OLD)
-endif()
+# if(POLICY CMP0116)
+#   cmake_policy(SET CMP0116 OLD)
+# endif()


diff --git a/cmake/Modules/HandleCompilerRT.cmake b/cmake/Modules/HandleCompilerRT.cmake
index 6865f45175ed..4b5de1f886e1 100644
--- a/cmake/Modules/HandleCompilerRT.cmake
+++ b/cmake/Modules/HandleCompilerRT.cmake
@@ -70,19 +70,29 @@ function(find_compiler_rt_library name variable)
       list(APPEND clang_command "--target=${target}")
     endif()
     get_property(cxx_flags CACHE CMAKE_CXX_FLAGS PROPERTY VALUE)
+    message(WARNING "\${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
+    message(WARNING "\${cxx_flags} = ${cxx_flags}")
     string(REPLACE " " ";" cxx_flags "${cxx_flags}")
     list(APPEND clang_command ${cxx_flags})
     set(cmd_prefix "")
     if(MSVC AND ${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
       set(cmd_prefix "/clang:")
     endif()
+    message(WARNING "\${clang_command} = ${clang_command}")
     execute_process(
       COMMAND ${clang_command} "${cmd_prefix}--rtlib=compiler-rt" "${cmd_prefix}-print-libgcc-file-name"
       RESULT_VARIABLE had_error
       OUTPUT_VARIABLE library_file
     )
+    message(WARNING "-print-libgcc-file-name \${had_error} = ${had_error}")
     string(STRIP "${library_file}" library_file)
     file(TO_CMAKE_PATH "${library_file}" library_file)
+    message(WARNING "\${library_file} = ${library_file}")
+    if(EXISTS "${library_file}")
+      message(STATUS "\${library_file} = ${library_file}")
+    else()
+      message(FATAL_ERROR "${library_file} does not exist")
+    endif()
     get_filename_component(dirname ${library_file} DIRECTORY)
     if(APPLE)
       execute_process(
diff --git a/compiler-rt/cmake/Modules/AddCompilerRT.cmake b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
index a72e279dd75e..49e4ceee0e32 100644
--- a/compiler-rt/cmake/Modules/AddCompilerRT.cmake
+++ b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
@@ -1,12 +1,13 @@
 include(ExternalProject)
 include(CompilerRTUtils)
 include(HandleCompilerRT)
+include(CompilerRTCompile)
 
 # CMP0114: ExternalProject step targets fully adopt their steps.
 # New in CMake 3.19: https://cmake.org/cmake/help/latest/policy/CMP0114.html
-if(POLICY CMP0114)
-  cmake_policy(SET CMP0114 OLD)
-endif()
+# if(POLICY CMP0114)
+#   cmake_policy(SET CMP0114 OLD)
+# endif()
 
 function(set_target_output_directories target output_dir)
   # For RUNTIME_OUTPUT_DIRECTORY variable, Multi-configuration generators
@@ -169,6 +170,7 @@ endmacro()
 #                         PARENT_TARGET <convenience parent target>
 #                         ADDITIONAL_HEADERS <header files>)
 function(add_compiler_rt_runtime name type)
+  message(WARNING "\${name} = ${name}")
   if(NOT type MATCHES "^(OBJECT|STATIC|SHARED|MODULE)$")
     message(FATAL_ERROR
             "type argument must be OBJECT, STATIC, SHARED or MODULE")
@@ -273,6 +275,7 @@ function(add_compiler_rt_runtime name type)
           set_output_name(output_name_${libname} ${name} ${arch})
         endif()
       endif()
+      message(WARNING "\${libname} = ${libname}")
       if(COMPILER_RT_USE_BUILTINS_LIBRARY AND NOT type STREQUAL "OBJECT" AND
          NOT name STREQUAL "clang_rt.builtins")
         get_compiler_rt_target(${arch} target)
@@ -280,13 +283,24 @@ function(add_compiler_rt_runtime name type)
         if(builtins_${libname} STREQUAL "NOTFOUND")
           message(FATAL_ERROR "Cannot find builtins library for the target architecture")
         endif()
+      # else()
+      #   set(builtins_${libname} "clang_rt.builtins")
+      endif()
+      if(DEFINED builtins_${libname} AND NOT builtins_${libname} STREQUAL "" AND EXISTS "${builtins_${libname}}")
+        message(WARNING "\${builtins_${libname}} = ${builtins_${libname}}")
+      else()
+        if(DEFINED builtins_${libname} AND NOT builtins_${libname} STREQUAL "")
+          message(FATAL_ERROR "${builtins_${libname}} does not exist")
+        endif()
       endif()
       set(sources_${libname} ${LIB_SOURCES})
       format_object_libs(sources_${libname} ${arch} ${LIB_OBJECT_LIBS})
       set(libnames ${libnames} ${libname})
       set(extra_cflags_${libname} ${TARGET_${arch}_CFLAGS} ${NO_LTO_FLAGS} ${NO_PGO_FLAGS} ${LIB_CFLAGS})
       get_compiler_rt_output_dir(${arch} output_dir_${libname})
+      message(WARNING "\${output_dir_${libname}} = ${output_dir_${libname}}")
       get_compiler_rt_install_dir(${arch} install_dir_${libname})
+      message(WARNING "\${install_dir_${libname}} = ${install_dir_${libname}}")
     endforeach()
   endif()
 
diff --git a/compiler-rt/cmake/Modules/CompilerRTUtils.cmake b/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
index 25e7823716fc..078587e6308d 100644
--- a/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
+++ b/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
@@ -169,7 +169,11 @@ macro(detect_target_arch)
   elseif(__AVR)
     add_default_target_arch(avr)
   elseif(__AARCH64)
-    add_default_target_arch(aarch64)
+    if(__AARCH_BIG_ENDIAN)
+        add_default_target_arch(aarch64_be)
+    else()
+        add_default_target_arch(aarch64)
+    endif()
   elseif(__X86_64)
     if(CMAKE_SIZEOF_VOID_P EQUAL "4")
       add_default_target_arch(x32)
@@ -355,19 +359,39 @@ endmacro()
 
 macro(construct_compiler_rt_default_triple)
   if(COMPILER_RT_DEFAULT_TARGET_ONLY)
-    if(DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE)
+    if(DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE AND
+      NOT COMPILER_RT_DEFAULT_TARGET_TRIPLE STREQUAL "")
       message(FATAL_ERROR "COMPILER_RT_DEFAULT_TARGET_TRIPLE isn't supported when building for default target only")
     endif()
     if ("${CMAKE_C_COMPILER_TARGET}" STREQUAL "")
       message(FATAL_ERROR "CMAKE_C_COMPILER_TARGET must also be set when COMPILER_RT_DEFAULT_TARGET_ONLY is ON")
+    else()
+      message(WARNING "\${CMAKE_C_COMPILER_TARGET}: ${CMAKE_C_COMPILER_TARGET}")
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${CMAKE_C_COMPILER_TARGET} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
     endif()
-    message(STATUS "cmake c compiler target: ${CMAKE_C_COMPILER_TARGET}")
-    set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${CMAKE_C_COMPILER_TARGET})
   else()
+    if ("${LLVM_TARGET_TRIPLE}" STREQUAL "")
+      load_llvm_config()
+      get_property(LLVM_TARGET_TRIPLE GLOBAL PROPERTY LLVM_TARGET_TRIPLE)
+      message(WARNING "\$ENV{KISS_XHOST_TRIPLE}:  $ENV{KISS_XHOST_TRIPLE}")
+      message(WARNING "\$ENV{LLVM_TARGET_TRIPLE}: $ENV{LLVM_TARGET_TRIPLE}")
+      message(WARNING "\${COMMON_CMAKE_ARGS}: ${COMMON_CMAKE_ARGS}")
+      message(WARNING "\${HAVE_LLVM_LIT}: ${HAVE_LLVM_LIT}")
+      message(WARNING "\${EXTRA_ARGS}: ${EXTRA_ARGS}")
+      message(WARNING "\${LLVM_BUILTIN_TARGETS}: ${LLVM_BUILTIN_TARGETS}")
+      message(WARNING "\${ARG_EXTRA_ARGS}: ${ARG_EXTRA_ARGS}")
+      message(WARNING "\${LLVM_DEFAULT_TARGET_TRIPLE}: ${LLVM_DEFAULT_TARGET_TRIPLE}")
+      message(WARNING "\${LLVM_RUNTIMES_TARGET}: ${LLVM_RUNTIMES_TARGET}")
+      if ("${LLVM_TARGET_TRIPLE}" STREQUAL "")
+        message(FATAL_ERROR "LLVM_TARGET_TRIPLE must also be set when COMPILER_RT_DEFAULT_TARGET_ONLY is OFF")
+      endif()
+    endif()
+    message(WARNING "\${LLVM_TARGET_TRIPLE}: ${LLVM_TARGET_TRIPLE}")
     set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_TARGET_TRIPLE} CACHE STRING
-          "Default triple for which compiler-rt runtimes will be built.")
+      "Default triple for which compiler-rt runtimes will be built." FORCE)
   endif()
-
+  message(WARNING "\${COMPILER_RT_DEFAULT_TARGET_TRIPLE}: ${COMPILER_RT_DEFAULT_TARGET_TRIPLE}")
   string(REPLACE "-" ";" LLVM_TARGET_TRIPLE_LIST ${COMPILER_RT_DEFAULT_TARGET_TRIPLE})
   list(GET LLVM_TARGET_TRIPLE_LIST 0 COMPILER_RT_DEFAULT_TARGET_ARCH)
 
@@ -414,6 +438,10 @@ function(filter_builtin_sources inout_var name)
 endfunction()
 
 function(get_compiler_rt_target arch variable)
+  if (NOT DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE OR
+      COMPILER_RT_DEFAULT_TARGET_TRIPLE STREQUAL "")
+    construct_compiler_rt_default_triple()
+  endif()
   string(FIND ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} "-" dash_index)
   string(SUBSTRING ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} ${dash_index} -1 triple_suffix)
   string(SUBSTRING ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} 0 ${dash_index} triple_cpu)


# --- ./llvm/cmake/modules/HandleLLVMOptions.cmake
# +++ ./llvm/cmake/modules/HandleLLVMOptions.cmake
# @@ -313,12 +313,51 @@
#  endif()
# 
#  if( LLVM_USE_LINKER )
# -  append("-fuse-ld=${LLVM_USE_LINKER}"
# -    CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)
# -  check_cxx_source_compiles("int main() { return 0; }" CXX_SUPPORTS_CUSTOM_LINKER)
# -  if ( NOT CXX_SUPPORTS_CUSTOM_LINKER )
# -    message(FATAL_ERROR "Host compiler does not support '-fuse-ld=${LLVM_USE_LINKER}'")
# -  endif()
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +    set(cl_cache "${CMAKE_C_LINKER_FLAGS}")
# +    set(cxxl_cache "${CMAKE_CXX_LINKER_FLAGS}")
# +    set(el_cache "${CMAKE_EXE_LINKER_FLAGS}")
# +    set(ml_cache "${CMAKE_MODULE_LINKER_FLAGS}")
# +    set(sl_cache "${CMAKE_SHARED_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_EXE_LINKER_FLAGS} = ${CMAKE_EXE_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_C_LINKER_FLAGS} = ${CMAKE_C_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_CXX_LINKER_FLAGS} = ${CMAKE_CXX_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_MODULE_LINKER_FLAGS} = ${CMAKE_MODULE_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_SHARED_LINKER_FLAGS} = ${CMAKE_SHARED_LINKER_FLAGS}")
# +    set(CMAKE_C_LINKER_FLAGS "")
# +    set(CMAKE_CXX_LINKER_FLAGS "")
# +    set(CMAKE_EXE_LINKER_FLAGS "")
# +    set(CMAKE_MODULE_LINKER_FLAGS "")
# +    set(CMAKE_SHARED_LINKER_FLAGS "")
# +    append("-fuse-ld=${LLVM_USE_LINKER}"
# +        CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)
# +
# +    set(CMAKE_LINKER "$ENV{ORIGIN}/lld" CACHE FILEPATH "")
# +    set(CMAKE_LINK_EXECUTABLE "$ENV{ORIGIN}/lld" CACHE FILEPATH "")
# +    message(STATUS "\${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +    message(STATUS "\${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +    set(cxx_cache "${CMAKE_CXX_FLAGS}")
# +    set(c_cache "${CMAKE_C_FLAGS}")
# +    set(CMAKE_CXX_FLAGS "")
# +    check_cxx_source_compiles("int main() { return 0; }" CXX_SUPPORTS_CUSTOM_LINKER)
# +    set(CMAKE_CXX_FLAGS "${cxx_cache}")
# +    unset(cxx_cache CACHE)
# +    set(CMAKE_C_FLAGS "${c_cache}")
# +    unset(c_cache CACHE)
# +    set(CMAKE_C_LINKER_FLAGS "${cl_cache}")
# +    unset(cl_cache CACHE)
# +    set(CMAKE_CXX_LINKER_FLAGS "${cxxl_cache}")
# +    unset(cxxl_cache CACHE)
# +    set(CMAKE_EXE_LINKER_FLAGS "${el_cache}")
# +    unset(el_cache CACHE)
# +    set(CMAKE_MODULE_LINKER_FLAGS "${ml_cache}")
# +    unset(ml_cache CACHE)
# +    set(CMAKE_SHARED_LINKER_FLAGS "${sl_cache}")
# +    unset(sl_cache CACHE)
# +    if ( NOT CXX_SUPPORTS_CUSTOM_LINKER )
# +        message(FATAL_ERROR "Host compiler does not support '-fuse-ld=${LLVM_USE_LINKER}'")
# +    endif()
#  endif()
# 
#  if( LLVM_ENABLE_PIC )

# @@ -69,6 +69,8 @@
#  # This variable is used by individual runtimes to locate LLVM files.
#  set(LLVM_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../llvm)
# 
# +set(CMAKE_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +
#  include(CheckLibraryExists)
#  include(LLVMCheckCompilerLinkerFlag)
#  include(CheckCCompilerFlag)
# @@ -132,15 +134,17 @@
#  # Check for -nostdlib++ first; if there's no C++ standard library yet,
#  # all check_cxx_compiler_flag commands will fail until we add -nostdlib++
#  # (or -nodefaultlibs).
# -llvm_check_compiler_linker_flag(C "-nostdlib++" CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# -if (CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# +# llvm_check_compiler_linker_flag(C "-nostdlib++" CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# +# if (CXX_SUPPORTS_NOSTDLIBXX_FLAG)
#    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdlib++")
# -endif()
# -check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# -endif()
# +# endif()
# +# check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +# if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +#  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# +# endif()
# 
# +set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} --sysroot=${KISS_ROOT}")
# +
#  # Avoid checking whether the compiler is working.
#  set(LLVM_COMPILER_CHECKED ON)
# 
# @@ -156,8 +160,8 @@
#  set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
#    "Default target for which the runtimes will be built.")
# 
# -option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
# -option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
# +option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." OFF)
# +option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." OFF)
#  option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)
# 
#  # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.

# --- ./lldb/utils/TableGen/CMakeLists.txt
# +++ ./lldb/utils/TableGen/CMakeLists.txt
# @@ -1,6 +1,9 @@
#  # tablegen targets get exported via llvm for LLVMConfig.cmake. So standalone
#  # builds of lldb can potentially import this via LLVMConfig and also attempt to
#  # build it in tree. So only build it if it doesn't exist.
# +
# +set(CMAKE_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +
#  if (NOT DEFINED LLDB_TABLEGEN_EXE)
#    if (TARGET lldb-tblgen)
#      set(LLDB_TABLEGEN_EXE $<TARGET_FILE:lldb-tblgen> CACHE STRING "")

# # diff --git a/libcxxabi/CMakeLists.txt b/libcxxabi/CMakeLists.txt
# # index 1400233b7..0a7b38737 100644
# --- a/libcxxabi/CMakeLists.txt
# +++ b/libcxxabi/CMakeLists.txt
# @@ -47,7 +47,7 @@
#  option(LIBCXXABI_ENABLE_WERROR "Fail and stop if a warning is triggered." OFF)
# -option(LIBCXXABI_USE_LLVM_UNWINDER "Build and use the LLVM unwinder." OFF)
# +option(LIBCXXABI_USE_LLVM_UNWINDER "Build and use the LLVM unwinder." ON)
#  option(LIBCXXABI_ENABLE_STATIC_UNWINDER "Statically link the LLVM unwinder." OFF)
# -option(LIBCXXABI_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
# +option(LIBCXXABI_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
#  option(LIBCXXABI_ENABLE_THREADS "Build with threads enabled" ON)
#  option(LIBCXXABI_HAS_PTHREAD_API "Ignore auto-detection and force use of pthread API" OFF)
#  option(LIBCXXABI_HAS_WIN32_THREAD_API "Ignore auto-detection and force use of win32 thread API" OFF)
# @@ -465,6 +465,11 @@
# 
#  string(REPLACE ";" " " LIBCXXABI_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
#  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${LIBCXXABI_CXX_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +${CMAKE_CXX_FLAGS}")
#  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${LIBCXXABI_C_FLAGS}")
# 
#  # On AIX, avoid picking up VMX extensions(i.e. vec_malloc) which would change
# 
# # @@ -224,7 +224,7 @@
# #  # LIBCXXABI_LIBRARIES: libraries libc++abi is linked to.
# # 
# #  set(LIBCXXABI_C_FLAGS "")
# # -set(LIBCXXABI_CXX_FLAGS "")
# # +set(LIBCXXABI_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# #  set(LIBCXXABI_COMPILE_FLAGS "")
# #  set(LIBCXXABI_LINK_FLAGS "")
# #  set(LIBCXXABI_LIBRARIES "")
# # @@ -455,7 +455,7 @@
# #  endif()
# # 
# #  string(REPLACE ";" " " LIBCXXABI_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
# # -set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${LIBCXXABI_CXX_FLAGS}")
# # +set(CMAKE_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
# #  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${LIBCXXABI_C_FLAGS}")
# # 
# #  # On AIX, avoid picking up VMX extensions(i.e. vec_malloc) which would change


diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
index bc2a820fe98e..e299f4eac73e 100644
--- a/libunwind/CMakeLists.txt
+++ b/libunwind/CMakeLists.txt
@@ -44,7 +44,7 @@ option(LIBUNWIND_ENABLE_CROSS_UNWINDING "Enable cross-platform unwinding support
 option(LIBUNWIND_ENABLE_ARM_WMMX "Enable unwinding support for ARM WMMX registers." OFF)
 option(LIBUNWIND_ENABLE_THREADS "Build libunwind with threading support." ON)
 option(LIBUNWIND_WEAK_PTHREAD_LIB "Use weak references to refer to pthread functions." OFF)
-option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
+option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
 option(LIBUNWIND_INCLUDE_DOCS "Build the libunwind documentation." ${LLVM_INCLUDE_DOCS})
 option(LIBUNWIND_INCLUDE_TESTS "Build the libunwind tests." ${LLVM_INCLUDE_TESTS})
 option(LIBUNWIND_IS_BAREMETAL "Build libunwind for baremetal targets." OFF)
@@ -302,6 +302,6 @@ if (LIBUNWIND_INCLUDE_DOCS)
   add_subdirectory(docs)
 endif()
 
-if (LIBUNWIND_INCLUDE_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
+if (LIBUNWIND_INCLUDE_TESTS AND LLVM_BUILD_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
   add_subdirectory(test)
 endif()


diff --git a/compiler-rt/CMakeLists.txt b/compiler-rt/CMakeLists.txt
index 1545340aa8a8..95c521730cbb 100644
--- a/compiler-rt/CMakeLists.txt
+++ b/compiler-rt/CMakeLists.txt
@@ -75,7 +75,7 @@ set(COMPILER_RT_BAREMETAL_BUILD OFF CACHE BOOL
   "Build for a bare-metal target.")
 
 if (COMPILER_RT_STANDALONE_BUILD)
-  set(CMAKE_CXX_STANDARD 17 CACHE STRING "C++ standard to conform to")
+  set(CMAKE_CXX_STANDARD 23 CACHE STRING "C++ standard to conform to")
   set(CMAKE_CXX_STANDARD_REQUIRED YES)
   set(CMAKE_CXX_EXTENSIONS NO)
 
@@ -117,6 +117,9 @@ if (COMPILER_RT_STANDALONE_BUILD)
   set(LLVM_LIT_OUTPUT_DIR "${COMPILER_RT_EXEC_OUTPUT_DIR}")
 endif()
 
+if (NOT LLVM_RUNTIMES_BUILD)
+  load_llvm_config()
+endif()
 construct_compiler_rt_default_triple()
 if ("${COMPILER_RT_DEFAULT_TARGET_TRIPLE}" MATCHES ".*hf$")
   if (${COMPILER_RT_DEFAULT_TARGET_ARCH} MATCHES "^arm")
@@ -284,7 +287,7 @@ cmake_dependent_option(COMPILER_RT_STATIC_CXX_LIBRARY
   "Statically link the C++ library." OFF
   "COMPILER_RT_CXX_LIBRARY" OFF)
 
-set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY OFF)
+set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
 if (FUCHSIA)
   set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
 endif()



diff --git a/compiler-rt/lib/scudo/standalone/CMakeLists.txt b/compiler-rt/lib/scudo/standalone/CMakeLists.txt
index 094c23a73f36..b63eb1e15b55 100644
--- a/compiler-rt/lib/scudo/standalone/CMakeLists.txt
+++ b/compiler-rt/lib/scudo/standalone/CMakeLists.txt
@@ -12,8 +12,25 @@ list(APPEND SCUDO_CFLAGS
   -g
   -nostdinc++)
 
+message(WARNING "CMAKE_CXX_FLAGS = ${CMAKE_CXX_FLAGS}")
+message(WARNING "COMPILER_RESOURCE_DIR = ${COMPILER_RESOURCE_DIR}")
+message(WARNING "CLANG_RESOURCE_DIR = ${CLANG_RESOURCE_DIR}")
+message(WARNING "\$ENV{DESTDIR} = $ENV{DESTDIR}")
+message(WARNING "\$ENV{CXXFLAGS} = $ENV{CXXFLAGS}")
+message(WARNING "\$ENV{CFLAGS} = $ENV{CFLAGS}")
+message(WARNING "\$ENV{LDFLAGS} = $ENV{LDFLAGS}")
 # Remove -stdlib= which is unused when passing -nostdinc++.
 string(REGEX REPLACE "-stdlib=[a-zA-Z+]*" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
+set (CMAKE_CXX_FLAGS
+  "-isystem $DESTDIR/$PREFIX_HOST/include/c++/v1 \
+-isystem ${COMPILER_RESOURCE_DIR}/include \
+-isystem $ENV{DESTDIR}/usr/include $ENV{CXXFLAGS} ${CMAKE_CXX_FLAGS} \
+-isystem $ENV{KISS_ROOT}/usr/include")
+
+set (CMAKE_C_FLAGS
+  "-isystem ${COMPILER_RESOURCE_DIR}/include \
+-isystem $ENV{DESTDIR}/usr/include $ENV{CFLAGS} ${CMAKE_C_FLAGS} \
+-isystem $ENV{KISS_ROOT}/usr/include")
 
 append_list_if(COMPILER_RT_HAS_FVISIBILITY_HIDDEN_FLAG -fvisibility=hidden SCUDO_CFLAGS)
 
@@ -33,8 +50,16 @@ endif()
 append_list_if(COMPILER_RT_HAS_WTHREAD_SAFETY_FLAG -Werror=thread-safety
   SCUDO_CFLAGS)
 
+set(CMAKE_EXE_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
 set(SCUDO_LINK_FLAGS)
 
+if(LLVM_ENABLE_BACKTRACES)
+  list(APPEND SCUDO_LINK_FLAGS -lexecinfo)
+endif()
+
 list(APPEND SCUDO_LINK_FLAGS -Wl,-z,defs,-z,now,-z,relro)
 
 list(APPEND SCUDO_LINK_FLAGS -ffunction-sections -fdata-sections -Wl,--gc-sections)
@@ -182,6 +207,7 @@ endif()
 append_list_if(COMPILER_RT_HAS_LIBPTHREAD -pthread SCUDO_LINK_FLAGS)
 
 append_list_if(FUCHSIA zircon SCUDO_LINK_LIBS)
+append_list_if(LLVM_ENABLE_BACKTRACES execinfo SCUDO_LINK_LIBS)
 
 if(COMPILER_RT_DEFAULT_TARGET_ARCH MATCHES "mips|mips64|mipsel|mips64el")
   list(APPEND SCUDO_LINK_LIBS atomic)




# diff a/polly/lib/External/CMakeLists.txt b/polly/lib/External/CMakeLists.txt
# --- a/polly/lib/External/CMakeLists.txt
# +++ b/polly/lib/External/CMakeLists.txt
# @@ -12,6 +12,20 @@
#    set(DISABLE_WARNING_FLAGS "-w")
#  endif ()
# 
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_CXX_FLAGS}")
# +message(STATUS "\${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "\${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# 
#  # External: Integer Set Library
#  if (POLLY_BUNDLED_ISL)

# diff --git a/polly/lib/External/CMakeLists.txt b/polly/lib/External/CMakeLists.txt
# index c0a5b32e283f..26bd1befdd8e 100644
# --- a/polly/lib/External/CMakeLists.txt
# +++ b/polly/lib/External/CMakeLists.txt
# @@ -12,6 +12,22 @@ else ()
#    set(DISABLE_WARNING_FLAGS "-w")
#  endif ()
# 
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers -isystem /usr/include/c++/v1 \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers -isystem /usr/include/c++/v1 \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_CXX_FLAGS}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# 
#  # External: Integer Set Library
#  if (POLLY_BUNDLED_ISL)
# @@ -308,6 +324,8 @@ if (POLLY_BUNDLED_ISL)
# 
#    # ISL requires at least C99 to compile. gcc < 5.0 use -std=gnu89 as default.
#    set_property(TARGET PollyISL polly-isl-test PROPERTY C_STANDARD 99)
# +  set_property(TARGET PollyISL APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +  add_compile_options (-fPIC)
# 
#    target_compile_options(PollyISL PRIVATE ${DISABLE_WARNING_FLAGS})
#    target_compile_options(polly-isl-test PRIVATE ${DISABLE_WARNING_FLAGS})


diff --git a/llvm/lib/Support/CMakeLists.txt b/llvm/lib/Support/CMakeLists.txt
index 4cbc3b79f3bb..126ce4332f7e 100644
--- a/llvm/lib/Support/CMakeLists.txt
+++ b/llvm/lib/Support/CMakeLists.txt
@@ -318,6 +318,20 @@ endif()

 set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS "${llvm_system_libs}")

+set_property(TARGET LLVMSupport APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+add_compile_options (-fPIC)
+remove_definitions( -DHAVE_LSEEK64=1 )
+add_definitions( -UHAVE_LSEEK64 )
+set_property(TARGET LLVMSupport PROPERTY HAVE_LSEEK64 0)
+add_compile_options (-UHAVE_LSEEK64)
+target_compile_options(LLVMSupport PRIVATE -UHAVE_LSEEK64)
+get_target_property(defs LLVMSupport DEFINITIONS)
+list(FILTER defs EXCLUDE REGEX [[^HAVE_LSEEK64=.*$]])
+set_property(TARGET LLVMSupport PROPERTY DEFINITIONS ${defs})
+target_include_directories(LLVMSupport PUBLIC
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/llvm/include
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/clang/include)

 if(LLVM_INTEGRATED_CRT_ALLOC)
   if(LLVM_INTEGRATED_CRT_ALLOC MATCHES "snmalloc$")



# diff --git a/llvm/lib/Support/BLAKE3/CMakeLists.txt b/llvm/lib/Support/BLAKE3/CMakeLists.txt
# index 85fe4f6f4206..8f745a2784a5 100644
# --- a/llvm/lib/Support/BLAKE3/CMakeLists.txt
# +++ b/llvm/lib/Support/BLAKE3/CMakeLists.txt
# @@ -79,4 +79,7 @@ else()
#  endif()
# 
#  add_library(LLVMSupportBlake3 OBJECT EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES})
# +set_property(TARGET LLVMSupportBlake3 APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
# +add_compile_options (-fPIC)
#  llvm_update_compile_flags(LLVMSupportBlake3)


# diff --git a/utils/bazel/llvm-project-overlay/llvm/config.bzl b/utils/bazel/llvm-project-overlay/llvm/config.bzl
# index 5507f80efa0b..b15ec9e1bb39 100644
# --- a/utils/bazel/llvm-project-overlay/llvm/config.bzl
# +++ b/utils/bazel/llvm-project-overlay/llvm/config.bzl
# @@ -48,7 +48,7 @@ posix_defines = [
#  linux_defines = posix_defines + [
#      "_GNU_SOURCE",
#      "HAVE_LINK_H=1",
# -    "HAVE_LSEEK64=1",
# +    "HAVE_LSEEK64=0",
#      "HAVE_MALLINFO=1",
#      "HAVE_SBRK=1",
#      "HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC=1",


# diff --git a/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h b/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# index 8a30957b6120..43698cb46974 100644
# --- a/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# +++ b/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# @@ -146,6 +146,9 @@
# 
#  /* Define to 1 if you have the `lseek64' function. */
#  /* HAVE_LSEEK64 defined in Bazel */
# +#if defined HAVE_LSEEK64
# +#undef HAVE_LSEEK64
# +#endif
# 
#  /* Define to 1 if you have the <mach/mach.h> header file. */
#  /* HAVE_MACH_MACH_H defined in Bazel */


# diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
# index 92b15f14c62f..3e76c8a624dd 100644
# --- a/llvm/lib/Support/raw_ostream.cpp
# +++ b/llvm/lib/Support/raw_ostream.cpp
# @@ -59,6 +59,10 @@
#  #include "llvm/Support/Windows/WindowsSupport.h"
#  #endif
# 
# +#if defined HAVE_LSEEK64
# +#undef HAVE_LSEEK64
# +#endif
# +
#  using namespace llvm;
# 
#  constexpr raw_ostream::Colors raw_ostream::BLACK;





# diff --git a/clang/lib/Headers/CMakeLists.txt b/clang/lib/Headers/CMakeLists.txt
# index bb9a11eabbef..342c4789b581 100644
# --- a/clang/lib/Headers/CMakeLists.txt
# +++ b/clang/lib/Headers/CMakeLists.txt
# @@ -283,7 +283,7 @@ set(openmp_wrapper_files
#    openmp_wrappers/new
#  )
#  
# -set(output_dir ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION_MAJOR}/include)
# +set(output_dir ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION}/include)
#  set(out_files)
#  set(generated_files)
#  
# @@ -437,7 +437,7 @@ add_header_target("openmp-resource-headers" ${openmp_wrapper_files})
#  add_header_target("windows-resource-headers" ${windows_only_files})
#  add_header_target("utility-resource-headers" ${utility_files})
#  
# -set(header_install_dir lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION_MAJOR}/include)
# +set(header_install_dir lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION}/include)
#  
#  #############################################################
#  # Install rules for the catch-all clang-resource-headers target
# diff --git a/clang/lib/Tooling/CMakeLists.txt b/clang/lib/Tooling/CMakeLists.txt
# index e4ce43762d6b..58877218e453 100644
# --- a/clang/lib/Tooling/CMakeLists.txt
# +++ b/clang/lib/Tooling/CMakeLists.txt
# @@ -61,7 +61,7 @@ else()
#        $<TARGET_FILE:clang-ast-dump>
#          # Skip this in debug mode because parsing AST.h is too slow
#          --skip-processing=${skip_expensive_processing}
# -        -I ${LLVM_BINARY_DIR}/lib/clang/${CLANG_VERSION_MAJOR}/include
# +        -I ${LLVM_BINARY_DIR}/lib/clang/${CLANG_VERSION}/include
#          -I ${CLANG_SOURCE_DIR}/include
#          -I ${LLVM_BINARY_DIR}/tools/clang/include
#          -I ${LLVM_BINARY_DIR}/include
# diff --git a/clang/runtime/CMakeLists.txt b/clang/runtime/CMakeLists.txt
# index 0cccf730e417..9f4633bc85b1 100644
# --- a/clang/runtime/CMakeLists.txt
# +++ b/clang/runtime/CMakeLists.txt
# @@ -82,9 +82,9 @@ if(LLVM_BUILD_EXTERNAL_COMPILER_RT AND EXISTS ${COMPILER_RT_SRC_ROOT}/)
#                 -DCMAKE_CXX_COMPILER_LAUNCHER=${CMAKE_CXX_COMPILER_LAUNCHER}
#                 -DLLVM_CONFIG_PATH=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-config
#                 -DLLVM_LIT_ARGS=${LLVM_LIT_ARGS}
# -               -DCOMPILER_RT_OUTPUT_DIR=${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION_MAJOR}
# +               -DCOMPILER_RT_OUTPUT_DIR=${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION}
#                 -DCOMPILER_RT_EXEC_OUTPUT_DIR=${LLVM_RUNTIME_OUTPUT_INTDIR}
# -               -DCOMPILER_RT_INSTALL_PATH:PATH=lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION_MAJOR}
# +               -DCOMPILER_RT_INSTALL_PATH:PATH=lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION}
#                 -DCOMPILER_RT_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
#                 -DCMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}
#                 -DLLVM_LIBDIR_SUFFIX=${LLVM_LIBDIR_SUFFIX}
# diff --git a/compiler-rt/cmake/base-config-ix.cmake b/compiler-rt/cmake/base-config-ix.cmake
# index 0ad95d57fa74..f50f2a764d45 100644
# --- a/compiler-rt/cmake/base-config-ix.cmake
# +++ b/compiler-rt/cmake/base-config-ix.cmake
# @@ -43,9 +43,9 @@ if (LLVM_TREE_AVAILABLE)
#    string(REGEX MATCH "^[0-9]+" CLANG_VERSION_MAJOR
#           ${PACKAGE_VERSION})
#    # Setup the paths where compiler-rt runtimes and headers should be stored.
# -  set(COMPILER_RT_OUTPUT_DIR ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION_MAJOR})
# +  set(COMPILER_RT_OUTPUT_DIR ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION})
#    set(COMPILER_RT_EXEC_OUTPUT_DIR ${LLVM_RUNTIME_OUTPUT_INTDIR})
# -  set(COMPILER_RT_INSTALL_PATH lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION_MAJOR})
# +  set(COMPILER_RT_INSTALL_PATH lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION})
#    option(COMPILER_RT_INCLUDE_TESTS "Generate and build compiler-rt unit tests."
#           ${LLVM_INCLUDE_TESTS})
#    option(COMPILER_RT_ENABLE_WERROR "Fail and stop if warning is triggered"


#   Could NOT find Threads (missing: Threads_FOUND)
diff --git a/openmp/runtime/cmake/config-ix.cmake b/openmp/runtime/cmake/config-ix.cmake
index 8e76e66066a9..ccb6f1a652bc 100644
--- a/openmp/runtime/cmake/config-ix.cmake
+++ b/openmp/runtime/cmake/config-ix.cmake
@@ -155,6 +155,11 @@ if(CMAKE_C_COMPILER_ID STREQUAL "Intel" OR CMAKE_C_COMPILER_ID STREQUAL "IntelLL
   check_library_exists(irc_pic _intel_fast_memcpy "" LIBOMP_HAVE_IRC_PIC_LIBRARY)
 endif()

+set (CMAKE_THREAD_LIBS_INIT         "-lpthread")
+set (CMAKE_HAVE_THREADS_LIBRARY     1)
+set (CMAKE_USE_WIN32_THREADS_INIT   0)
+set (CMAKE_USE_PTHREADS_INIT        1)
+set (THREADS_PREFER_PTHREAD_FLAG    ON) # set(THREADS_PREFER_PTHREAD_FLAG TRUE)
 # Checking Threading requirements
 find_package(Threads REQUIRED)
 if(WIN32)


# diff --git a/openmp/CMakeLists.txt b/openmp/CMakeLists.txt
# index a87ea2fb57c5..64cd7c085609 100644
# --- a/openmp/CMakeLists.txt
# +++ b/openmp/CMakeLists.txt
# @@ -21,6 +21,25 @@ if (OPENMP_STANDALONE_BUILD OR "${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_CURRENT_S
#    endif()
#  endif()
# 
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers -isystem /usr/include/c++/v1 \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers -isystem /usr/include/c++/v1 \
# +-isystem $ENV{MAKE_DIR}/$ENV{OUTPUT_FOLDER}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +${CMAKE_CXX_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +
# +add_compile_options (-fPIC)
# +
#  # Must go below project(..)
#  include(GNUInstallDirs)
# 
# @@ -58,6 +77,9 @@ else()
#    endif()
#  endif()
# 
# +set (LLVM_CXX_STD "c++20")
# +set (LLVM_REQUIRED_CXX_STANDARD 20)
# +set (CMAKE_SIZEOF_VOID_P "8")
#  # Check and set up common compiler flags.
#  include(config-ix)
#  include(HandleOpenMPOptions)
# @@ -75,7 +97,7 @@ set(ENABLE_LIBOMPTARGET ON)
#  # Since the device plugins are only supported on Linux anyway,
#  # there is no point in trying to compile libomptarget on other OSes.
#  # 32-bit systems are not supported either.
# -if (APPLE OR WIN32 OR NOT OPENMP_HAVE_STD_CPP17_FLAG OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
# +if (APPLE OR WIN32 OR NOT OPENMP_HAS_STD_CPP_FLAG OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#    set(ENABLE_LIBOMPTARGET OFF)
#  endif()
# 
# @@ -99,7 +121,7 @@ if (OPENMP_ENABLE_LIBOMPTARGET)
#    # Check that the library can actually be built.
#    if (APPLE OR WIN32)
#      message(FATAL_ERROR "libomptarget cannot be built on Windows and MacOS X!")
# -  elseif (NOT OPENMP_HAVE_STD_CPP17_FLAG)
# +  elseif (NOT OPENMP_HAS_STD_CPP_FLAG)
#      message(FATAL_ERROR "Host compiler must support C++17 to build libomptarget!")
#    elseif (NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#      message(FATAL_ERROR "libomptarget on 32-bit systems are not supported!")



# diff --git a/openmp/cmake/config-ix.cmake b/openmp/cmake/config-ix.cmake
# index 857cfe5da8d6..a2fd13b7e2f4 100644
# --- a/openmp/cmake/config-ix.cmake
# +++ b/openmp/cmake/config-ix.cmake
# @@ -37,4 +37,5 @@ check_cxx_compiler_flag(-Wextra OPENMP_HAVE_WEXTRA_FLAG)
#  check_cxx_compiler_flag(-Wpedantic OPENMP_HAVE_WPEDANTIC_FLAG)
#  check_cxx_compiler_flag(-Wmaybe-uninitialized OPENMP_HAVE_WMAYBE_UNINITIALIZED_FLAG)
# 
# -check_cxx_compiler_flag(-std=c++17 OPENMP_HAVE_STD_CPP17_FLAG)
# +check_cxx_compiler_flag(-std=c++20 OPENMP_HAS_STD_CPP_FLAG)
# +set (OPENMP_HAS_STD_CPP_FLAG "ON")

# diff --git a/openmp/cmake/HandleOpenMPOptions.cmake b/openmp/cmake/HandleOpenMPOptions.cmake
# index 53a2d053e424..43afc180fc51 100644
# --- a/openmp/cmake/HandleOpenMPOptions.cmake
# +++ b/openmp/cmake/HandleOpenMPOptions.cmake
# @@ -36,4 +36,4 @@ append_if(OPENMP_HAVE_WEXTRA_FLAG "-Wno-extra" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
#  append_if(OPENMP_HAVE_WPEDANTIC_FLAG "-Wno-pedantic" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
#  append_if(OPENMP_HAVE_WMAYBE_UNINITIALIZED_FLAG "-Wno-maybe-uninitialized" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
# 
# -append_if(OPENMP_HAVE_STD_CPP17_FLAG "-std=c++17" CMAKE_CXX_FLAGS)
# +append_if(OPENMP_HAS_STD_CPP_FLAG "-std=c++20" CMAKE_CXX_FLAGS)


# diff --git a/openmp/libomptarget/CMakeLists.txt b/openmp/libomptarget/CMakeLists.txt
# index bc6e615cd584..c4a299e88e75 100644
# --- a/openmp/libomptarget/CMakeLists.txt
# +++ b/openmp/libomptarget/CMakeLists.txt
# @@ -48,6 +48,8 @@ set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} powerpc64-ibm-linux-g
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} powerpc64-ibm-linux-gnu-LTO")
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-pc-linux-gnu")
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-pc-linux-gnu-LTO")
# +set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-linux-musl")
# +set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-linux-musl-LTO")
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda")
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda-LTO")
#  set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda-JIT-LTO")
# 
# diff --git a/llvm/lib/Support/Unix/Signals.inc b/llvm/lib/Support/Unix/Signals.inc
# index 05a7335216f4..0589a38025bf 100644
# --- a/llvm/lib/Support/Unix/Signals.inc
# +++ b/llvm/lib/Support/Unix/Signals.inc
# @@ -85,12 +85,12 @@ static void InfoSignalHandler(int Sig); // defined below.
#  using SignalHandlerFunctionType = void (*)();
#  /// The function to call if ctrl-c is pressed.
#  static std::atomic<SignalHandlerFunctionType> InterruptFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
#  static std::atomic<SignalHandlerFunctionType> InfoSignalFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
#  /// The function to call on SIGPIPE (one-time use only).
#  static std::atomic<SignalHandlerFunctionType> OneShotPipeSignalFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
# 
#  namespace {
#  /// Signal-safe removal of files.
# @@ -98,8 +98,8 @@ namespace {
#  /// themselves is signal-safe. Memory is freed when the head is freed, deletion
#  /// is therefore not signal-safe either.
#  class FileToRemoveList {
# -  std::atomic<char *> Filename = ATOMIC_VAR_INIT(nullptr);
# -  std::atomic<FileToRemoveList *> Next = ATOMIC_VAR_INIT(nullptr);
# +  std::atomic<char *> Filename = (nullptr);
# +  std::atomic<FileToRemoveList *> Next = (nullptr);
# 
#    FileToRemoveList() = default;
#    // Not signal-safe.
# @@ -188,7 +188,7 @@ public:
#      Head.exchange(OldHead);
#    }
#  };
# -static std::atomic<FileToRemoveList *> FilesToRemove = ATOMIC_VAR_INIT(nullptr);
# +static std::atomic<FileToRemoveList *> FilesToRemove = (nullptr);
# 
#  /// Clean up the list in a signal-friendly manner.
#  /// Recall that signals can fire during llvm_shutdown. If this occurs we should
# @@ -248,7 +248,7 @@ static const int InfoSigs[] = {SIGUSR1
#  static const size_t NumSigs = std::size(IntSigs) + std::size(KillSigs) +
#                                std::size(InfoSigs) + 1 /* SIGPIPE */;
# 
# -static std::atomic<unsigned> NumRegisteredSignals = ATOMIC_VAR_INIT(0);
# +static std::atomic<unsigned> NumRegisteredSignals = (0);
#  static struct {
#    struct sigaction SA;
#    int SigNo;

# diff --git a/polly/lib/CMakeLists.txt b/polly/lib/CMakeLists.txt
# index 5b58d0ba8d2d..fc2962ef97de 100644
# --- a/polly/lib/CMakeLists.txt
# +++ b/polly/lib/CMakeLists.txt
# @@ -108,6 +108,8 @@ add_llvm_pass_plugin(Polly
#    )
#  set_target_properties(obj.Polly PROPERTIES FOLDER "Polly")
#  set_target_properties(Polly PROPERTIES FOLDER "Polly")
# +set_property(TARGET Polly APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +add_compile_options (-fPIC)
# 
#  if (MSVC_IDE OR XCODE)
#    # Configure source groups for Polly source files. By default, in the IDE there

# diff --git a/llvm/utils/count/CMakeLists.txt b/llvm/utils/count/CMakeLists.txt
# index 4e0d371334e4..e52a2f229582 100644
# --- a/llvm/utils/count/CMakeLists.txt
# +++ b/llvm/utils/count/CMakeLists.txt
# @@ -1,3 +1,5 @@
#  add_llvm_utility(count
#    count.c
#    )
# +set_property(TARGET count APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +add_compile_options (-fPIC)

# diff --git a/llvm/lib/Support/PrettyStackTrace.cpp b/llvm/lib/Support/PrettyStackTrace.cpp
# --- a/llvm/lib/Support/PrettyStackTrace.cpp
# +++ b/llvm/lib/Support/PrettyStackTrace.cpp
# @@ -65,7 +65,7 @@
#  // SIGINFO requests, it's possible that some threads will stop responding to it,
#  // but the program won't crash.
#  static volatile std::atomic<unsigned> GlobalSigInfoGenerationCounter =
# -    ATOMIC_VAR_INIT(1);
# +    (1);
#  static LLVM_THREAD_LOCAL unsigned ThreadLocalSigInfoGenerationCounter = 0;
# 
#  namespace llvm {


diff --git a/clang/lib/Headers/__stddef_max_align_t.h b/clang/lib/Headers/__stddef_max_align_t.h
index e3b439285d0f..e58f21b5e216 100644
--- a/clang/lib/Headers/__stddef_max_align_t.h
+++ b/clang/lib/Headers/__stddef_max_align_t.h
@@ -10,6 +10,7 @@
 #ifndef __CLANG_MAX_ALIGN_T_DEFINED
 #define __CLANG_MAX_ALIGN_T_DEFINED
 
+#if defined(__NEED_max_align_t) && !defined(__DEFINED_max_align_t)
 #if defined(_MSC_VER)
 typedef double max_align_t;
 #elif defined(__APPLE__)
@@ -23,5 +24,7 @@ typedef struct {
       __attribute__((__aligned__(__alignof__(long double))));
 } max_align_t;
 #endif
+#define __DEFINED_max_align_t
+#endif
 
 #endif


# diff --git a/libcxx/CMakeLists.txt b/libcxx/CMakeLists.txt
# index 90eb60c8eb6f..21ffc4b82b4c 100644
# --- a/libcxx/CMakeLists.txt
# +++ b/libcxx/CMakeLists.txt
# @@ -535,7 +535,7 @@ function(cxx_add_basic_build_flags target)
#        target_compile_definitions(${target} PRIVATE -D_LIBCPP_LINK_RT_LIB)
#      endif()
#    endif()
# -  target_compile_options(${target} PUBLIC "${LIBCXX_ADDITIONAL_COMPILE_FLAGS}")
# +  target_compile_options(${target} PUBLIC ${LIBCXX_ADDITIONAL_COMPILE_FLAGS})
#  endfunction()
#  
#  # Exception flags =============================================================
# diff --git a/libcxxabi/CMakeLists.txt b/libcxxabi/CMakeLists.txt
# index 19047835607e..b185c1167e14 100644
# --- a/libcxxabi/CMakeLists.txt
# +++ b/libcxxabi/CMakeLists.txt
# @@ -246,8 +246,8 @@ if (${CMAKE_SYSTEM_NAME} MATCHES "AIX")
#    add_flags_if_supported("-mdefault-visibility-export-mapping=explicit")
#    set(CMAKE_AIX_EXPORT_ALL_SYMBOLS OFF)
#  endif()
# -add_compile_flags("${LIBCXXABI_ADDITIONAL_COMPILE_FLAGS}")
# -add_library_flags("${LIBCXXABI_ADDITIONAL_LIBRARIES}")
# +add_compile_flags(${LIBCXXABI_ADDITIONAL_COMPILE_FLAGS})
# +add_library_flags(${LIBCXXABI_ADDITIONAL_LIBRARIES})
#  
#  # Configure compiler. Must happen after setting the target flags.
#  include(config-ix)
# diff --git a/libunwind/src/CMakeLists.txt b/libunwind/src/CMakeLists.txt
# index e5897fedd212..87a562b8dd4f 100644
# --- a/libunwind/src/CMakeLists.txt
# +++ b/libunwind/src/CMakeLists.txt
# @@ -132,8 +132,8 @@ else()
#    target_compile_options(unwind_shared_objects PRIVATE -fno-rtti)
#  endif()
#  target_link_libraries(unwind_shared_objects PRIVATE unwind-headers ${LIBUNWIND_LIBRARIES})
# -target_compile_options(unwind_shared_objects PUBLIC "${LIBUNWIND_ADDITIONAL_COMPILE_FLAGS}")
# -target_link_libraries(unwind_shared_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRARIES}")
# +target_compile_options(unwind_shared_objects PUBLIC ${LIBUNWIND_ADDITIONAL_COMPILE_FLAGS})
# +target_link_libraries(unwind_shared_objects PUBLIC ${LIBUNWIND_ADDITIONAL_LIBRARIES})
#  set_target_properties(unwind_shared_objects
#    PROPERTIES
#      CXX_EXTENSIONS OFF
# @@ -172,8 +172,8 @@ else()
#    target_compile_options(unwind_static_objects PRIVATE -fno-rtti)
#  endif()
#  target_link_libraries(unwind_static_objects PRIVATE unwind-headers ${LIBUNWIND_LIBRARIES})
# -target_compile_options(unwind_static_objects PUBLIC "${LIBUNWIND_ADDITIONAL_COMPILE_FLAGS}")
# -target_link_libraries(unwind_static_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRARIES}")
# +target_compile_options(unwind_static_objects PUBLIC ${LIBUNWIND_ADDITIONAL_COMPILE_FLAGS})
# +target_link_libraries(unwind_static_objects PUBLIC ${LIBUNWIND_ADDITIONAL_LIBRARIES})
#  set_target_properties(unwind_static_objects
#    PROPERTIES
#      CXX_EXTENSIONS OFF


diff --git a/llvm/include/llvm/Support/ScopedPrinter.h b/llvm/include/llvm/Support/ScopedPrinter.h
index aaaed3f5ceac..2f6fff6f76e9 100644
--- a/llvm/include/llvm/Support/ScopedPrinter.h
+++ b/llvm/include/llvm/Support/ScopedPrinter.h
@@ -539,7 +539,13 @@ ScopedPrinter::printHex<support::ulittle16_t>(StringRef Label,
   startLine() << Label << ": " << hex(Value) << "\n";
 }
 
-struct DelimitedScope;
+struct DelimitedScope {
+  DelimitedScope(ScopedPrinter &W) : W(&W) {}
+  DelimitedScope() : W(nullptr) {}
+  virtual ~DelimitedScope() = default;
+  virtual void setPrinter(ScopedPrinter &W) = 0;
+  ScopedPrinter *W;
+};
 
 class JSONScopedPrinter : public ScopedPrinter {
 private:
@@ -838,14 +844,6 @@ private:
   }
 };
 
-struct DelimitedScope {
-  DelimitedScope(ScopedPrinter &W) : W(&W) {}
-  DelimitedScope() : W(nullptr) {}
-  virtual ~DelimitedScope() = default;
-  virtual void setPrinter(ScopedPrinter &W) = 0;
-  ScopedPrinter *W;
-};
-
 struct DictScope : DelimitedScope {
   explicit DictScope() = default;
   explicit DictScope(ScopedPrinter &W) : DelimitedScope(W) { W.objectBegin(); }



diff --git a/llvm/lib/TableGen/TGParser.cpp b/llvm/lib/TableGen/TGParser.cpp
index 759e15f4c443..81b7ff9c21f2 100644
--- a/llvm/lib/TableGen/TGParser.cpp
+++ b/llvm/lib/TableGen/TGParser.cpp
@@ -4362,3 +4362,11 @@ LLVM_DUMP_METHOD void MultiClass::dump() const {
     E.dump();
 }
 #endif
+
+
+RecordsEntry::RecordsEntry(std::unique_ptr<Record> Rec) : Rec(std::move(Rec)) {}
+RecordsEntry::RecordsEntry(std::unique_ptr<ForeachLoop> Loop) : Loop(std::move(Loop)) {}
+RecordsEntry::RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion)
+  : Assertion(std::move(Assertion)) {}
+
+
diff --git a/llvm/lib/TableGen/TGParser.h b/llvm/lib/TableGen/TGParser.h
index d42cdad88a84..02294df48e7f 100644
--- a/llvm/lib/TableGen/TGParser.h
+++ b/llvm/lib/TableGen/TGParser.h
@@ -45,10 +45,9 @@ struct RecordsEntry {
   void dump() const;
 
   RecordsEntry() = default;
-  RecordsEntry(std::unique_ptr<Record> Rec) : Rec(std::move(Rec)) {}
-  RecordsEntry(std::unique_ptr<ForeachLoop> Loop) : Loop(std::move(Loop)) {}
-  RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion)
-      : Assertion(std::move(Assertion)) {}
+  RecordsEntry(std::unique_ptr<Record> Rec);
+  RecordsEntry(std::unique_ptr<ForeachLoop> Loop);
+  RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion);
 };
 
 /// ForeachLoop - Record the iteration state associated with a for loop.


diff --git a/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp b/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
index 23697fd9e2e2..ce6d93f372e9 100644
--- a/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
+++ b/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
@@ -759,3 +759,19 @@ void GIMatchTreeVRegDefPartitioner::generatePartitionSelectorCode(
 
   OS << Indent << "if (Partition == -1) return false;\n";
 }
+
+void GIMatchTree::setNumChildren(unsigned Num) { Children.resize(Num); }
+
+void GIMatchTree::setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V) {
+  Partitioner = std::move(V);
+}
+
+GIMatchTreeBuilder::GIMatchTreeBuilder(unsigned NextInstrID) : NextInstrID(NextInstrID) {}
+GIMatchTreeBuilder::GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID)
+    : TreeNode(TreeNode), NextInstrID(NextInstrID) {}
+
+void GIMatchTreeBuilder::addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P) {
+  Partitioners.push_back(std::move(P));
+}
+
+
diff --git a/llvm/utils/TableGen/GlobalISel/GIMatchTree.h b/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
index c65423ddacdb..e3b974fc7ed7 100644
--- a/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
+++ b/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
@@ -137,7 +137,7 @@ class GIMatchTree {
 public:
   void writeDOTGraph(raw_ostream &OS) const;
 
-  void setNumChildren(unsigned Num) { Children.resize(Num); }
+  void setNumChildren(unsigned Num);
   void addPossibleLeaf(const GIMatchTreeLeafInfo &V, bool IsFullyTraversed,
                        bool IsFullyTested) {
     PossibleLeaves.push_back(V);
@@ -148,9 +148,7 @@ public:
     if (PossibleLeaves.size() > Length)
       PossibleLeaves.resize(Length);
   }
-  void setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V) {
-    Partitioner = std::move(V);
-  }
+  void setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V);
   GIMatchTreePartitioner *getPartitioner() const { return Partitioner.get(); }
 
   std::vector<GIMatchTree>::iterator children_begin() {
@@ -414,18 +412,15 @@ protected:
   void runStep();
 
 public:
-  GIMatchTreeBuilder(unsigned NextInstrID) : NextInstrID(NextInstrID) {}
-  GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID)
-      : TreeNode(TreeNode), NextInstrID(NextInstrID) {}
+  GIMatchTreeBuilder(unsigned NextInstrID);
+  GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID);
 
   void addLeaf(StringRef Name, unsigned RootIdx, const GIMatchDag &MatchDag,
                void *Data) {
     Leaves.emplace_back(*this, Name, RootIdx, MatchDag, Data);
   }
   void addLeaf(const GIMatchTreeBuilderLeafInfo &L) { Leaves.push_back(L); }
-  void addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P) {
-    Partitioners.push_back(std::move(P));
-  }
+  void addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P);
   void addPartitionersForInstr(unsigned InstrIdx);
   void addPartitionersForOperand(unsigned InstrID, unsigned OpIdx);
 
diff --git a/llvm/utils/TableGen/GlobalISelMatchTable.cpp b/llvm/utils/TableGen/GlobalISelMatchTable.cpp
index aab772f020a6..c570069a2b60 100644
--- a/llvm/utils/TableGen/GlobalISelMatchTable.cpp
+++ b/llvm/utils/TableGen/GlobalISelMatchTable.cpp
@@ -2015,5 +2015,25 @@ void MakeTempRegisterAction::emitActionOpcodes(MatchTable &Table,
         << MatchTable::LineBreak;
 }
 
+std::unique_ptr<PredicateMatcher> GroupMatcher::popFirstCondition() {
+  assert(!Conditions.empty() &&
+       "Trying to pop a condition from a condition-less group");
+  std::unique_ptr<PredicateMatcher> P = std::move(Conditions.front());
+  Conditions.erase(Conditions.begin());
+  return P;
+}
+
+const PredicateMatcher & GroupMatcher::getFirstCondition() const {
+  assert(!Conditions.empty() &&
+         "Trying to get a condition from a condition-less group");
+  return *Conditions.front();
+}
+
+RuleMatcher::RuleMatcher(ArrayRef<SMLoc> SrcLoc)
+  : NextInsnVarID(0), NextOutputInsnID(0), NextTempRegID(0), SrcLoc(SrcLoc),
+  RuleID(NextRuleID++) {}
+
+void RuleMatcher::insnmatchers_pop_front() { Matchers.erase(Matchers.begin()); }
+
 } // namespace gi
 } // namespace llvm
diff --git a/llvm/utils/TableGen/GlobalISelMatchTable.h b/llvm/utils/TableGen/GlobalISelMatchTable.h
index fcb3392226c1..030a5c763cc1 100644
--- a/llvm/utils/TableGen/GlobalISelMatchTable.h
+++ b/llvm/utils/TableGen/GlobalISelMatchTable.h
@@ -48,48 +48,6 @@ class MatchTable;
 class Matcher;
 class OperandMatcher;
 class MatchAction;
-class PredicateMatcher;
-class InstructionMatcher;
-
-enum {
-  GISF_IgnoreCopies = 0x1,
-};
-
-using GISelFlags = std::uint16_t;
-
-//===- Helper functions ---------------------------------------------------===//
-
-std::string getNameForFeatureBitset(const std::vector<Record *> &FeatureBitset);
-
-/// Takes a sequence of \p Rules and group them based on the predicates
-/// they share. \p MatcherStorage is used as a memory container
-/// for the group that are created as part of this process.
-///
-/// What this optimization does looks like if GroupT = GroupMatcher:
-/// Output without optimization:
-/// \verbatim
-/// # R1
-///  # predicate A
-///  # predicate B
-///  ...
-/// # R2
-///  # predicate A // <-- effectively this is going to be checked twice.
-///                //     Once in R1 and once in R2.
-///  # predicate C
-/// \endverbatim
-/// Output with optimization:
-/// \verbatim
-/// # Group1_2
-///  # predicate A // <-- Check is now shared.
-///  # R1
-///   # predicate B
-///  # R2
-///   # predicate C
-/// \endverbatim
-template <class GroupT>
-std::vector<Matcher *>
-optimizeRules(ArrayRef<Matcher *> Rules,
-              std::vector<std::unique_ptr<Matcher>> &MatcherStorage);
 
 /// A record to be stored in a MatchTable.
 ///
@@ -169,6 +127,135 @@ public:
   unsigned size() const { return NumElements; }
 };
 
+class RuleMatcher;
+
+class PredicateMatcher {
+public:
+  /// This enum is used for RTTI and also defines the priority that is given to
+  /// the predicate when generating the matcher code. Kinds with higher priority
+  /// must be tested first.
+  ///
+  /// The relative priority of OPM_LLT, OPM_RegBank, and OPM_MBB do not matter
+  /// but OPM_Int must have priority over OPM_RegBank since constant integers
+  /// are represented by a virtual register defined by a G_CONSTANT instruction.
+  ///
+  /// Note: The relative priority between IPM_ and OPM_ does not matter, they
+  /// are currently not compared between each other.
+  enum PredicateKind {
+    IPM_Opcode,
+    IPM_NumOperands,
+    IPM_ImmPredicate,
+    IPM_Imm,
+    IPM_AtomicOrderingMMO,
+    IPM_MemoryLLTSize,
+    IPM_MemoryVsLLTSize,
+    IPM_MemoryAddressSpace,
+    IPM_MemoryAlignment,
+    IPM_VectorSplatImm,
+    IPM_NoUse,
+    IPM_GenericPredicate,
+    OPM_SameOperand,
+    OPM_ComplexPattern,
+    OPM_IntrinsicID,
+    OPM_CmpPredicate,
+    OPM_Instruction,
+    OPM_Int,
+    OPM_LiteralInt,
+    OPM_LLT,
+    OPM_PointerToAny,
+    OPM_RegBank,
+    OPM_MBB,
+    OPM_RecordNamedOperand,
+  };
+
+protected:
+  PredicateKind Kind;
+  unsigned InsnVarID;
+  unsigned OpIdx;
+
+public:
+  PredicateMatcher(PredicateKind Kind, unsigned InsnVarID, unsigned OpIdx = ~0)
+      : Kind(Kind), InsnVarID(InsnVarID), OpIdx(OpIdx) {}
+  virtual ~PredicateMatcher();
+
+  unsigned getInsnVarID() const { return InsnVarID; }
+  unsigned getOpIdx() const { return OpIdx; }
+
+  /// Emit MatchTable opcodes that check the predicate for the given operand.
+  virtual void emitPredicateOpcodes(MatchTable &Table,
+                                    RuleMatcher &Rule) const = 0;
+
+  PredicateKind getKind() const { return Kind; }
+
+  bool dependsOnOperands() const {
+    // Custom predicates really depend on the context pattern of the
+    // instruction, not just the individual instruction. This therefore
+    // implicitly depends on all other pattern constraints.
+    return Kind == IPM_GenericPredicate;
+  }
+
+  virtual bool isIdentical(const PredicateMatcher &B) const {
+    return B.getKind() == getKind() && InsnVarID == B.InsnVarID &&
+           OpIdx == B.OpIdx;
+  }
+
+  virtual bool isIdenticalDownToValue(const PredicateMatcher &B) const {
+    return hasValue() && PredicateMatcher::isIdentical(B);
+  }
+
+  virtual MatchTableRecord getValue() const {
+    assert(hasValue() && "Can not get a value of a value-less predicate!");
+    llvm_unreachable("Not implemented yet");
+  }
+  virtual bool hasValue() const { return false; }
+
+  /// Report the maximum number of temporary operands needed by the predicate
+  /// matcher.
+  virtual unsigned countRendererFns() const { return 0; }
+};
+
+class InstructionMatcher;
+
+enum {
+  GISF_IgnoreCopies = 0x1,
+};
+
+using GISelFlags = std::uint16_t;
+
+//===- Helper functions ---------------------------------------------------===//
+
+std::string getNameForFeatureBitset(const std::vector<Record *> &FeatureBitset);
+
+/// Takes a sequence of \p Rules and group them based on the predicates
+/// they share. \p MatcherStorage is used as a memory container
+/// for the group that are created as part of this process.
+///
+/// What this optimization does looks like if GroupT = GroupMatcher:
+/// Output without optimization:
+/// \verbatim
+/// # R1
+///  # predicate A
+///  # predicate B
+///  ...
+/// # R2
+///  # predicate A // <-- effectively this is going to be checked twice.
+///                //     Once in R1 and once in R2.
+///  # predicate C
+/// \endverbatim
+/// Output with optimization:
+/// \verbatim
+/// # Group1_2
+///  # predicate A // <-- Check is now shared.
+///  # R1
+///   # predicate B
+///  # R2
+///   # predicate C
+/// \endverbatim
+template <class GroupT>
+std::vector<Matcher *>
+optimizeRules(ArrayRef<Matcher *> Rules,
+              std::vector<std::unique_ptr<Matcher>> &MatcherStorage);
+
 /// Holds the contents of a generated MatchTable to enable formatting and the
 /// necessary index tracking needed to support GIM_Try.
 class MatchTable {
@@ -335,18 +422,8 @@ public:
   size_t size() const { return Matchers.size(); }
   bool empty() const { return Matchers.empty(); }
 
-  std::unique_ptr<PredicateMatcher> popFirstCondition() override {
-    assert(!Conditions.empty() &&
-           "Trying to pop a condition from a condition-less group");
-    std::unique_ptr<PredicateMatcher> P = std::move(Conditions.front());
-    Conditions.erase(Conditions.begin());
-    return P;
-  }
-  const PredicateMatcher &getFirstCondition() const override {
-    assert(!Conditions.empty() &&
-           "Trying to get a condition from a condition-less group");
-    return *Conditions.front();
-  }
+  std::unique_ptr<PredicateMatcher> popFirstCondition() override;
+  const PredicateMatcher &getFirstCondition() const override;
   bool hasFirstCondition() const override { return !Conditions.empty(); }
 
 private:
@@ -486,9 +563,7 @@ protected:
                              StringRef FlagName, GISelFlags FlagBit);
 
 public:
-  RuleMatcher(ArrayRef<SMLoc> SrcLoc)
-      : NextInsnVarID(0), NextOutputInsnID(0), NextTempRegID(0), SrcLoc(SrcLoc),
-        RuleID(NextRuleID++) {}
+  RuleMatcher(ArrayRef<SMLoc> SrcLoc);
   RuleMatcher(RuleMatcher &&Other) = default;
   RuleMatcher &operator=(RuleMatcher &&Other) = default;
 
@@ -618,7 +693,7 @@ public:
     return make_range(Matchers.begin(), Matchers.end());
   }
   bool insnmatchers_empty() const { return Matchers.empty(); }
-  void insnmatchers_pop_front() { Matchers.erase(Matchers.begin()); }
+  void insnmatchers_pop_front();
 };
 
 template <class PredicateTy> class PredicateListMatcher {
@@ -705,91 +780,6 @@ public:
   }
 };
 
-class PredicateMatcher {
-public:
-  /// This enum is used for RTTI and also defines the priority that is given to
-  /// the predicate when generating the matcher code. Kinds with higher priority
-  /// must be tested first.
-  ///
-  /// The relative priority of OPM_LLT, OPM_RegBank, and OPM_MBB do not matter
-  /// but OPM_Int must have priority over OPM_RegBank since constant integers
-  /// are represented by a virtual register defined by a G_CONSTANT instruction.
-  ///
-  /// Note: The relative priority between IPM_ and OPM_ does not matter, they
-  /// are currently not compared between each other.
-  enum PredicateKind {
-    IPM_Opcode,
-    IPM_NumOperands,
-    IPM_ImmPredicate,
-    IPM_Imm,
-    IPM_AtomicOrderingMMO,
-    IPM_MemoryLLTSize,
-    IPM_MemoryVsLLTSize,
-    IPM_MemoryAddressSpace,
-    IPM_MemoryAlignment,
-    IPM_VectorSplatImm,
-    IPM_NoUse,
-    IPM_GenericPredicate,
-    OPM_SameOperand,
-    OPM_ComplexPattern,
-    OPM_IntrinsicID,
-    OPM_CmpPredicate,
-    OPM_Instruction,
-    OPM_Int,
-    OPM_LiteralInt,
-    OPM_LLT,
-    OPM_PointerToAny,
-    OPM_RegBank,
-    OPM_MBB,
-    OPM_RecordNamedOperand,
-  };
-
-protected:
-  PredicateKind Kind;
-  unsigned InsnVarID;
-  unsigned OpIdx;
-
-public:
-  PredicateMatcher(PredicateKind Kind, unsigned InsnVarID, unsigned OpIdx = ~0)
-      : Kind(Kind), InsnVarID(InsnVarID), OpIdx(OpIdx) {}
-  virtual ~PredicateMatcher();
-
-  unsigned getInsnVarID() const { return InsnVarID; }
-  unsigned getOpIdx() const { return OpIdx; }
-
-  /// Emit MatchTable opcodes that check the predicate for the given operand.
-  virtual void emitPredicateOpcodes(MatchTable &Table,
-                                    RuleMatcher &Rule) const = 0;
-
-  PredicateKind getKind() const { return Kind; }
-
-  bool dependsOnOperands() const {
-    // Custom predicates really depend on the context pattern of the
-    // instruction, not just the individual instruction. This therefore
-    // implicitly depends on all other pattern constraints.
-    return Kind == IPM_GenericPredicate;
-  }
-
-  virtual bool isIdentical(const PredicateMatcher &B) const {
-    return B.getKind() == getKind() && InsnVarID == B.InsnVarID &&
-           OpIdx == B.OpIdx;
-  }
-
-  virtual bool isIdenticalDownToValue(const PredicateMatcher &B) const {
-    return hasValue() && PredicateMatcher::isIdentical(B);
-  }
-
-  virtual MatchTableRecord getValue() const {
-    assert(hasValue() && "Can not get a value of a value-less predicate!");
-    llvm_unreachable("Not implemented yet");
-  }
-  virtual bool hasValue() const { return false; }
-
-  /// Report the maximum number of temporary operands needed by the predicate
-  /// matcher.
-  virtual unsigned countRendererFns() const { return 0; }
-};
-
 /// Generates code to check a predicate of an operand.
 ///
 /// Typical predicates include:


diff --git a/llvm/include/llvm/Analysis/AliasAnalysis.h b/llvm/include/llvm/Analysis/AliasAnalysis.h
index 8da8d516499a..d2f6248893b8 100644
--- a/llvm/include/llvm/Analysis/AliasAnalysis.h
+++ b/llvm/include/llvm/Analysis/AliasAnalysis.h
@@ -303,7 +303,7 @@ class AAResults {
 public:
   // Make these results default constructable and movable. We have to spell
   // these out because MSVC won't synthesize them.
-  AAResults(const TargetLibraryInfo &TLI) : TLI(TLI) {}
+  AAResults(const TargetLibraryInfo &TLI);
   AAResults(AAResults &&Arg);
   ~AAResults();
 
diff --git a/llvm/lib/Analysis/AliasAnalysis.cpp b/llvm/lib/Analysis/AliasAnalysis.cpp
index 7b2f91f5392a..d2660d63e296 100644
--- a/llvm/lib/Analysis/AliasAnalysis.cpp
+++ b/llvm/lib/Analysis/AliasAnalysis.cpp
@@ -73,6 +73,7 @@ static cl::opt<bool> EnableAATrace("aa-trace", cl::Hidden, cl::init(false));
 static const bool EnableAATrace = false;
 #endif
 
+AAResults::AAResults(const TargetLibraryInfo &TLI) : TLI(TLI) {}
 AAResults::AAResults(AAResults &&Arg)
     : TLI(Arg.TLI), AAs(std::move(Arg.AAs)), AADeps(std::move(Arg.AADeps)) {}
 
diff --git a/llvm/lib/LTO/LTO.cpp b/llvm/lib/LTO/LTO.cpp
index 6803d6ab1285..af42543f987a 100644
--- a/llvm/lib/LTO/LTO.cpp
+++ b/llvm/lib/LTO/LTO.cpp
@@ -983,9 +983,11 @@ Error LTO::linkRegularLTO(RegularLTOState::AddedModule Mod,
           if (Error Err = F->materialize())
             return Err;
           OptimizationRemarkEmitter ORE(F, nullptr);
-          ORE.emit(OptimizationRemark(DEBUG_TYPE, "deadfunction", F)
+          OptimizationRemark or_instance(DEBUG_TYPE, "deadfunction", F);
+          or_instance
                    << ore::NV("Function", F)
-                   << " not added to the combined module ");
+                   << " not added to the combined module ";
+          ORE.emit(or_instance);
         }
       }
       continue;
@@ -1500,7 +1502,7 @@ public:
     const GVSummaryMapTy &DefinedGlobals =
         ModuleToDefinedGVSummaries.find(ModulePath)->second;
     BackendThreadPool.async(
-        [=](BitcodeModule BM, ModuleSummaryIndex &CombinedIndex,
+        [=, this](BitcodeModule BM, ModuleSummaryIndex &CombinedIndex,
             const FunctionImporter::ImportMapTy &ImportList,
             const FunctionImporter::ExportSetTy &ExportList,
             const std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>


diff --git a/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h b/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
index ea6ed322e9b1..838f23831488 100644
--- a/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
+++ b/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
@@ -368,7 +368,7 @@ template <typename Class> struct bind_ty {
 
 inline bind_ty<Register> m_Reg(Register &R) { return R; }
 inline bind_ty<MachineInstr *> m_MInstr(MachineInstr *&MI) { return MI; }
-inline bind_ty<LLT> m_Type(LLT Ty) { return Ty; }
+inline bind_ty<LLT> m_Type(LLT &Ty) { return Ty; }
 inline bind_ty<CmpInst::Predicate> m_Pred(CmpInst::Predicate &P) { return P; }
 inline operand_type_match m_Pred() { return operand_type_match(); }
 


diff --git a/clang/lib/AST/ParentMapContext.cpp b/clang/lib/AST/ParentMapContext.cpp
index 21cfd5b1de6e..f485369fd000 100644
--- a/clang/lib/AST/ParentMapContext.cpp
+++ b/clang/lib/AST/ParentMapContext.cpp
@@ -19,36 +19,6 @@
 
 using namespace clang;
 
-ParentMapContext::ParentMapContext(ASTContext &Ctx) : ASTCtx(Ctx) {}
-
-ParentMapContext::~ParentMapContext() = default;
-
-void ParentMapContext::clear() { Parents.reset(); }
-
-const Expr *ParentMapContext::traverseIgnored(const Expr *E) const {
-  return traverseIgnored(const_cast<Expr *>(E));
-}
-
-Expr *ParentMapContext::traverseIgnored(Expr *E) const {
-  if (!E)
-    return nullptr;
-
-  switch (Traversal) {
-  case TK_AsIs:
-    return E;
-  case TK_IgnoreUnlessSpelledInSource:
-    return E->IgnoreUnlessSpelledInSource();
-  }
-  llvm_unreachable("Invalid Traversal type!");
-}
-
-DynTypedNode ParentMapContext::traverseIgnored(const DynTypedNode &N) const {
-  if (const auto *E = N.get<Expr>()) {
-    return DynTypedNode::create(*traverseIgnored(E));
-  }
-  return N;
-}
-
 template <typename T, typename... U>
 std::tuple<bool, DynTypedNodeList, const T *, const U *...>
 matchParents(const DynTypedNodeList &NodeList,
@@ -265,6 +235,36 @@ public:
   }
 };
 
+ParentMapContext::ParentMapContext(ASTContext &Ctx) : ASTCtx(Ctx) {}
+
+ParentMapContext::~ParentMapContext() = default;
+
+void ParentMapContext::clear() { Parents.reset(); }
+
+const Expr *ParentMapContext::traverseIgnored(const Expr *E) const {
+  return traverseIgnored(const_cast<Expr *>(E));
+}
+
+Expr *ParentMapContext::traverseIgnored(Expr *E) const {
+  if (!E)
+    return nullptr;
+
+  switch (Traversal) {
+  case TK_AsIs:
+    return E;
+  case TK_IgnoreUnlessSpelledInSource:
+    return E->IgnoreUnlessSpelledInSource();
+  }
+  llvm_unreachable("Invalid Traversal type!");
+}
+
+DynTypedNode ParentMapContext::traverseIgnored(const DynTypedNode &N) const {
+  if (const auto *E = N.get<Expr>()) {
+    return DynTypedNode::create(*traverseIgnored(E));
+  }
+  return N;
+}
+
 template <typename T, typename... U> struct MatchParents {
   static std::tuple<bool, DynTypedNodeList, const T *, const U *...>
   match(const DynTypedNodeList &NodeList,


diff --git a/llvm/include/llvm/DWARFLinker/DWARFLinker.h b/llvm/include/llvm/DWARFLinker/DWARFLinker.h
index 5dce990adf02..eaae593c256d 100644
--- a/llvm/include/llvm/DWARFLinker/DWARFLinker.h
+++ b/llvm/include/llvm/DWARFLinker/DWARFLinker.h
@@ -310,17 +310,11 @@ public:
                              const DWARFDie *DIE)>
       messageHandler;
   DWARFLinker(messageHandler ErrorHandler, messageHandler WarningHandler,
-              std::function<StringRef(StringRef)> StringsTranslator)
-      : DwarfLinkerClientID(DwarfLinkerClient::Dsymutil),
-        StringsTranslator(StringsTranslator), ErrorHandler(ErrorHandler),
-        WarningHandler(WarningHandler) {}
+              std::function<StringRef(StringRef)> StringsTranslator);
 
   static std::unique_ptr<DWARFLinker> createLinker(
       messageHandler ErrorHandler, messageHandler WarningHandler,
-      std::function<StringRef(StringRef)> StringsTranslator = nullptr) {
-    return std::make_unique<DWARFLinker>(ErrorHandler, WarningHandler,
-                                         StringsTranslator);
-  }
+      std::function<StringRef(StringRef)> StringsTranslator = nullptr);
 
   /// Type of output file.
   enum class OutputFileType {
diff --git a/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h b/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
index 834cd96b77b4..325882b6e5df 100644
--- a/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
+++ b/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
@@ -54,9 +54,9 @@ class InputFile {
   getOrCreateTypeCollection(TypeCollectionKind Kind);
 
 public:
-  InputFile(PDBFile *Pdb) { PdbOrObj = Pdb; }
-  InputFile(object::COFFObjectFile *Obj) { PdbOrObj = Obj; }
-  InputFile(MemoryBuffer *Buffer) { PdbOrObj = Buffer; }
+  InputFile(PDBFile *Pdb);
+  InputFile(object::COFFObjectFile *Obj);
+  InputFile(MemoryBuffer *Buffer);
   ~InputFile();
   InputFile(InputFile &&Other) = default;
 
diff --git a/llvm/lib/DWARFLinker/DWARFLinker.cpp b/llvm/lib/DWARFLinker/DWARFLinker.cpp
index e6eccb20114a..b0259c1e99c7 100644
--- a/llvm/lib/DWARFLinker/DWARFLinker.cpp
+++ b/llvm/lib/DWARFLinker/DWARFLinker.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/DWARFLinker/DWARFLinker.h"
+#include "llvm/DWARFLinker/DWARFStreamer.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/BitVector.h"
 #include "llvm/ADT/STLExtras.h"
@@ -3082,4 +3083,17 @@ Error DWARFLinker::createEmitter(const Triple &TheTriple,
 
 DwarfEmitter *DWARFLinker::getEmitter() { return TheDwarfEmitter.get(); }
 
+DWARFLinker::DWARFLinker(messageHandler ErrorHandler, messageHandler WarningHandler,
+            std::function<StringRef(StringRef)> StringsTranslator)
+    : DwarfLinkerClientID(DwarfLinkerClient::Dsymutil),
+      StringsTranslator(StringsTranslator), ErrorHandler(ErrorHandler),
+      WarningHandler(WarningHandler) {}
+
+std::unique_ptr<DWARFLinker> DWARFLinker::createLinker(
+    messageHandler ErrorHandler, messageHandler WarningHandler,
+    std::function<StringRef(StringRef)> StringsTranslator) {
+  return std::make_unique<DWARFLinker>(ErrorHandler, WarningHandler,
+                                       StringsTranslator);
+}
+
 } // namespace llvm
diff --git a/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp b/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
index 85c22483fa90..2cc6dbc7cc6d 100644
--- a/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
+++ b/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
@@ -586,3 +586,8 @@ bool llvm::pdb::shouldDumpSymbolGroup(uint32_t Idx, const SymbolGroup &Group,
   // Otherwise, only dump if this is the same module specified.
   return (Filters.DumpModi == Idx);
 }
+
+InputFile::InputFile(PDBFile *Pdb) { PdbOrObj = Pdb; }
+InputFile::InputFile(object::COFFObjectFile *Obj) { PdbOrObj = Obj; }
+InputFile::InputFile(MemoryBuffer *Buffer) { PdbOrObj = Buffer; }
+


# diff --git a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# index a0a360c0a434..ac8be9dc314c 100644
# --- a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# +++ b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# @@ -510,14 +510,14 @@ class LVPatterns final {
#    template <typename T, typename U>
#    void resolveGenericPatternMatch(T *Element, const U &Requests) {
#      assert(Element && "Element must not be nullptr");
# -    auto CheckPattern = [=]() -> bool {
# +    auto CheckPattern = [=, this]() -> bool {
#        return (Element->isNamed() &&
#                (matchGenericPattern(Element->getName()) ||
#                 matchGenericPattern(Element->getLinkageName()))) ||
#               (Element->isTyped() &&
#                matchGenericPattern(Element->getTypeName()));
#      };
# -    auto CheckOffset = [=]() -> bool {
# +    auto CheckOffset = [=, this]() -> bool {
#        return matchOffsetPattern(Element->getOffset());
#      };
#      if ((options().getSelectGenericPattern() && CheckPattern()) ||
# @@ -530,12 +530,12 @@ class LVPatterns final {
#    template <typename U>
#    void resolveGenericPatternMatch(LVLine *Line, const U &Requests) {
#      assert(Line && "Line must not be nullptr");
# -    auto CheckPattern = [=]() -> bool {
# +    auto CheckPattern = [=, this]() -> bool {
#        return matchGenericPattern(Line->lineNumberAsStringStripped()) ||
#               matchGenericPattern(Line->getName()) ||
#               matchGenericPattern(Line->getPathname());
#      };
# -    auto CheckOffset = [=]() -> bool {
# +    auto CheckOffset = [=, this]() -> bool {
#        return matchOffsetPattern(Line->getAddress());
#      };
#      if ((options().getSelectGenericPattern() && CheckPattern()) ||


diff --git a/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h b/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
index bd63dd875621..c15bc677ae53 100644
--- a/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
+++ b/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
@@ -75,6 +75,7 @@ namespace llvm {
 
   public:
     ResourcePriorityQueue(SelectionDAGISel *IS);
+    ~ResourcePriorityQueue();
 
     bool isBottomUp() const override { return false; }
 
diff --git a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
index a0a360c0a434..ac8be9dc314c 100644
--- a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
+++ b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
@@ -510,14 +510,14 @@ class LVPatterns final {
   template <typename T, typename U>
   void resolveGenericPatternMatch(T *Element, const U &Requests) {
     assert(Element && "Element must not be nullptr");
-    auto CheckPattern = [=]() -> bool {
+    auto CheckPattern = [=, this]() -> bool {
       return (Element->isNamed() &&
               (matchGenericPattern(Element->getName()) ||
                matchGenericPattern(Element->getLinkageName()))) ||
              (Element->isTyped() &&
               matchGenericPattern(Element->getTypeName()));
     };
-    auto CheckOffset = [=]() -> bool {
+    auto CheckOffset = [=, this]() -> bool {
       return matchOffsetPattern(Element->getOffset());
     };
     if ((options().getSelectGenericPattern() && CheckPattern()) ||
@@ -530,12 +530,12 @@ class LVPatterns final {
   template <typename U>
   void resolveGenericPatternMatch(LVLine *Line, const U &Requests) {
     assert(Line && "Line must not be nullptr");
-    auto CheckPattern = [=]() -> bool {
+    auto CheckPattern = [=, this]() -> bool {
       return matchGenericPattern(Line->lineNumberAsStringStripped()) ||
              matchGenericPattern(Line->getName()) ||
              matchGenericPattern(Line->getPathname());
     };
-    auto CheckOffset = [=]() -> bool {
+    auto CheckOffset = [=, this]() -> bool {
       return matchOffsetPattern(Line->getAddress());
     };
     if ((options().getSelectGenericPattern() && CheckPattern()) ||
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
index bfc7f7689718..07b961f9b4a0 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
@@ -69,8 +69,10 @@ public:
   FORWARD_SYMBOL_METHOD(isPureVirtual)
   FORWARD_SYMBOL_METHOD(getRelativeVirtualAddress)
   FORWARD_SYMBOL_METHOD(getToken)
-  FORWARD_CONCRETE_SYMBOL_ID_METHOD_WITH_NAME(PDBSymbolTypeFunctionSig, getType,
-                                              getSignature)
+
+  decltype(auto) getSignatureId() const;
+  std::unique_ptr<PDBSymbolTypeFunctionSig> getSignature() const;
+
   FORWARD_SYMBOL_METHOD(isUnalignedType)
   FORWARD_SYMBOL_METHOD(getUndecoratedName)
   FORWARD_SYMBOL_METHOD(isVirtual)
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
index ee1f736c17a0..09b0c1c5db2a 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
@@ -37,13 +37,15 @@ public:
   FORWARD_SYMBOL_ID_METHOD(getLexicalParent)
   FORWARD_SYMBOL_ID_METHOD(getUnmodifiedType)
   FORWARD_SYMBOL_METHOD(getName)
-  FORWARD_SYMBOL_METHOD(getSrcLineOnTypeDefn)
+  decltype(auto) getSrcLineOnTypeDefn() const;
   FORWARD_SYMBOL_METHOD(isNested)
   FORWARD_SYMBOL_METHOD(hasOverloadedOperator)
   FORWARD_SYMBOL_METHOD(isPacked)
   FORWARD_SYMBOL_METHOD(isScoped)
-  FORWARD_CONCRETE_SYMBOL_ID_METHOD_WITH_NAME(PDBSymbolTypeBuiltin, getType,
-                                              getUnderlyingType)
+
+  decltype(auto) getUnderlyingTypeId() const;
+  std::unique_ptr<PDBSymbolTypeBuiltin> getUnderlyingType() const;
+
   FORWARD_SYMBOL_METHOD(isUnalignedType)
   FORWARD_SYMBOL_METHOD(isVolatileType)
 };
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
index a3a49a4b619a..d2bfce6a2fda 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
@@ -35,7 +35,7 @@ public:
   FORWARD_SYMBOL_METHOD(getLength)
   FORWARD_SYMBOL_ID_METHOD(getLexicalParent)
   FORWARD_SYMBOL_METHOD(getName)
-  FORWARD_SYMBOL_METHOD(getSrcLineOnTypeDefn)
+  decltype(auto) getSrcLineOnTypeDefn() const;
   FORWARD_SYMBOL_METHOD(isNested)
   FORWARD_SYMBOL_METHOD(hasOverloadedOperator)
   FORWARD_SYMBOL_METHOD(isPacked)
diff --git a/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp b/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
index e0e8d503ca92..bbdd6313608f 100644
--- a/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
@@ -63,6 +63,8 @@ ResourcePriorityQueue::ResourcePriorityQueue(SelectionDAGISel *IS)
   HorizontalVerticalBalance = 0;
 }
 
+ResourcePriorityQueue::~ResourcePriorityQueue() {}
+
 unsigned
 ResourcePriorityQueue::numberRCValPredInSU(SUnit *SU, unsigned RCId) {
   unsigned NumberDeps = 0;
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
index 59d57e83fc10..64b97b5a1031 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
@@ -79,6 +79,15 @@ private:
 };
 }
 
+decltype(auto) PDBSymbolFunc::getSignatureId() const {
+  return RawSymbol->getTypeId();
+}
+
+std::unique_ptr<PDBSymbolTypeFunctionSig> PDBSymbolFunc::getSignature() const {
+  uint32_t Id = getSignatureId();
+  return getConcreteSymbolByIdHelper<PDBSymbolTypeFunctionSig>(Id);
+}
+
 std::unique_ptr<IPDBEnumChildren<PDBSymbolData>>
 PDBSymbolFunc::getArguments() const {
   return std::make_unique<FunctionArgEnumerator>(Session, *this);
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
index db8ca327da1e..297cf766ed8c 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
@@ -16,3 +16,13 @@ using namespace llvm;
 using namespace llvm::pdb;
 
 void PDBSymbolTypeEnum::dump(PDBSymDumper &Dumper) const { Dumper.dump(*this); }
+decltype(auto) PDBSymbolTypeEnum::getSrcLineOnTypeDefn() const { return RawSymbol->getSrcLineOnTypeDefn(); }
+
+decltype(auto) PDBSymbolTypeEnum::getUnderlyingTypeId() const {
+  return RawSymbol->getTypeId();
+}
+
+std::unique_ptr<PDBSymbolTypeBuiltin> PDBSymbolTypeEnum::getUnderlyingType() const {
+  uint32_t Id = getUnderlyingTypeId();
+  return getConcreteSymbolByIdHelper<PDBSymbolTypeBuiltin>(Id);
+}
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
index 122111d32027..42683907644f 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
@@ -15,3 +15,4 @@ using namespace llvm;
 using namespace llvm::pdb;
 
 void PDBSymbolTypeUDT::dump(PDBSymDumper &Dumper) const { Dumper.dump(*this); }
+decltype(auto) PDBSymbolTypeUDT::getSrcLineOnTypeDefn() const { return RawSymbol->getSrcLineOnTypeDefn(); }
diff --git a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
index 4c3696f9c342..c9bb1bc92ceb 100644
--- a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
+++ b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
@@ -1152,7 +1152,7 @@ IRBuilder<>::InsertPoint OpenMPIRBuilder::createParallel(
   }
 
   OutlineInfo OI;
-  OI.PostOutlineCB = [=](Function &OutlinedFn) {
+  OI.PostOutlineCB = [=, this](Function &OutlinedFn) {
     // Add some known attributes.
     OutlinedFn.addParamAttr(0, Attribute::NoAlias);
     OutlinedFn.addParamAttr(1, Attribute::NoAlias);
@@ -2209,7 +2209,7 @@ CanonicalLoopInfo *OpenMPIRBuilder::createCanonicalLoop(
   Value *TripCount = Builder.CreateSelect(ZeroCmp, Zero, CountIfLooping,
                                           "omp_" + Name + ".tripcount");
 
-  auto BodyGen = [=](InsertPointTy CodeGenIP, Value *IV) {
+  auto BodyGen = [=, this](InsertPointTy CodeGenIP, Value *IV) {
     Builder.restoreIP(CodeGenIP);
     Value *Span = Builder.CreateMul(IV, Step);
     Value *IndVar = Builder.CreateAdd(Span, Start);
diff --git a/llvm/lib/ObjCopy/ELF/ELFObject.cpp b/llvm/lib/ObjCopy/ELF/ELFObject.cpp
index 697afab2a617..0b4ff9a3d051 100644
--- a/llvm/lib/ObjCopy/ELF/ELFObject.cpp
+++ b/llvm/lib/ObjCopy/ELF/ELFObject.cpp
@@ -34,6 +34,8 @@ using namespace llvm::ELF;
 using namespace llvm::objcopy::elf;
 using namespace llvm::object;
 
+Object::Object() {}
+
 template <class ELFT> void ELFWriter<ELFT>::writePhdr(const Segment &Seg) {
   uint8_t *B = reinterpret_cast<uint8_t *>(Buf->getBufferStart()) +
                Obj.ProgramHdrSegment.Offset + Seg.Index * sizeof(Elf_Phdr);
@@ -1237,6 +1239,8 @@ static bool compareSegmentsByOffset(const Segment *A, const Segment *B) {
   return A->Index < B->Index;
 }
 
+BasicELFBuilder::BasicELFBuilder() : Obj(std::make_unique<Object>()) {}
+
 void BasicELFBuilder::initFileHeader() {
   Obj->Flags = 0x0;
   Obj->Type = ET_REL;
@@ -1278,6 +1282,9 @@ Error BasicELFBuilder::initSections() {
   return Error::success();
 }
 
+BinaryELFBuilder::BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility)
+    : MemBuf(MB), NewSymbolVisibility(NewSymbolVisibility) {}
+
 void BinaryELFBuilder::addData(SymbolTableSection *SymTab) {
   auto Data = ArrayRef<uint8_t>(
       reinterpret_cast<const uint8_t *>(MemBuf->getBufferStart()),
@@ -1315,6 +1322,8 @@ Expected<std::unique_ptr<Object>> BinaryELFBuilder::build() {
   return std::move(Obj);
 }
 
+IHexELFBuilder::IHexELFBuilder(const std::vector<IHexRecord> &Records) : Records(Records) {}
+
 // Adds sections from IHEX data file. Data should have been
 // fully validated by this time.
 void IHexELFBuilder::addDataSections() {
diff --git a/llvm/lib/ObjCopy/ELF/ELFObject.h b/llvm/lib/ObjCopy/ELF/ELFObject.h
index 89a03b3fe0ee..5ff1b3fde545 100644
--- a/llvm/lib/ObjCopy/ELF/ELFObject.h
+++ b/llvm/lib/ObjCopy/ELF/ELFObject.h
@@ -928,7 +928,7 @@ protected:
   Error initSections();
 
 public:
-  BasicELFBuilder() : Obj(std::make_unique<Object>()) {}
+  BasicELFBuilder();
 };
 
 class BinaryELFBuilder : public BasicELFBuilder {
@@ -937,8 +937,7 @@ class BinaryELFBuilder : public BasicELFBuilder {
   void addData(SymbolTableSection *SymTab);
 
 public:
-  BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility)
-      : MemBuf(MB), NewSymbolVisibility(NewSymbolVisibility) {}
+  BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility);
 
   Expected<std::unique_ptr<Object>> build();
 };
@@ -949,7 +948,7 @@ class IHexELFBuilder : public BasicELFBuilder {
   void addDataSections();
 
 public:
-  IHexELFBuilder(const std::vector<IHexRecord> &Records) : Records(Records) {}
+  IHexELFBuilder(const std::vector<IHexRecord> &Records);
 
   Expected<std::unique_ptr<Object>> build();
 };
@@ -1038,6 +1037,7 @@ private:
   };
 
 public:
+  Object();
   template <class T>
   using ConstRange = iterator_range<pointee_iterator<
       typename std::vector<std::unique_ptr<T>>::const_iterator>>;
diff --git a/llvm/lib/Remarks/BitstreamRemarkParser.cpp b/llvm/lib/Remarks/BitstreamRemarkParser.cpp
index 6dd032f07e72..15b2ea9fad08 100644
--- a/llvm/lib/Remarks/BitstreamRemarkParser.cpp
+++ b/llvm/lib/Remarks/BitstreamRemarkParser.cpp
@@ -342,6 +342,13 @@ Expected<std::unique_ptr<Remark>> BitstreamRemarkParser::next() {
   return parseRemark();
 }
 
+BitstreamRemarkParser::BitstreamRemarkParser(StringRef Buf)
+    : RemarkParser(Format::Bitstream), ParserHelper(Buf) {}
+
+BitstreamRemarkParser::BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab)
+    : RemarkParser(Format::Bitstream), ParserHelper(Buf),
+      StrTab(std::move(StrTab)) {}
+
 Error BitstreamRemarkParser::parseMeta() {
   // Advance and to the meta block.
   if (Error E = advanceToMetaBlock(ParserHelper))
diff --git a/llvm/lib/Remarks/BitstreamRemarkParser.h b/llvm/lib/Remarks/BitstreamRemarkParser.h
index fc786fc57622..08e189c92246 100644
--- a/llvm/lib/Remarks/BitstreamRemarkParser.h
+++ b/llvm/lib/Remarks/BitstreamRemarkParser.h
@@ -45,13 +45,10 @@ struct BitstreamRemarkParser : public RemarkParser {
 
   /// Create a parser that expects to find a string table embedded in the
   /// stream.
-  explicit BitstreamRemarkParser(StringRef Buf)
-      : RemarkParser(Format::Bitstream), ParserHelper(Buf) {}
+  explicit BitstreamRemarkParser(StringRef Buf);
 
   /// Create a parser that uses a pre-parsed string table.
-  BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab)
-      : RemarkParser(Format::Bitstream), ParserHelper(Buf),
-        StrTab(std::move(StrTab)) {}
+  BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab);
 
   Expected<std::unique_ptr<Remark>> next() override;
 
diff --git a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
index 3a9a89d61355..d357828962f9 100644
--- a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
+++ b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
@@ -7535,7 +7535,7 @@ struct AAPrivatizablePtrArgument final : public AAPrivatizablePtrImpl {
     // beginning and initialized with the values passed through arguments. The
     // new alloca replaces the use of the old pointer argument.
     Attributor::ArgumentReplacementInfo::CalleeRepairCBTy FnRepairCB =
-        [=](const Attributor::ArgumentReplacementInfo &ARI,
+        [=, this](const Attributor::ArgumentReplacementInfo &ARI,
             Function &ReplacementFn, Function::arg_iterator ArgIt) {
           BasicBlock &EntryBB = ReplacementFn.getEntryBlock();
           Instruction *IP = &*EntryBB.getFirstInsertionPt();
@@ -7559,7 +7559,7 @@ struct AAPrivatizablePtrArgument final : public AAPrivatizablePtrImpl {
     // of the privatizable type are loaded prior to the call and passed to the
     // new function version.
     Attributor::ArgumentReplacementInfo::ACSRepairCBTy ACSRepairCB =
-        [=](const Attributor::ArgumentReplacementInfo &ARI,
+        [=, this](const Attributor::ArgumentReplacementInfo &ARI,
             AbstractCallSite ACS, SmallVectorImpl<Value *> &NewArgOperands) {
           // When no alignment is specified for the load instruction,
           // natural alignment is assumed.


diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
index d7e40e8ef978..946223f6e34d 100644
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
@@ -1035,9 +1035,8 @@ void reportVectorizationFailure(const StringRef DebugMsg,
                                 Instruction *I) {
   LLVM_DEBUG(debugVectorizationMessage("Not vectorizing: ", DebugMsg, I));
   LoopVectorizeHints Hints(TheLoop, true /* doesn't matter */, *ORE);
-  ORE->emit(
-      createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I)
-      << "loop not vectorized: " << OREMsg);
+  auto lva = createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I);
+  ORE->emit(lva << "loop not vectorized: " << OREMsg);
 }
 
 void reportVectorizationInfo(const StringRef Msg, const StringRef ORETag,
@@ -1045,9 +1044,8 @@ void reportVectorizationInfo(const StringRef Msg, const StringRef ORETag,
                              Instruction *I) {
   LLVM_DEBUG(debugVectorizationMessage("", Msg, I));
   LoopVectorizeHints Hints(TheLoop, true /* doesn't matter */, *ORE);
-  ORE->emit(
-      createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I)
-      << Msg);
+  auto lva = createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I);
+  ORE->emit(lva << Msg);
 }
 
 } // end namespace llvm
@@ -3071,9 +3069,10 @@ BasicBlock *InnerLoopVectorizer::emitMemRuntimeChecks(BasicBlock *Bypass) {
            "Cannot emit memory checks when optimizing for size, unless forced "
            "to vectorize.");
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationCodeSize",
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationCodeSize",
                                         OrigLoop->getStartLoc(),
-                                        OrigLoop->getHeader())
+                                        OrigLoop->getHeader());
+      return ora_instance
              << "Code-size may be reduced by not forcing "
                 "vectorization, or by source-code modifications "
                 "eliminating the need for runtime checks "
@@ -4997,9 +4996,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
                         << " is unsafe, clamping to max safe VF="
                         << MaxSafeFixedVF << ".\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is unsafe, clamping to maximum safe vectorization factor "
@@ -5013,9 +5013,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
                         << " is ignored because scalable vectors are not "
                            "available.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is ignored because the target does not support scalable "
@@ -5025,9 +5026,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
       LLVM_DEBUG(dbgs() << "LV: User VF=" << UserVF
                         << " is unsafe. Ignoring scalable UserVF.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is unsafe. Ignoring the hint to let the compiler pick a "
@@ -8336,7 +8338,7 @@ VPWidenIntOrFpInductionRecipe *VPRecipeBuilder::tryToOptimizeInductionTruncate(
   // can be optimized.
   auto isOptimizableIVTruncate =
       [&](Instruction *K) -> std::function<bool(ElementCount)> {
-    return [=](ElementCount VF) -> bool {
+    return [=, this](ElementCount VF) -> bool {
       return CM.isOptimizableIVTruncate(K, VF);
     };
   };
@@ -10026,8 +10028,9 @@ static void checkMixedPrecision(Loop *L, OptimizationRemarkEmitter *ORE) {
     // constant or a function return type and point the user to it.
     if (isa<FPExtInst>(I) && EmittedRemark.insert(I).second)
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(LV_NAME, "VectorMixedPrecision",
-                                          I->getDebugLoc(), L->getHeader())
+        OptimizationRemarkAnalysis ora_instance(LV_NAME, "VectorMixedPrecision",
+                                          I->getDebugLoc(), L->getHeader());
+        return ora_instance
                << "floating point conversion changes vector width. "
                << "Mixed floating point precision requires an up/down "
                << "cast that will negatively impact performance.";
@@ -10284,9 +10287,10 @@ bool LoopVectorizePass::processLoop(Loop *L) {
   if (!LVL.canVectorizeFPMath(AllowOrderedReductions)) {
     ORE->emit([&]() {
       auto *ExactFPMathInst = Requirements.getExactFPInst();
-      return OptimizationRemarkAnalysisFPCommute(DEBUG_TYPE, "CantReorderFPOps",
+      OptimizationRemarkAnalysisFPCommute orafpc(DEBUG_TYPE, "CantReorderFPOps",
                                                  ExactFPMathInst->getDebugLoc(),
-                                                 ExactFPMathInst->getParent())
+                                                 ExactFPMathInst->getParent());
+      return orafpc
              << "loop not vectorized: cannot prove it is safe to reorder "
                 "floating-point operations";
     });
@@ -10333,9 +10337,10 @@ bool LoopVectorizePass::processLoop(Loop *L) {
         !areRuntimeChecksProfitable(Checks, VF, getVScaleForTuning(L, *TTI), L,
                                     *PSE.getSE())) {
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysisAliasing(
+        OptimizationRemarkAnalysisAliasing oraa(
                    DEBUG_TYPE, "CantReorderMemOps", L->getStartLoc(),
-                   L->getHeader())
+                   L->getHeader());
+        return oraa
                << "loop not vectorized: cannot prove it is safe to reorder "
                   "memory operations";
       });
@@ -10396,29 +10401,32 @@ bool LoopVectorizePass::processLoop(Loop *L) {
   if (!VectorizeLoop && !InterleaveLoop) {
     // Do not vectorize or interleaving the loop.
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(VAPassName, VecDiagMsg.first,
-                                      L->getStartLoc(), L->getHeader())
+      OptimizationRemarkMissed orm_instance(VAPassName, VecDiagMsg.first,
+                                      L->getStartLoc(), L->getHeader());
+      return orm_instance
              << VecDiagMsg.second;
     });
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(LV_NAME, IntDiagMsg.first,
-                                      L->getStartLoc(), L->getHeader())
-             << IntDiagMsg.second;
+      OptimizationRemarkMissed orm_instance(LV_NAME, IntDiagMsg.first,
+                                      L->getStartLoc(), L->getHeader());
+      return orm_instance << IntDiagMsg.second;
     });
     return false;
   } else if (!VectorizeLoop && InterleaveLoop) {
     LLVM_DEBUG(dbgs() << "LV: Interleave Count is " << IC << '\n');
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(VAPassName, VecDiagMsg.first,
-                                        L->getStartLoc(), L->getHeader())
+      OptimizationRemarkAnalysis ora_instance(VAPassName, VecDiagMsg.first,
+                                        L->getStartLoc(), L->getHeader());
+      return ora_instance
              << VecDiagMsg.second;
     });
   } else if (VectorizeLoop && !InterleaveLoop) {
     LLVM_DEBUG(dbgs() << "LV: Found a vectorizable loop (" << VF.Width
                       << ") in " << DebugLocStr << '\n');
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(LV_NAME, IntDiagMsg.first,
-                                        L->getStartLoc(), L->getHeader())
+      OptimizationRemarkAnalysis ora_instance(LV_NAME, IntDiagMsg.first,
+                                        L->getStartLoc(), L->getHeader());
+      return ora_instance
              << IntDiagMsg.second;
     });
   } else if (VectorizeLoop && InterleaveLoop) {
@@ -10442,8 +10450,9 @@ bool LoopVectorizePass::processLoop(Loop *L) {
       LVP.executePlan(VF.Width, IC, BestPlan, Unroller, DT, false);
 
       ORE->emit([&]() {
-        return OptimizationRemark(LV_NAME, "Interleaved", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark or_instance(LV_NAME, "Interleaved", L->getStartLoc(),
+                                  L->getHeader());
+        return or_instance
                << "interleaved loop (interleaved count: "
                << NV("InterleaveCount", IC) << ")";
       });
@@ -10554,8 +10563,9 @@ bool LoopVectorizePass::processLoop(Loop *L) {
       }
       // Report the vectorization decision.
       ORE->emit([&]() {
-        return OptimizationRemark(LV_NAME, "Vectorized", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark or_instance(LV_NAME, "Vectorized", L->getStartLoc(),
+                                  L->getHeader());
+        return or_instance
                << "vectorized loop (vectorization width: "
                << NV("VectorizationFactor", VF.Width)
                << ", interleaved count: " << NV("InterleaveCount", IC) << ")";


diff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
index 821a3fa22a85..62c6ccc27f4b 100644
--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
@@ -7258,7 +7258,7 @@ public:
     if (CommonMask.empty())
       return Cost;
     int Limit = CommonMask.size() * 2;
-    if (all_of(CommonMask, [=](int Idx) { return Idx < Limit; }) &&
+    if (all_of(CommonMask, [=, this](int Idx) { return Idx < Limit; }) &&
         ShuffleVectorInst::isIdentityMask(CommonMask))
       return Cost;
     return Cost +
@@ -7445,7 +7445,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       E->isAltShuffle() ? (unsigned)Instruction::ShuffleVector : E->getOpcode();
   const unsigned Sz = VL.size();
   auto GetCostDiff =
-      [=](function_ref<InstructionCost(unsigned)> ScalarEltCost,
+      [=, this](function_ref<InstructionCost(unsigned)> ScalarEltCost,
           function_ref<InstructionCost(InstructionCost)> VectorCost) {
         // Calculate the cost of this instruction.
         InstructionCost ScalarCost = 0;
@@ -7466,7 +7466,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       };
   // Calculate cost difference from vectorizing set of GEPs.
   // Negative value means vectorizing is profitable.
-  auto GetGEPCostDiff = [=](ArrayRef<Value *> Ptrs, Value *BasePtr) {
+  auto GetGEPCostDiff = [=, this](ArrayRef<Value *> Ptrs, Value *BasePtr) {
     InstructionCost ScalarCost = 0;
     InstructionCost VecCost = 0;
     // Here we differentiate two cases: (1) when Ptrs represent a regular
@@ -7571,7 +7571,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   }
   case Instruction::ExtractValue:
   case Instruction::ExtractElement: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *I = cast<Instruction>(VL[Idx]);
       VectorType *SrcVecTy;
       if (ShuffleOrOp == Instruction::ExtractElement) {
@@ -7729,13 +7729,13 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   case Instruction::Trunc:
   case Instruction::FPTrunc:
   case Instruction::BitCast: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       return TTI->getCastInstrCost(E->getOpcode(), ScalarTy,
                                    VI->getOperand(0)->getType(),
                                    TTI::getCastContextHint(VI), CostKind, VI);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       Type *SrcTy = VL0->getOperand(0)->getType();
       auto *SrcVecTy = FixedVectorType::get(SrcTy, VL.size());
       InstructionCost VecCost = CommonCost;
@@ -7821,7 +7821,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   case Instruction::And:
   case Instruction::Or:
   case Instruction::Xor: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       unsigned OpIdx = isa<UnaryOperator>(VI) ? 0 : 1;
       TTI::OperandValueInfo Op1Info = TTI::getOperandInfo(VI->getOperand(0));
@@ -7831,7 +7831,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       return TTI->getArithmeticInstrCost(ShuffleOrOp, ScalarTy, CostKind,
                                          Op1Info, Op2Info, Operands, VI);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       unsigned OpIdx = isa<UnaryOperator>(VL0) ? 0 : 1;
       TTI::OperandValueInfo Op1Info = getOperandInfo(VL, 0);
       TTI::OperandValueInfo Op2Info = getOperandInfo(VL, OpIdx);
@@ -7845,14 +7845,14 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
     return CommonCost + GetGEPCostDiff(VL, VL0);
   }
   case Instruction::Load: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<LoadInst>(VL[Idx]);
       return TTI->getMemoryOpCost(Instruction::Load, ScalarTy, VI->getAlign(),
                                   VI->getPointerAddressSpace(), CostKind,
                                   TTI::OperandValueInfo(), VI);
     };
     auto *LI0 = cast<LoadInst>(VL0);
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       InstructionCost VecLdCost;
       if (E->State == TreeEntry::Vectorize) {
         VecLdCost = TTI->getMemoryOpCost(
@@ -7885,7 +7885,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   }
   case Instruction::Store: {
     bool IsReorder = !E->ReorderIndices.empty();
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<StoreInst>(VL[Idx]);
       TTI::OperandValueInfo OpInfo = getOperandInfo(VI, 0);
       return TTI->getMemoryOpCost(Instruction::Store, ScalarTy, VI->getAlign(),
@@ -7894,7 +7894,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
     };
     auto *BaseSI =
         cast<StoreInst>(IsReorder ? VL[E->ReorderIndices.front()] : VL0);
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       // We know that we can merge the stores. Calculate the cost.
       TTI::OperandValueInfo OpInfo = getOperandInfo(VL, 0);
       return TTI->getMemoryOpCost(Instruction::Store, VecTy, BaseSI->getAlign(),
@@ -7912,7 +7912,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
            GetGEPCostDiff(PointerOps, BaseSI->getPointerOperand());
   }
   case Instruction::Call: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *CI = cast<CallInst>(VL[Idx]);
       Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);
       if (ID != Intrinsic::not_intrinsic) {
@@ -7923,7 +7923,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
                                    CI->getFunctionType()->getReturnType(),
                                    CI->getFunctionType()->params(), CostKind);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       auto *CI = cast<CallInst>(VL0);
       auto VecCallCosts = getVectorCallCosts(CI, VecTy, TTI, TLI);
       return std::min(VecCallCosts.first, VecCallCosts.second) + CommonCost;
@@ -7940,7 +7940,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
            "Invalid Shuffle Vector Operand");
     // Try to find the previous shuffle node with the same operands and same
     // main/alternate ops.
-    auto TryFindNodeWithEqualOperands = [=]() {
+    auto TryFindNodeWithEqualOperands = [=, this]() {
       for (const std::unique_ptr<TreeEntry> &TE : VectorizableTree) {
         if (TE.get() == E)
           break;
@@ -7954,7 +7954,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       }
       return false;
     };
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       assert(E->isOpcodeOrAlt(VI) && "Unexpected main/alternate opcode");
       (void)E;
@@ -8835,7 +8835,7 @@ BoUpSLP::isGatherShuffledEntry(const TreeEntry *TE, ArrayRef<Value *> VL,
       return TE1->Idx < TE2->Idx;
     });
     // Try to find the perfect match in another gather node at first.
-    auto *It = find_if(FirstEntries, [=](const TreeEntry *EntryPtr) {
+    auto *It = find_if(FirstEntries, [=, this](const TreeEntry *EntryPtr) {
       return EntryPtr->isSame(VL) || EntryPtr->isSame(TE->Scalars);
     });
     if (It != FirstEntries.end() && (*It)->getVectorFactor() == VL.size()) {
@@ -8921,7 +8921,7 @@ BoUpSLP::isGatherShuffledEntry(const TreeEntry *TE, ArrayRef<Value *> VL,
   // We suppose it is better to ignore instruction, which do not form splats,
   // are not vectorized/not extractelements (these instructions will be handled
   // by extractelements processing) or may form vector node in future.
-  auto MightBeIgnored = [=](Value *V) {
+  auto MightBeIgnored = [=, this](Value *V) {
     auto *I = dyn_cast<Instruction>(V);
     SmallVector<Value *> IgnoredVals;
     if (UserIgnoreList)
@@ -9082,7 +9082,7 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {
   // constant indeces).
   auto *Front = E->getMainOp();
   auto *BB = Front->getParent();
-  assert(llvm::all_of(E->Scalars, [=](Value *V) -> bool {
+  assert(llvm::all_of(E->Scalars, [=, this](Value *V) -> bool {
     if (E->getOpcode() == Instruction::GetElementPtr &&
         !isa<GetElementPtrInst>(V))
       return true;
@@ -9775,8 +9775,8 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Args &...Params) {
     if (UserTE->getNumOperands() != 2)
       return false;
     auto *It =
-        find_if(VectorizableTree, [=](const std::unique_ptr<TreeEntry> &TE) {
-          return find_if(TE->UserTreeIndices, [=](const EdgeInfo &EI) {
+        find_if(VectorizableTree, [=, this](const std::unique_ptr<TreeEntry> &TE) {
+          return find_if(TE->UserTreeIndices, [=, this](const EdgeInfo &EI) {
                    return EI.UserTE == UserTE && EI.EdgeIdx != EdgeIdx;
                  }) != TE->UserTreeIndices.end();
         });
@@ -10067,7 +10067,7 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Args &...Params) {
       Value *BV = ShuffleBuilder.gather(GatheredScalars);
       ShuffleBuilder.add(BV, BVMask);
     }
-    if (all_of(NonConstants, [=](Value *V) {
+    if (all_of(NonConstants, [=, this](Value *V) {
           return isa<PoisonValue>(V) ||
                  (IsSingleShuffle && ((IsIdentityShuffle &&
                   IsNonPoisoned) || IsUsedInExpr) && isa<UndefValue>(V));
@@ -12326,9 +12326,9 @@ bool SLPVectorizerPass::vectorizeStoreChain(ArrayRef<Value *> Chain, BoUpSLP &R,
     LLVM_DEBUG(dbgs() << "SLP: Decided to vectorize cost = " << Cost << "\n");
 
     using namespace ore;
-
-    R.getORE()->emit(OptimizationRemark(SV_NAME, "StoresVectorized",
-                                        cast<StoreInst>(Chain[0]))
+    OptimizationRemark or_instance(SV_NAME, "StoresVectorized",
+                                        cast<StoreInst>(Chain[0]));
+    R.getORE()->emit(or_instance
                      << "Stores SLP vectorized with cost " << NV("Cost", Cost)
                      << " and with tree size "
                      << NV("TreeSize", R.getTreeSize()));
@@ -12544,7 +12544,8 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
         std::string type_str;
         llvm::raw_string_ostream rso(type_str);
         Ty->print(rso);
-        return OptimizationRemarkMissed(SV_NAME, "UnsupportedType", I0)
+        OptimizationRemarkMissed orm_instance(SV_NAME, "UnsupportedType", I0);
+        return orm_instance
                << "Cannot SLP vectorize list: type "
                << rso.str() + " is unsupported by vectorizer";
       });
@@ -12558,7 +12559,8 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
   MaxVF = std::min(R.getMaximumVF(Sz, S.getOpcode()), MaxVF);
   if (MaxVF < 2) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "SmallVF", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "SmallVF", I0);
+      return orm_instance
              << "Cannot SLP vectorize list: vectorization factor "
              << "less than 2 is not supported";
     });
@@ -12620,8 +12622,9 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
                         << " for VF=" << ActualVF << "\n");
       if (Cost < -SLPCostThreshold) {
         LLVM_DEBUG(dbgs() << "SLP: Vectorizing list at cost:" << Cost << ".\n");
-        R.getORE()->emit(OptimizationRemark(SV_NAME, "VectorizedList",
-                                                    cast<Instruction>(Ops[0]))
+        OptimizationRemark or_instance(SV_NAME, "VectorizedList",
+                                                    cast<Instruction>(Ops[0]));
+        R.getORE()->emit(or_instance
                                  << "SLP vectorized with cost " << ore::NV("Cost", Cost)
                                  << " and with tree size "
                                  << ore::NV("TreeSize", R.getTreeSize()));
@@ -12637,14 +12640,16 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
 
   if (!Changed && CandidateFound) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "NotBeneficial", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "NotBeneficial", I0);
+      return orm_instance
              << "List vectorization was possible but not beneficial with cost "
              << ore::NV("Cost", MinCost) << " >= "
              << ore::NV("Treshold", -SLPCostThreshold);
     });
   } else if (!Changed) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "NotPossible", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "NotPossible", I0);
+      return orm_instance
              << "Cannot SLP vectorize list: vectorization was impossible"
              << " with available vectorization factors";
     });
@@ -13609,9 +13614,10 @@ public:
           return nullptr;
         if (Cost >= -SLPCostThreshold) {
           V.getORE()->emit([&]() {
-            return OptimizationRemarkMissed(
+            OptimizationRemarkMissed orm_instance(
                        SV_NAME, "HorSLPNotBeneficial",
-                       ReducedValsToOps.find(VL[0])->second.front())
+                       ReducedValsToOps.find(VL[0])->second.front());
+            return orm_instance
                    << "Vectorizing horizontal reduction is possible "
                    << "but not beneficial with cost " << ore::NV("Cost", Cost)
                    << " and threshold "
@@ -13625,9 +13631,10 @@ public:
         LLVM_DEBUG(dbgs() << "SLP: Vectorizing horizontal reduction at cost:"
                           << Cost << ". (HorRdx)\n");
         V.getORE()->emit([&]() {
-          return OptimizationRemark(
+          OptimizationRemark or_instance(
                      SV_NAME, "VectorizedHorizontalReduction",
-                     ReducedValsToOps.find(VL[0])->second.front())
+                     ReducedValsToOps.find(VL[0])->second.front());
+          return or_instance
                  << "Vectorized horizontal reduction with cost "
                  << ore::NV("Cost", Cost) << " and with tree size "
                  << ore::NV("TreeSize", V.getTreeSize());


diff --git a/llvm/lib/CodeGen/StackProtector.cpp b/llvm/lib/CodeGen/StackProtector.cpp
index 387b653f8815..70c527969a8b 100644
--- a/llvm/lib/CodeGen/StackProtector.cpp
+++ b/llvm/lib/CodeGen/StackProtector.cpp
@@ -310,7 +310,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
     if (!Layout)
       return true;
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "StackProtectorRequested", F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorRequested", F);
+      return or_instance
              << "Stack protection applied to function "
              << ore::NV("Function", F)
              << " due to a function attribute or command-line switch";
@@ -327,8 +328,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
       if (const AllocaInst *AI = dyn_cast<AllocaInst>(&I)) {
         if (AI->isArrayAllocation()) {
           auto RemarkBuilder = [&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorAllocaOrArray",
-                                      &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorAllocaOrArray", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to a call to alloca or use of a variable length "
@@ -374,7 +375,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
               AI, IsLarge ? MachineFrameInfo::SSPLK_LargeArray
                           : MachineFrameInfo::SSPLK_SmallArray));
           ORE.emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorBuffer", &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorBuffer", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to a stack allocated buffer or struct containing a "
@@ -393,8 +395,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
             return true;
           Layout->insert(std::make_pair(AI, MachineFrameInfo::SSPLK_AddrOf));
           ORE.emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorAddressTaken",
-                                      &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorAddressTaken", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to the address of a local variable being taken";


diff --git a/llvm/lib/CodeGen/ShrinkWrap.cpp b/llvm/lib/CodeGen/ShrinkWrap.cpp
index 4b1d3637a746..052d41be2075 100644
--- a/llvm/lib/CodeGen/ShrinkWrap.cpp
+++ b/llvm/lib/CodeGen/ShrinkWrap.cpp
@@ -804,7 +804,8 @@ static bool giveUpWithRemarks(MachineOptimizationRemarkEmitter *ORE,
                               const DiagnosticLocation &Loc,
                               const MachineBasicBlock *MBB) {
   ORE->emit([&]() {
-    return MachineOptimizationRemarkMissed(DEBUG_TYPE, RemarkName, Loc, MBB)
+    MachineOptimizationRemarkMissed morm_instance(DEBUG_TYPE, RemarkName, Loc, MBB);
+    return morm_instance
            << RemarkMessage;
   });
 

diff --git a/llvm/lib/CodeGen/PrologEpilogInserter.cpp b/llvm/lib/CodeGen/PrologEpilogInserter.cpp
index e323aaaeefaf..ef4aab48bf15 100644
--- a/llvm/lib/CodeGen/PrologEpilogInserter.cpp
+++ b/llvm/lib/CodeGen/PrologEpilogInserter.cpp
@@ -326,9 +326,10 @@ bool PEI::runOnMachineFunction(MachineFunction &MF) {
   }
 
   ORE->emit([&]() {
-    return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "StackSize",
+    MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "StackSize",
                                              MF.getFunction().getSubprogram(),
-                                             &MF.front())
+                                             &MF.front());
+    return mora_instance
            << ore::NV("NumStackBytes", StackSize) << " stack bytes in function";
   });
 


diff --git a/llvm/lib/CodeGen/MachinePipeliner.cpp b/llvm/lib/CodeGen/MachinePipeliner.cpp
index c7e7497dab36..63aaa04c5d98 100644
--- a/llvm/lib/CodeGen/MachinePipeliner.cpp
+++ b/llvm/lib/CodeGen/MachinePipeliner.cpp
@@ -264,9 +264,9 @@ bool MachinePipeliner::scheduleLoop(MachineLoop &L) {
   if (!canPipelineLoop(L)) {
     LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");
     ORE->emit([&]() {
-      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",
-                                             L.getStartLoc(), L.getHeader())
-             << "Failed to pipeline loop";
+      MachineOptimizationRemarkMissed morm_instance(DEBUG_TYPE, "canPipelineLoop",
+                                             L.getStartLoc(), L.getHeader());
+      return morm_instance << "Failed to pipeline loop";
     });
 
     LI.LoopPipelinerInfo.reset();
@@ -335,9 +335,9 @@ void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {
 bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
   if (L.getNumBlocks() != 1) {
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "Not a single basic block: "
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "Not a single basic block: "
              << ore::NV("NumBlocks", L.getNumBlocks());
     });
     return false;
@@ -345,9 +345,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
 
   if (disabledByPragma) {
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "Disabled by Pragma.";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "Disabled by Pragma.";
     });
     return false;
   }
@@ -361,9 +361,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");
     NumFailBranch++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "The branch can't be understood";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "The branch can't be understood";
     });
     return false;
   }
@@ -375,9 +375,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");
     NumFailLoop++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "The loop structure is not supported";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "The loop structure is not supported";
     });
     return false;
   }
@@ -386,9 +386,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");
     NumFailPreheader++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "No loop preheader found";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "No loop preheader found";
     });
     return false;
   }
@@ -524,9 +524,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");
     NumFailZeroMII++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Invalid Minimal Initiation Interval: 0";
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Invalid Minimal Initiation Interval: 0";
     });
     return;
   }
@@ -537,9 +537,9 @@ void SwingSchedulerDAG::schedule() {
                       << ", we don't pipeline large loops\n");
     NumFailLargeMaxMII++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Minimal Initiation Interval too large: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Minimal Initiation Interval too large: "
              << ore::NV("MII", (int)MII) << " > "
              << ore::NV("SwpMaxMii", SwpMaxMii) << "."
              << "Refer to -pipeliner-max-mii.";
@@ -587,9 +587,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "No schedule found, return\n");
     NumFailNoSchedule++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Unable to find schedule";
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Unable to find schedule";
     });
     return;
   }
@@ -600,8 +600,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");
     NumFailZeroStage++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance
              << "No need to pipeline - no overlapped iterations in schedule.";
     });
     return;
@@ -612,9 +613,9 @@ void SwingSchedulerDAG::schedule() {
                       << " : too many stages, abort\n");
     NumFailLargeMaxStage++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Too many stages in schedule: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Too many stages in schedule: "
              << ore::NV("numStages", (int)numStages) << " > "
              << ore::NV("SwpMaxStages", SwpMaxStages)
              << ". Refer to -pipeliner-max-stages.";
@@ -623,9 +624,9 @@ void SwingSchedulerDAG::schedule() {
   }
 
   Pass.ORE->emit([&]() {
-    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),
-                                     Loop.getHeader())
-           << "Pipelined succesfully!";
+    MachineOptimizationRemark mor_instance(DEBUG_TYPE, "schedule", Loop.getStartLoc(),
+                                     Loop.getHeader());
+    return mor_instance << "Pipelined succesfully!";
   });
 
   // Generate the schedule as a ModuloSchedule.
@@ -2059,9 +2060,9 @@ bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {
   if (scheduleFound) {
     Schedule.finalizeSchedule(this);
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Schedule found with Initiation Interval: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Schedule found with Initiation Interval: "
              << ore::NV("II", Schedule.getInitiationInterval())
              << ", MaxStageCount: "
              << ore::NV("MaxStageCount", Schedule.getMaxStageCount());


diff --git a/llvm/include/llvm/CodeGen/BasicTTIImpl.h b/llvm/include/llvm/CodeGen/BasicTTIImpl.h
index 383fdd1f4d79..3af245731700 100644
--- a/llvm/include/llvm/CodeGen/BasicTTIImpl.h
+++ b/llvm/include/llvm/CodeGen/BasicTTIImpl.h
@@ -590,8 +590,9 @@ public:
 
           if (ORE) {
             ORE->emit([&]() {
-              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),
-                                        L->getHeader())
+              OptimizationRemark or_instance("TTI", "DontUnroll", L->getStartLoc(),
+                                        L->getHeader());
+              return or_instance
                      << "advising against unrolling the loop because it "
                         "contains a "
                      << ore::NV("Call", &I);


diff --git a/llvm/lib/CodeGen/HardwareLoops.cpp b/llvm/lib/CodeGen/HardwareLoops.cpp
index e7b14d700a44..4d82bdcbee44 100644
--- a/llvm/lib/CodeGen/HardwareLoops.cpp
+++ b/llvm/lib/CodeGen/HardwareLoops.cpp
@@ -112,7 +112,8 @@ namespace {
   void reportHWLoopFailure(const StringRef Msg, const StringRef ORETag,
       OptimizationRemarkEmitter *ORE, Loop *TheLoop, Instruction *I = nullptr) {
     LLVM_DEBUG(debugHWLoopFailure(Msg, I));
-    ORE->emit(createHWLoopAnalysis(ORETag, TheLoop, I) << Msg);
+    auto hwla_instance = createHWLoopAnalysis(ORETag, TheLoop, I);
+    ORE->emit(hwla_instance << Msg);
   }
 
   using TTI = TargetTransformInfo;
diff --git a/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp b/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
index d0ad6e45b4d3..6e6e361cdd7d 100644
--- a/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
+++ b/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
@@ -1243,8 +1243,8 @@ bool InterleavedLoadCombineImpl::combine(std::list<VectorInfo> &InterleavedLoad,
 
   NumInterleavedLoadCombine++;
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Combined Interleaved Load", LI)
-           << "Load interleaved combined with factor "
+    OptimizationRemark or_instance(DEBUG_TYPE, "Combined Interleaved Load", LI);
+    return or_instance << "Load interleaved combined with factor "
            << ore::NV("Factor", Factor);
   });
 

diff --git a/llvm/lib/CodeGen/AtomicExpandPass.cpp b/llvm/lib/CodeGen/AtomicExpandPass.cpp
index 80a0bb957cfc..dcf5b9584cf9 100644
--- a/llvm/lib/CodeGen/AtomicExpandPass.cpp
+++ b/llvm/lib/CodeGen/AtomicExpandPass.cpp
@@ -605,7 +605,8 @@ bool AtomicExpand::tryExpandAtomicRMW(AtomicRMWInst *AI) {
                           : SSNs[AI->getSyncScopeID()];
       OptimizationRemarkEmitter ORE(AI->getFunction());
       ORE.emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "Passed", AI)
+        OptimizationRemark or_instance(DEBUG_TYPE, "Passed", AI);
+        return or_instance
                << "A compare and swap loop was generated for an atomic "
                << AI->getOperationName(AI->getOperation()) << " operation at "
                << MemScope << " memory scope";


diff --git a/llvm/lib/Analysis/MLInlineAdvisor.cpp b/llvm/lib/Analysis/MLInlineAdvisor.cpp
index 0660a9993b6d..ad7e3a465039 100644
--- a/llvm/lib/Analysis/MLInlineAdvisor.cpp
+++ b/llvm/lib/Analysis/MLInlineAdvisor.cpp
@@ -345,7 +345,8 @@ std::unique_ptr<InlineAdvice> MLInlineAdvisor::getAdviceImpl(CallBase &CB) {
   // we just return the base InlineAdvice, which acts as a noop.
   if (ForceStop) {
     ORE.emit([&] {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ForceStop", &CB)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ForceStop", &CB);
+      return orm_instance
              << "Won't attempt inlining because module size grew too much.";
     });
     return std::make_unique<InlineAdvice>(this, CB, ORE, Mandatory);


diff --git a/llvm/lib/Analysis/InlineAdvisor.cpp b/llvm/lib/Analysis/InlineAdvisor.cpp
index e2480d51d372..55aee48ffeee 100644
--- a/llvm/lib/Analysis/InlineAdvisor.cpp
+++ b/llvm/lib/Analysis/InlineAdvisor.cpp
@@ -89,8 +89,9 @@ private:
   void recordUnsuccessfulInliningImpl(const InlineResult &Result) override {
     if (IsInliningRecommended)
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(Advisor->getAnnotatedInlinePassName(),
-                                        "NotInlined", DLoc, Block)
+        OptimizationRemarkMissed orm_instance(Advisor->getAnnotatedInlinePassName(),
+                                        "NotInlined", DLoc, Block);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' is not AlwaysInline into '"
                << NV("Caller", Caller)
                << "': " << NV("Reason", Result.getFailureReason());
@@ -109,8 +110,9 @@ void DefaultInlineAdvice::recordUnsuccessfulInliningImpl(
   llvm::setInlineRemark(*OriginalCB, std::string(Result.getFailureReason()) +
                                          "; " + inlineCostStr(*OIC));
   ORE.emit([&]() {
-    return OptimizationRemarkMissed(Advisor->getAnnotatedInlinePassName(),
-                                    "NotInlined", DLoc, Block)
+    OptimizationRemarkMissed orm_instance(Advisor->getAnnotatedInlinePassName(),
+                                    "NotInlined", DLoc, Block);
+    return orm_instance
            << "'" << NV("Callee", Callee) << "' is not inlined into '"
            << NV("Caller", Caller)
            << "': " << NV("Reason", Result.getFailureReason());
@@ -394,14 +396,16 @@ llvm::shouldInline(CallBase &CB,
                       << ", Call: " << CB << "\n");
     if (IC.isNever()) {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline", Call)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline", Call);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' not inlined into '"
                << NV("Caller", Caller)
                << "' because it should never be inlined " << IC;
       });
     } else {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "TooCostly", Call)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "TooCostly", Call);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' not inlined into '"
                << NV("Caller", Caller) << "' because too costly to inline "
                << IC;
@@ -418,8 +422,9 @@ llvm::shouldInline(CallBase &CB,
                       << " Cost = " << IC.getCost()
                       << ", outer Cost = " << TotalSecondaryCost << '\n');
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IncreaseCostInOtherContexts",
-                                      Call)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "IncreaseCostInOtherContexts",
+                                      Call);
+      return orm_instance
              << "Not inlining. Cost of inlining '" << NV("Callee", Callee)
              << "' increases the cost of inlining '" << NV("Caller", Caller)
              << "' in other contexts";


diff --git a/llvm/lib/Analysis/InlineCost.cpp b/llvm/lib/Analysis/InlineCost.cpp
index 9ff277f5334e..18b7909983bf 100644
--- a/llvm/lib/Analysis/InlineCost.cpp
+++ b/llvm/lib/Analysis/InlineCost.cpp
@@ -2511,8 +2511,9 @@ CallAnalyzer::analyzeBlock(BasicBlock *BB,
     if (!IR.isSuccess()) {
       if (ORE)
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline",
-                                          &CandidateCall)
+          OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline",
+                                          &CandidateCall);
+          return orm_instance
                  << NV("Callee", &F) << " has uninlinable pattern ("
                  << NV("InlineResult", IR.getFailureReason())
                  << ") and cost is not fully computed";
@@ -2528,8 +2529,9 @@ CallAnalyzer::analyzeBlock(BasicBlock *BB,
           InlineResult::failure("recursive and allocates too much stack space");
       if (ORE)
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline",
-                                          &CandidateCall)
+          OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline",
+                                          &CandidateCall);
+          return orm_instance
                  << NV("Callee", &F) << " is "
                  << NV("InlineResult", IR.getFailureReason())
                  << ". Cost is not fully computed";


diff --git a/llvm/lib/Transforms/Coroutines/CoroElide.cpp b/llvm/lib/Transforms/Coroutines/CoroElide.cpp
index d78ab1c1ea28..f2ab0a9ae336 100644
--- a/llvm/lib/Transforms/Coroutines/CoroElide.cpp
+++ b/llvm/lib/Transforms/Coroutines/CoroElide.cpp
@@ -347,9 +347,10 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
   bool ShouldElide = shouldElide(CoroId->getFunction(), DT);
   if (!ShouldElide)
     ORE.emit([&]() {
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "CoroElide", CoroId);
       if (auto FrameSizeAndAlign =
               getFrameLayout(cast<Function>(ResumeAddrConstant)))
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -357,7 +358,7 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
                << ore::NV("frame_size", FrameSizeAndAlign->first) << ", align="
                << ore::NV("align", FrameSizeAndAlign->second.value()) << ")";
       else
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -384,7 +385,8 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
             << CoroId->getFunction()->getName() << "\n";
 #endif
       ORE.emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "CoroElide", CoroId)
+        OptimizationRemark or_instance(DEBUG_TYPE, "CoroElide", CoroId);
+        return or_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -394,7 +396,8 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
       });
     } else {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "CoroElide", CoroId);
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())


diff --git a/llvm/lib/Transforms/Coroutines/CoroSplit.cpp b/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
index 39e909bf3316..589685dad85b 100644
--- a/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
+++ b/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
@@ -2152,7 +2152,8 @@ PreservedAnalyses CoroSplitPass::run(LazyCallGraph::SCC &C,
     updateCallGraphAfterCoroutineSplit(*N, Shape, Clones, C, CG, AM, UR, FAM);
 
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "CoroSplit", &F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "CoroSplit", &F);
+      return or_instance
              << "Split '" << ore::NV("function", F.getName())
              << "' (frame_size=" << ore::NV("frame_size", Shape.FrameSize)
              << ", align=" << ore::NV("align", Shape.FrameAlign.value()) << ")";
diff --git a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
index d33258642365..ab0df88113de 100644
--- a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
+++ b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
@@ -422,7 +422,8 @@ struct VirtualCallSite {
     BasicBlock *Block = CB.getParent();
 
     using namespace ore;
-    OREGetter(F).emit(OptimizationRemark(DEBUG_TYPE, OptName, DLoc, Block)
+    OptimizationRemark or_instance(DEBUG_TYPE, OptName, DLoc, Block);
+    OREGetter(F).emit(or_instance
                       << NV("Optimization", OptName)
                       << ": devirtualized a call to "
                       << NV("FunctionName", TargetName));
@@ -2360,7 +2361,8 @@ bool DevirtModule::run() {
       }
 
       using namespace ore;
-      OREGetter(F).emit(OptimizationRemark(DEBUG_TYPE, "Devirtualized", F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "Devirtualized", F);
+      OREGetter(F).emit(or_instance
                         << "devirtualized "
                         << NV("FunctionName", DT.first));
     }


diff --git a/llvm/lib/Transforms/IPO/ModuleInliner.cpp b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
index 5e91ab80d750..83c6eff887e1 100644
--- a/llvm/lib/Transforms/IPO/ModuleInliner.cpp
+++ b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
@@ -153,7 +153,8 @@ PreservedAnalyses ModuleInlinerPass::run(Module &M,
             using namespace ore;
             setInlineRemark(*CB, "unavailable definition");
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "NoDefinition", &I)
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NoDefinition", &I);
+              return orm_instance
                      << NV("Callee", Callee) << " will not be inlined into "
                      << NV("Caller", CB->getCaller())
                      << " because its definition is unavailable"
diff --git a/llvm/lib/Transforms/IPO/PartialInlining.cpp b/llvm/lib/Transforms/IPO/PartialInlining.cpp
index b88ba2dec24b..689226f9098a 100644
--- a/llvm/lib/Transforms/IPO/PartialInlining.cpp
+++ b/llvm/lib/Transforms/IPO/PartialInlining.cpp
@@ -374,9 +374,9 @@ PartialInlinerImpl::computeOutliningColdRegionsInfo(
         if (!is_contained(BlockList, Succ)) {
           if (ExitBlock) {
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "MultiExitRegion",
-                                              &Succ->front())
-                     << "Region dominated by "
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "MultiExitRegion",
+                                              &Succ->front());
+              return orm_instance << "Region dominated by "
                      << ore::NV("Block", BlockList.front()->getName())
                      << " has more than one region exit edge.";
             });
@@ -476,9 +476,9 @@ PartialInlinerImpl::computeOutliningColdRegionsInfo(
 
       if (!SkipCostAnalysis && OutlineRegionCost < MinOutlineRegionCost) {
         ORE.emit([&]() {
-          return OptimizationRemarkAnalysis(DEBUG_TYPE, "TooCostly",
-                                            &SI->front())
-                 << ore::NV("Callee", &F)
+          OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "TooCostly",
+                                            &SI->front());
+          return ora_instance << ore::NV("Callee", &F)
                  << " inline cost-savings smaller than "
                  << ore::NV("Cost", MinOutlineRegionCost);
         });
@@ -737,8 +737,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (IC.isAlways()) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "AlwaysInline", &CB)
-             << NV("Callee", Cloner.OrigFunc)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "AlwaysInline", &CB);
+      return ora_instance << NV("Callee", Cloner.OrigFunc)
              << " should always be fully inlined, not partially";
     });
     return false;
@@ -746,7 +746,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (IC.isNever()) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline", &CB)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline", &CB);
+      return orm_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller)
              << " because it should never be inlined (cost=never)";
@@ -756,7 +757,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (!IC) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "TooCostly", &CB)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "TooCostly", &CB);
+      return ora_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller) << " because too costly to inline (cost="
              << NV("Cost", IC.getCost()) << ", threshold="
@@ -773,8 +775,9 @@ bool PartialInlinerImpl::shouldPartialInline(
   // Weighted saving is smaller than weighted cost, return false
   if (NormWeightedSavings < WeightedOutliningRcost) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "OutliningCallcostTooHigh",
-                                        &CB)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "OutliningCallcostTooHigh",
+                                        &CB);
+      return ora_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller) << " runtime overhead (overhead="
              << NV("Overhead", (unsigned)WeightedOutliningRcost.getFrequency())
@@ -788,7 +791,8 @@ bool PartialInlinerImpl::shouldPartialInline(
   }
 
   ORE.emit([&]() {
-    return OptimizationRemarkAnalysis(DEBUG_TYPE, "CanBePartiallyInlined", &CB)
+    OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "CanBePartiallyInlined", &CB);
+    return ora_instance
            << NV("Callee", Cloner.OrigFunc) << " can be partially inlined into "
            << NV("Caller", Caller) << " with cost=" << NV("Cost", IC.getCost())
            << " (threshold="
@@ -1144,8 +1148,9 @@ bool PartialInlinerImpl::FunctionCloner::doMultiRegionFunctionOutlining() {
       }
     } else
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                        &RegionInfo.Region.front()->front())
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                        &RegionInfo.Region.front()->front());
+        return orm_instance
                << "Failed to extract region at block "
                << ore::NV("Block", RegionInfo.Region.front());
       });
@@ -1204,8 +1209,9 @@ PartialInlinerImpl::FunctionCloner::doSingleRegionFunctionOutlining() {
     OutlinedFunctions.push_back(std::make_pair(OutlinedFunc, OutliningCallBB));
   } else
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                      &ToExtract.front()->front())
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                      &ToExtract.front()->front());
+      return orm_instance
              << "Failed to extract region at block "
              << ore::NV("Block", ToExtract.front());
     });
@@ -1336,8 +1342,9 @@ bool PartialInlinerImpl::tryPartialInline(FunctionCloner &Cloner) {
     BasicBlock *Block;
     std::tie(DLoc, Block) = getOneDebugLoc(*Cloner.ClonedFunc);
     OrigFuncORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "OutlineRegionTooSmall",
-                                        DLoc, Block)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "OutlineRegionTooSmall",
+                                        DLoc, Block);
+      return ora_instance
              << ore::NV("Function", Cloner.OrigFunc)
              << " not partially inlined into callers (Original Size = "
              << ore::NV("OutlinedRegionOriginalSize", Cloner.OutlinedRegionCost)
@@ -1415,7 +1422,8 @@ bool PartialInlinerImpl::tryPartialInline(FunctionCloner &Cloner) {
           CalleeEntryCountV, CalleeEntryCount->getType()));
     OptimizationRemarkEmitter OrigFuncORE(Cloner.OrigFunc);
     OrigFuncORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "PartiallyInlined", Cloner.OrigFunc)
+      OptimizationRemark or_instance(DEBUG_TYPE, "PartiallyInlined", Cloner.OrigFunc);
+      return or_instance
              << "Partially inlined into at least one caller";
     });
   }


diff --git a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
index f835fb26fcb8..1ce7da7d7c64 100644
--- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
@@ -2249,8 +2249,9 @@ void ModuleCallsiteContextGraph::updateAllocationCall(
   auto A = llvm::Attribute::get(Call.call()->getFunction()->getContext(),
                                 "memprof", AllocTypeString);
   cast<CallBase>(Call.call())->addFnAttr(A);
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofAttribute", Call.call());
   OREGetter(Call.call()->getFunction())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofAttribute", Call.call())
+      .emit(or_instance
             << ore::NV("AllocationCall", Call.call()) << " in clone "
             << ore::NV("Caller", Call.call()->getFunction())
             << " marked with memprof allocation attribute "
@@ -2269,8 +2270,9 @@ void ModuleCallsiteContextGraph::updateCall(CallInfo &CallerCall,
                                             FuncInfo CalleeFunc) {
   if (CalleeFunc.cloneNo() > 0)
     cast<CallBase>(CallerCall.call())->setCalledFunction(CalleeFunc.func());
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofCall", CallerCall.call());
   OREGetter(CallerCall.call()->getFunction())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofCall", CallerCall.call())
+      .emit(or_instance
             << ore::NV("Call", CallerCall.call()) << " in clone "
             << ore::NV("Caller", CallerCall.call()->getFunction())
             << " assigned to call function clone "
@@ -2302,8 +2304,9 @@ ModuleCallsiteContextGraph::cloneFunctionForCallsite(
     assert(Inst.cloneNo() == 0);
     CallMap[Inst] = {cast<Instruction>(VMap[Inst.call()]), CloneNo};
   }
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofClone", Func.func());
   OREGetter(Func.func())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofClone", Func.func())
+      .emit(or_instance
             << "created clone " << ore::NV("NewFunction", NewFunc));
   return {NewFunc, CloneNo};
 }
@@ -2835,7 +2838,8 @@ static SmallVector<std::unique_ptr<ValueToValueMapTy>, 4> createFunctionClones(
       PrevF->eraseFromParent();
     } else
       NewF->setName(Name);
-    ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofClone", &F)
+    OptimizationRemark or_instance(DEBUG_TYPE, "MemprofClone", &F);
+    ORE.emit(or_instance
              << "created clone " << ore::NV("NewFunction", NewF));
 
     // Now handle aliases to this function, and clone those as well.
@@ -3089,7 +3093,8 @@ bool MemProfContextDisambiguation::applyImport(Module &M) {
               // entry).
               CBClone = cast<CallBase>((*VMaps[J - 1])[CB]);
             CBClone->addFnAttr(A);
-            ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofAttribute", CBClone)
+            OptimizationRemark or_instance(DEBUG_TYPE, "MemprofAttribute", CBClone);
+            ORE.emit(or_instance
                      << ore::NV("AllocationCall", CBClone) << " in clone "
                      << ore::NV("Caller", CBClone->getFunction())
                      << " marked with memprof allocation attribute "
@@ -3138,7 +3143,8 @@ bool MemProfContextDisambiguation::applyImport(Module &M) {
             else
               CBClone = cast<CallBase>((*VMaps[J - 1])[CB]);
             CBClone->setCalledFunction(NewF);
-            ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofCall", CBClone)
+            OptimizationRemark or_instance(DEBUG_TYPE, "MemprofCall", CBClone);
+            ORE.emit(or_instance
                      << ore::NV("Call", CBClone) << " in clone "
                      << ore::NV("Caller", CBClone->getFunction())
                      << " assigned to call function clone "


diff --git a/llvm/include/llvm/Transforms/IPO/Attributor.h b/llvm/include/llvm/Transforms/IPO/Attributor.h
index 1da00acdf034..0181425a9e1b 100644
--- a/llvm/include/llvm/Transforms/IPO/Attributor.h
+++ b/llvm/include/llvm/Transforms/IPO/Attributor.h
@@ -2114,15 +2114,15 @@ public:
 
     Function *F = I->getFunction();
     auto &ORE = Configuration.OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I));
+        return rcb;
       });
   }
 
@@ -2134,15 +2134,15 @@ public:
       return;
 
     auto &ORE = Configuration.OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F));
+        return rcb;
       });
   }
 
diff --git a/llvm/lib/Transforms/IPO/OpenMPOpt.cpp b/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
index 588f3901e3cb..c47245a35b14 100644
--- a/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
+++ b/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
@@ -1857,15 +1857,15 @@ private:
                   RemarkCallBack &&RemarkCB) const {
     Function *F = I->getParent()->getParent();
     auto &ORE = OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit(
-          [&]() { return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I)); });
+          [&]() { return rcb; });
   }
 
   /// Emit a remark on a function.
@@ -1873,15 +1873,15 @@ private:
   void emitRemark(Function *F, StringRef RemarkName,
                   RemarkCallBack &&RemarkCB) const {
     auto &ORE = OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit(
-          [&]() { return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F)); });
+          [&]() { return rcb; });
   }
 
   /// The underlying module.


diff --git a/llvm/lib/Transforms/IPO/SampleProfile.cpp b/llvm/lib/Transforms/IPO/SampleProfile.cpp
index a53baecd4776..4e41eb84502e 100644
--- a/llvm/lib/Transforms/IPO/SampleProfile.cpp
+++ b/llvm/lib/Transforms/IPO/SampleProfile.cpp
@@ -1057,9 +1057,10 @@ void SampleProfileLoader::emitOptimizationRemarksForInlineCandidates(
   for (auto *I : Candidates) {
     Function *CalledFunction = I->getCalledFunction();
     if (CalledFunction) {
-      ORE->emit(OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(),
+      OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(),
                                            "InlineAttempt", I->getDebugLoc(),
-                                           I->getParent())
+                                           I->getParent());
+      ORE->emit(ora_instance
                 << "previous inlining reattempted for "
                 << (Hot ? "hotness: '" : "size: '")
                 << ore::NV("Callee", CalledFunction) << "' into '"
@@ -1284,8 +1285,9 @@ bool SampleProfileLoader::tryInlineCandidate(
 
   InlineCost Cost = shouldInlineCandidate(Candidate);
   if (Cost.isNever()) {
-    ORE->emit(OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(),
-                                         "InlineFail", DLoc, BB)
+    OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(),
+                                         "InlineFail", DLoc, BB);
+    ORE->emit(ora_instance
               << "incompatible inlining");
     return false;
   }
@@ -1588,9 +1590,9 @@ void SampleProfileLoader::promoteMergeNotInlinedContextSamples(
     if (!Callee || Callee->isDeclaration())
       continue;
 
-    ORE->emit(
-        OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(), "NotInline",
-                                   I->getDebugLoc(), I->getParent())
+    OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(), "NotInline",
+                                   I->getDebugLoc(), I->getParent());
+    ORE->emit(ora_instance
         << "previous inlining not repeated: '" << ore::NV("Callee", Callee)
         << "' into '" << ore::NV("Caller", &F) << "'");
 
@@ -1794,7 +1796,8 @@ void SampleProfileLoader::generateMDProfMetadata(Function &F) {
       LLVM_DEBUG(dbgs() << "SUCCESS. Found non-zero weights.\n");
       TI->setMetadata(LLVMContext::MD_prof, MDB.createBranchWeights(Weights));
       ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "PopularDest", MaxDestInst)
+        OptimizationRemark or_instance(DEBUG_TYPE, "PopularDest", MaxDestInst);
+        return or_instance
                << "most popular destination for conditional branches at "
                << ore::NV("CondBranchesLoc", BranchLoc);
       });


diff --git a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
index 599ace9ca79f..02da25fbf700 100644
--- a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
+++ b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
@@ -358,8 +358,9 @@ Function *HotColdSplitting::extractColdRegion(
 
     LLVM_DEBUG(llvm::dbgs() << "Outlined Region: " << *OutF);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "HotColdSplit",
-                                &*Region[0]->begin())
+      OptimizationRemark or_instance(DEBUG_TYPE, "HotColdSplit",
+                                &*Region[0]->begin());
+      return or_instance
              << ore::NV("Original", OrigF) << " split cold code into "
              << ore::NV("Split", OutF);
     });
@@ -367,8 +368,9 @@ Function *HotColdSplitting::extractColdRegion(
   }
 
   ORE.emit([&]() {
-    return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                    &*Region[0]->begin())
+    OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                    &*Region[0]->begin());
+    return orm_instance
            << "Failed to extract region at block "
            << ore::NV("Block", Region.front());
   });
diff --git a/llvm/lib/Transforms/IPO/Inliner.cpp b/llvm/lib/Transforms/IPO/Inliner.cpp
index 3e00aebce372..bb757477241c 100644
--- a/llvm/lib/Transforms/IPO/Inliner.cpp
+++ b/llvm/lib/Transforms/IPO/Inliner.cpp
@@ -264,7 +264,8 @@ PreservedAnalyses InlinerPass::run(LazyCallGraph::SCC &InitialC,
             using namespace ore;
             setInlineRemark(*CB, "unavailable definition");
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "NoDefinition", &I)
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NoDefinition", &I);
+              return orm_instance
                      << NV("Callee", Callee) << " will not be inlined into "
                      << NV("Caller", CB->getCaller())
                      << " because its definition is unavailable"


diff --git a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
index cc375f9badcd..4d35a291919e 100644
--- a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
+++ b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
@@ -70,8 +70,9 @@ bool AlwaysInlineImpl(
                                           &GetAAR(F), InsertLifetime);
         if (!Res.isSuccess()) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE, "NotInlined", DLoc,
-                                            Block)
+            OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NotInlined", DLoc,
+                                            Block);
+            return orm_instance
                    << "'" << ore::NV("Callee", &F) << "' is not inlined into '"
                    << ore::NV("Caller", Caller)
                    << "': " << ore::NV("Reason", Res.getFailureReason());


diff --git a/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp b/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
index e53019768e88..76263066e537 100644
--- a/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
+++ b/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
@@ -25,10 +25,10 @@ static void warnAboutLeftoverTransformations(Loop *L,
                                              OptimizationRemarkEmitter *ORE) {
   if (hasUnrollTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover unroll transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedUnrolling",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure fru(DEBUG_TYPE,
+                                      "FailedRequestedUnrolling",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(fru
         << "loop not unrolled: the optimizer was unable to perform the "
            "requested transformation; the transformation might be disabled or "
            "specified as part of an unsupported transformation ordering");
@@ -36,10 +36,10 @@ static void warnAboutLeftoverTransformations(Loop *L,
 
   if (hasUnrollAndJamTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover unroll-and-jam transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedUnrollAndJamming",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure fruaj(DEBUG_TYPE,
+                                      "FailedRequestedUnrollAndJamming",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(fruaj
         << "loop not unroll-and-jammed: the optimizer was unable to perform "
            "the requested transformation; the transformation might be disabled "
            "or specified as part of an unsupported transformation ordering");
@@ -52,30 +52,31 @@ static void warnAboutLeftoverTransformations(Loop *L,
     std::optional<int> InterleaveCount =
         getOptionalIntLoopAttribute(L, "llvm.loop.interleave.count");
 
-    if (!VectorizeWidth || VectorizeWidth->isVector())
-      ORE->emit(
-          DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                            "FailedRequestedVectorization",
-                                            L->getStartLoc(), L->getHeader())
+    if (!VectorizeWidth || VectorizeWidth->isVector()) {
+      DiagnosticInfoOptimizationFailure frv(DEBUG_TYPE,
+                                        "FailedRequestedVectorization",
+                                        L->getStartLoc(), L->getHeader());
+      ORE->emit(frv
           << "loop not vectorized: the optimizer was unable to perform the "
              "requested transformation; the transformation might be disabled "
              "or specified as part of an unsupported transformation ordering");
-    else if (InterleaveCount.value_or(0) != 1)
-      ORE->emit(
-          DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                            "FailedRequestedInterleaving",
-                                            L->getStartLoc(), L->getHeader())
+    } else if (InterleaveCount.value_or(0) != 1) {
+      DiagnosticInfoOptimizationFailure fri(DEBUG_TYPE,
+                                        "FailedRequestedInterleaving",
+                                        L->getStartLoc(), L->getHeader());
+      ORE->emit(fri
           << "loop not interleaved: the optimizer was unable to perform the "
              "requested transformation; the transformation might be disabled "
              "or specified as part of an unsupported transformation ordering");
+    }
   }
 
   if (hasDistributeTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover distribute transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedDistribution",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure frd(DEBUG_TYPE,
+                                      "FailedRequestedDistribution",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(frd
         << "loop not distributed: the optimizer was unable to perform the "
            "requested transformation; the transformation might be disabled or "
            "specified as part of an unsupported transformation ordering");


diff --git a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
index 4f1350e4ebb9..3eeb2e249f6e 100644
--- a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
+++ b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
@@ -271,7 +271,8 @@ static bool markTails(Function &F, OptimizationRemarkEmitter *ORE) {
         if (SafeToTail) {
           using namespace ore;
           ORE->emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "tailcall-readnone", CI)
+            OptimizationRemark or_instance(DEBUG_TYPE, "tailcall-readnone", CI);
+            return or_instance
                    << "marked as tail call candidate (readnone)";
           });
           CI->setTailCall();
@@ -654,7 +655,8 @@ bool TailRecursionEliminator::eliminateCall(CallInst *CI) {
 
   using namespace ore;
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "tailcall-recursion", CI)
+    OptimizationRemark or_instance(DEBUG_TYPE, "tailcall-recursion", CI);
+    return or_instance
            << "transforming tail recursion into loop";
   });
 
diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
index f923f0be6621..718e87866d39 100644
--- a/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
@@ -194,9 +194,10 @@ bool LoopVectorizeHints::allowVectorization(
     // vectorize.disable to be used without disabling the pass and errors
     // to differentiate between disabled vectorization and a width of 1.
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(vectorizeAnalysisPassName(),
+      OptimizationRemarkAnalysis ora(vectorizeAnalysisPassName(),
                                         "AllDisabled", L->getStartLoc(),
-                                        L->getHeader())
+                                        L->getHeader());
+      return ora
              << "loop not vectorized: vectorization and interleaving are "
                 "explicitly disabled, or the loop has already been "
                 "vectorized";
@@ -211,12 +212,13 @@ void LoopVectorizeHints::emitRemarkWithHints() const {
   using namespace ore;
 
   ORE.emit([&]() {
-    if (Force.Value == LoopVectorizeHints::FK_Disabled)
-      return OptimizationRemarkMissed(LV_NAME, "MissedExplicitlyDisabled",
+    if (Force.Value == LoopVectorizeHints::FK_Disabled) {
+      OptimizationRemarkMissed orm(LV_NAME, "MissedExplicitlyDisabled",
                                       TheLoop->getStartLoc(),
-                                      TheLoop->getHeader())
+                                      TheLoop->getHeader());
+      return orm
              << "loop not vectorized: vectorization is explicitly disabled";
-    else {
+    } else {
       OptimizationRemarkMissed R(LV_NAME, "MissedDetails",
                                  TheLoop->getStartLoc(), TheLoop->getHeader());
       R << "loop not vectorized";


diff --git a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
index 335b489d3cb2..0da16d74b1ff 100644
--- a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
@@ -999,9 +999,10 @@ bool llvm::computeUnrollCount(
     if ((PragmaFullUnroll || PragmaEnableUnroll) && TripCount &&
         UP.Count != TripCount)
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE,
+        OptimizationRemarkMissed fuadtl(DEBUG_TYPE,
                                         "FullUnrollAsDirectedTooLarge",
-                                        L->getStartLoc(), L->getHeader())
+                                        L->getStartLoc(), L->getHeader());
+        return fuadtl
                << "Unable to fully unroll loop as directed by unroll pragma "
                   "because "
                   "unrolled size is too large.";
@@ -1011,9 +1012,10 @@ bool llvm::computeUnrollCount(
       if (UP.Count == 0) {
         if (PragmaEnableUnroll)
           ORE->emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
+            OptimizationRemarkMissed uadtl(DEBUG_TYPE,
                                             "UnrollAsDirectedTooLarge",
-                                            L->getStartLoc(), L->getHeader())
+                                            L->getStartLoc(), L->getHeader());
+            return uadtl
                    << "Unable to unroll loop as directed by unroll(enable) "
                       "pragma "
                       "because unrolled size is too large.";
@@ -1026,9 +1028,10 @@ bool llvm::computeUnrollCount(
          "All cases when TripCount is constant should be covered here.");
   if (PragmaFullUnroll)
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(
+      OptimizationRemarkMissed cfuadrtc(
                  DEBUG_TYPE, "CantFullUnrollAsDirectedRuntimeTripCount",
-                 L->getStartLoc(), L->getHeader())
+                 L->getStartLoc(), L->getHeader());
+      return cfuadrtc
              << "Unable to fully unroll loop as directed by unroll(full) "
                 "pragma "
                 "because loop has a runtime trip count.";
@@ -1092,9 +1095,10 @@ bool llvm::computeUnrollCount(
 
     if (unrollCountPragmaValue(L) > 0 && !UP.AllowRemainder)
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE,
+        OptimizationRemarkMissed ducfd(DEBUG_TYPE,
                                         "DifferentUnrollCountFromDirected",
-                                        L->getStartLoc(), L->getHeader())
+                                        L->getStartLoc(), L->getHeader());
+        return ducfd
                << "Unable to unroll loop the number of times directed by "
                   "unroll_count pragma because remainder loop is restricted "
                   "(that could architecture specific or because the loop "
@@ -1287,8 +1291,9 @@ tryToUnrollLoop(Loop *L, DominatorTree &DT, LoopInfo *LI, ScalarEvolution &SE,
     LLVM_DEBUG(dbgs() << "PEELING loop %" << L->getHeader()->getName()
                       << " with iteration count " << PP.PeelCount << "!\n");
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Peeled", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark p(DEBUG_TYPE, "Peeled", L->getStartLoc(),
+                                L->getHeader());
+      return p
              << " peeled loop by " << ore::NV("PeelCount", PP.PeelCount)
              << " iterations";
     });
diff --git a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
index 13e06c79d0d7..7aa37913a676 100644
--- a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
@@ -365,7 +365,8 @@ bool LoopVersioningLICM::legalLoopInstructions() {
       // If instruction is unsafe just return false.
       if (!instructionSafeForVersioning(&Inst)) {
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopInst", &Inst)
+          OptimizationRemarkMissed ili(DEBUG_TYPE, "IllegalLoopInst", &Inst);
+          return ili
                  << " Unsafe Loop Instruction";
         });
         return false;
@@ -384,9 +385,10 @@ bool LoopVersioningLICM::legalLoopInstructions() {
     LLVM_DEBUG(
         dbgs() << "    LAA: Runtime checks are more than threshold !!\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "RuntimeCheck",
+      OptimizationRemarkMissed rc(DEBUG_TYPE, "RuntimeCheck",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return rc
              << "Number of runtime checks "
              << NV("RuntimeChecks", LAI->getNumRuntimePointerChecks())
              << " exceeds threshold "
@@ -416,9 +418,10 @@ bool LoopVersioningLICM::legalLoopInstructions() {
     LLVM_DEBUG(dbgs() << "    Invariant loads & store threshold: "
                       << InvariantThreshold << "%\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InvariantThreshold",
+      OptimizationRemarkMissed it(DEBUG_TYPE, "InvariantThreshold",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return it
              << "Invariant load & store "
              << NV("LoadAndStoreCounter",
                    ((InvariantCounter * 100) / LoadAndStoreCounter))
@@ -459,9 +462,10 @@ bool LoopVersioningLICM::isLegalForVersioning() {
     LLVM_DEBUG(
         dbgs() << "    Loop structure not suitable for LoopVersioningLICM\n\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopStruct",
+      OptimizationRemarkMissed ils(DEBUG_TYPE, "IllegalLoopStruct",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return ils
              << " Unsafe Loop structure";
     });
     return false;
@@ -479,9 +483,10 @@ bool LoopVersioningLICM::isLegalForVersioning() {
         dbgs()
         << "    Loop memory access not suitable for LoopVersioningLICM\n\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopMemoryAccess",
+      OptimizationRemarkMissed ilma(DEBUG_TYPE, "IllegalLoopMemoryAccess",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return ilma
              << " Unsafe Loop memory access";
     });
     return false;
@@ -489,8 +494,9 @@ bool LoopVersioningLICM::isLegalForVersioning() {
   // Loop versioning is feasible, return true.
   LLVM_DEBUG(dbgs() << "    Loop Versioning found to be beneficial\n\n");
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "IsLegalForVersioning",
-                              CurLoop->getStartLoc(), CurLoop->getHeader())
+    OptimizationRemark ilfv(DEBUG_TYPE, "IsLegalForVersioning",
+                              CurLoop->getStartLoc(), CurLoop->getHeader());
+    return ilfv
            << " Versioned loop for LICM."
            << " Number of runtime checks we had to insert "
            << NV("RuntimeChecks", LAI->getNumRuntimePointerChecks());


diff --git a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
index 7c2770979a90..5b21f03f069d 100644
--- a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
@@ -417,7 +417,8 @@ bool LoopDataPrefetch::runOnLoop(Loop *L) {
                << *P.MemI->getOperand(isa<LoadInst>(P.MemI) ? 0 : 1)
                << ", SCEV: " << *P.LSCEVAddRec << "\n");
     ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "Prefetched", P.MemI)
+        OptimizationRemark p(DEBUG_TYPE, "Prefetched", P.MemI);
+        return p
           << "prefetched memory access";
       });
 
diff --git a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
index 91286ebcea33..ab41bbb9a2ed 100644
--- a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
@@ -520,9 +520,10 @@ struct LoopInterchange {
     }
 
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Interchanged",
+      OptimizationRemark i(DEBUG_TYPE, "Interchanged",
                                 InnerLoop->getStartLoc(),
-                                InnerLoop->getHeader())
+                                InnerLoop->getHeader());
+      return i
              << "Loop interchanged with enclosing loop.";
     });
 
@@ -780,9 +781,10 @@ bool LoopInterchangeLegality::currentLimitations() {
         dbgs() << "Loops where the latch is not the exiting block are not"
                << " supported currently.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ExitingNotLatch",
+      OptimizationRemarkMissed enl(DEBUG_TYPE, "ExitingNotLatch",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return enl
              << "Loops where the latch is not the exiting block cannot be"
                 " interchange currently.";
     });
@@ -795,9 +797,10 @@ bool LoopInterchangeLegality::currentLimitations() {
         dbgs() << "Only outer loops with induction or reduction PHI nodes "
                << "are supported currently.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedPHIOuter",
+      OptimizationRemarkMissed uphio(DEBUG_TYPE, "UnsupportedPHIOuter",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return uphio
              << "Only outer loops with induction or reduction PHI nodes can be"
                 " interchanged currently.";
     });
@@ -817,9 +820,10 @@ bool LoopInterchangeLegality::currentLimitations() {
           dbgs() << "Only inner loops with induction or reduction PHI nodes "
                 << "are supported currently.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedPHIInner",
+        OptimizationRemarkMissed uphii(DEBUG_TYPE, "UnsupportedPHIInner",
                                         CurLevelLoop->getStartLoc(),
-                                        CurLevelLoop->getHeader())
+                                        CurLevelLoop->getHeader());
+        return uphii
               << "Only inner loops with induction or reduction PHI nodes can be"
                   " interchange currently.";
       });
@@ -831,9 +835,10 @@ bool LoopInterchangeLegality::currentLimitations() {
   if (!isLoopStructureUnderstood()) {
     LLVM_DEBUG(dbgs() << "Loop structure not understood by pass\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedStructureInner",
+      OptimizationRemarkMissed usi(DEBUG_TYPE, "UnsupportedStructureInner",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return usi
              << "Inner loop structure not understood currently.";
     });
     return true;
@@ -948,9 +953,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
                       << " and OuterLoopId = " << OuterLoopId
                       << " due to dependence\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "Dependence",
+      OptimizationRemarkMissed d(DEBUG_TYPE, "Dependence",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return d
              << "Cannot interchange loops due to dependences.";
     });
     return false;
@@ -966,9 +972,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
             dbgs() << "Loops with call instructions cannot be interchanged "
                    << "safely.");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "CallInst",
+          OptimizationRemarkMissed ci(DEBUG_TYPE, "CallInst",
                                           CI->getDebugLoc(),
-                                          CI->getParent())
+                                          CI->getParent());
+          return ci
                  << "Cannot interchange loops due to call instruction.";
         });
 
@@ -983,9 +990,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!areInnerLoopLatchPHIsSupported(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in inner loop latch.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedInnerLatchPHI",
+      OptimizationRemarkMissed uilphi(DEBUG_TYPE, "UnsupportedInnerLatchPHI",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return uilphi
              << "Cannot interchange loops because unsupported PHI nodes found "
                 "in inner loop latch.";
     });
@@ -1003,9 +1011,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!tightlyNested(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Loops not tightly nested\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "NotTightlyNested",
+      OptimizationRemarkMissed ntn(DEBUG_TYPE, "NotTightlyNested",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return ntn
              << "Cannot interchange loops because they are not tightly "
                 "nested.";
     });
@@ -1016,9 +1025,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
                                      OuterInnerReductions)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in inner loop exit.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedExitPHI",
+      OptimizationRemarkMissed uephii(DEBUG_TYPE, "UnsupportedExitPHI",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return uephii
              << "Found unsupported PHI node in loop exit.";
     });
     return false;
@@ -1027,9 +1037,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!areOuterLoopExitPHIsSupported(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in outer loop exit.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedExitPHI",
+      OptimizationRemarkMissed uephio(DEBUG_TYPE, "UnsupportedExitPHI",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return uephio
              << "Found unsupported PHI node in loop exit.";
     });
     return false;
@@ -1173,18 +1184,20 @@ bool LoopInterchangeProfitability::isProfitable(
   }
   if (!shouldInterchange.has_value()) {
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InterchangeNotProfitable",
+      OptimizationRemarkMissed inp(DEBUG_TYPE, "InterchangeNotProfitable",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return inp
              << "Insufficient information to calculate the cost of loop for "
                 "interchange.";
     });
     return false;
   } else if (!shouldInterchange.value()) {
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InterchangeNotProfitable",
+      OptimizationRemarkMissed inp(DEBUG_TYPE, "InterchangeNotProfitable",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return inp
              << "Interchanging loops is not considered to improve cache "
                 "locality nor vectorization.";
     });


diff --git a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
index c041e3621a16..ea269dd9be4d 100644
--- a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
@@ -464,8 +464,9 @@ static LoopDeletionResult deleteLoopIfDead(Loop *L, DominatorTree &DT,
                 PoisonValue::get(P.getType()));
     }
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "NeverExecutes", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark ne(DEBUG_TYPE, "NeverExecutes", L->getStartLoc(),
+                                L->getHeader());
+      return ne
              << "Loop deleted because it never executes";
     });
     deleteDeadLoop(L, &DT, &SE, &LI, MSSA);
@@ -504,8 +505,9 @@ static LoopDeletionResult deleteLoopIfDead(Loop *L, DominatorTree &DT,
 
   LLVM_DEBUG(dbgs() << "Loop is invariant, delete it!\n");
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Invariant", L->getStartLoc(),
-                              L->getHeader())
+    OptimizationRemark i(DEBUG_TYPE, "Invariant", L->getStartLoc(),
+                              L->getHeader());
+    return i
            << "Loop deleted because it is invariant";
   });
   deleteDeadLoop(L, &DT, &SE, &LI, MSSA);
diff --git a/llvm/lib/Transforms/Scalar/LoopDistribute.cpp b/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
index 27196e46ca56..41c671b382e2 100644
--- a/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
@@ -841,8 +841,9 @@ public:
     ++NumLoopsDistributed;
     // Report the success.
     ORE->emit([&]() {
-      return OptimizationRemark(LDIST_NAME, "Distribute", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark d(LDIST_NAME, "Distribute", L->getStartLoc(),
+                                L->getHeader());
+      return d
              << "distributed loop";
     });
     return true;
@@ -857,8 +858,9 @@ public:
 
     // With Rpass-missed report that distribution failed.
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(LDIST_NAME, "NotDistributed",
-                                      L->getStartLoc(), L->getHeader())
+      OptimizationRemarkMissed nd(LDIST_NAME, "NotDistributed",
+                                      L->getStartLoc(), L->getHeader());
+      return nd
              << "loop not distributed: use -Rpass-analysis=loop-distribute for "
                 "more "
                 "info";
@@ -866,9 +868,10 @@ public:
 
     // With Rpass-analysis report why.  This is on by default if distribution
     // was requested explicitly.
-    ORE->emit(OptimizationRemarkAnalysis(
+    OptimizationRemarkAnalysis ora_instance(
                   Forced ? OptimizationRemarkAnalysis::AlwaysPrint : LDIST_NAME,
-                  RemarkName, L->getStartLoc(), L->getHeader())
+                  RemarkName, L->getStartLoc(), L->getHeader());
+    ORE->emit(ora_instance
               << "loop not distributed: " << Message);
 
     // Also issue a warning if distribution was requested explicitly but it


diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index f8fab03f151d..f33c88ae74b9 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -1190,8 +1190,9 @@ bool llvm::canSinkOrHoistInst(Instruction &I, AAResults *AA, DominatorTree *DT,
     // whose address is not necessarily loop-invariant.
     if (ORE && Invalidated && CurLoop->isLoopInvariant(LI->getPointerOperand()))
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(
-                   DEBUG_TYPE, "LoadWithLoopInvariantAddressInvalidated", LI)
+        OptimizationRemarkMissed lwliai(
+                   DEBUG_TYPE, "LoadWithLoopInvariantAddressInvalidated", LI);
+        return lwliai
                << "failed to move load with loop-invariant address "
                   "because the loop may invalidate its value";
       });
@@ -1674,7 +1675,8 @@ static bool sink(Instruction &I, LoopInfo *LI, DominatorTree *DT,
     return Changed;
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "InstSunk", &I)
+    OptimizationRemark is(DEBUG_TYPE, "InstSunk", &I);
+    return is
            << "sinking " << ore::NV("Inst", &I);
   });
   if (isa<LoadInst>(I))
@@ -1731,7 +1733,8 @@ static void hoist(Instruction &I, const DominatorTree *DT, const Loop *CurLoop,
   LLVM_DEBUG(dbgs() << "LICM hoisting to " << Dest->getNameOrAsOperand() << ": "
                     << I << "\n");
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Hoisted", &I) << "hoisting "
+    OptimizationRemark h(DEBUG_TYPE, "Hoisted", &I);
+    return h << "hoisting "
                                                          << ore::NV("Inst", &I);
   });
 
@@ -1785,8 +1788,9 @@ static bool isSafeToExecuteUnconditionally(
     auto *LI = dyn_cast<LoadInst>(&Inst);
     if (LI && CurLoop->isLoopInvariant(LI->getPointerOperand()))
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(
-                   DEBUG_TYPE, "LoadWithLoopInvariantAddressCondExecuted", LI)
+        OptimizationRemarkMissed lwliace(
+                   DEBUG_TYPE, "LoadWithLoopInvariantAddressCondExecuted", LI);
+        return lwliace
                << "failed to hoist load with loop-invariant address "
                   "because load is conditionally executed";
       });
@@ -2215,8 +2219,9 @@ bool llvm::promoteLoopAccessesToScalars(
   }
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "PromoteLoopAccessesToScalar",
-                              LoopUses[0])
+    OptimizationRemark plats(DEBUG_TYPE, "PromoteLoopAccessesToScalar",
+                              LoopUses[0]);
+    return plats
            << "Moving accesses to memory location out of the loop";
   });
 
diff --git a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
index 8572a442e784..286d4d8ccda3 100644
--- a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
@@ -803,7 +803,8 @@ bool LoopIdiomRecognize::processLoopMemCpy(MemCpyInst *MCI,
 
   if (SizeInBytes != StoreStrideValue && SizeInBytes != -StoreStrideValue) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "SizeStrideUnequal", MCI)
+      OptimizationRemarkMissed ssu(DEBUG_TYPE, "SizeStrideUnequal", MCI);
+      return ssu
              << ore::NV("Inst", "memcpy") << " in "
              << ore::NV("Function", MCI->getFunction())
              << " function will not be hoisted: "
@@ -1314,8 +1315,9 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
     if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,
                               BECount, StoreSizeSCEV, *AA, IgnoredInsts)) {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "LoopMayAccessStore",
-                                        TheStore)
+        OptimizationRemarkMissed lmas(DEBUG_TYPE, "LoopMayAccessStore",
+                                        TheStore);
+        return lmas
                << ore::NV("Inst", InstRemark) << " in "
                << ore::NV("Function", TheStore->getFunction())
                << " function will not be hoisted: "
@@ -1347,7 +1349,8 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
   if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,
                             StoreSizeSCEV, *AA, IgnoredInsts)) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "LoopMayAccessLoad", TheLoad)
+      OptimizationRemarkMissed lmal(DEBUG_TYPE, "LoopMayAccessLoad", TheLoad);
+      return lmal
              << ore::NV("Inst", InstRemark) << " in "
              << ore::NV("Function", TheStore->getFunction())
              << " function will not be hoisted: "
@@ -1435,8 +1438,9 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
                     << "\n");
 
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "ProcessLoopStoreOfLoopLoad",
-                              NewCall->getDebugLoc(), Preheader)
+    OptimizationRemark plsoll(DEBUG_TYPE, "ProcessLoopStoreOfLoopLoad",
+                              NewCall->getDebugLoc(), Preheader);
+    return plsoll
            << "Formed a call to "
            << ore::NV("NewFunction", NewCall->getCalledFunction())
            << "() intrinsic from " << ore::NV("Inst", InstRemark)


diff --git a/llvm/lib/Transforms/Scalar/GVN.cpp b/llvm/lib/Transforms/Scalar/GVN.cpp
index 03e8a2507b45..880cde5a68d2 100644
--- a/llvm/lib/Transforms/Scalar/GVN.cpp
+++ b/llvm/lib/Transforms/Scalar/GVN.cpp
@@ -1491,7 +1491,8 @@ void GVNPass::eliminatePartiallyRedundantLoad(
     MD->invalidateCachedPointerInfo(V);
   markInstructionForDeletion(Load);
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "LoadPRE", Load)
+    OptimizationRemark lpre(DEBUG_TYPE, "LoadPRE", Load);
+    return lpre
            << "load eliminated by PRE";
   });
 }
@@ -1834,7 +1835,8 @@ static void reportLoadElim(LoadInst *Load, Value *AvailableValue,
   using namespace ore;
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "LoadElim", Load)
+    OptimizationRemark le(DEBUG_TYPE, "LoadElim", Load);
+    return le
            << "load of type " << NV("Type", Load->getType()) << " eliminated"
            << setExtraArgs() << " in favor of "
            << NV("InfavorOfValue", AvailableValue);


diff --git a/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp b/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
index b182f46cc515..47f6bb3da426 100644
--- a/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
+++ b/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
@@ -67,11 +67,13 @@ static void runImpl(Function &F, const TargetLibraryInfo &TLI) {
     }
   }
 
-  for (const auto &KV : Mapping)
-    ORE.emit(OptimizationRemarkAnalysis(REMARK_PASS, "AnnotationSummary",
-                                        F.getSubprogram(), &F.front())
+  for (const auto &KV : Mapping) {
+    OptimizationRemarkAnalysis as(REMARK_PASS, "AnnotationSummary",
+                                        F.getSubprogram(), &F.front());
+    ORE.emit(as
              << "Annotated " << NV("count", KV.second) << " instructions with "
              << NV("type", KV.first));
+  }
 
   // For each debug location, look for all the instructions with annotations and
   // generate more detailed remarks to be displayed at that location.
diff --git a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
index f2efe60bdf88..752cd2c6387a 100644
--- a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
+++ b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
@@ -378,7 +378,8 @@ struct MainSwitch {
       Instr = SI;
     } else {
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "SwitchNotPredictable", SI)
+        OptimizationRemarkMissed sp(DEBUG_TYPE, "SwitchNotPredictable", SI);
+        return sp
                << "Switch instruction is not predictable.";
       });
     }
@@ -503,8 +504,9 @@ struct AllSwitchPaths {
 
     if (StateDef.empty()) {
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "SwitchNotPredictable",
-                                        Switch)
+        OptimizationRemarkMissed snp(DEBUG_TYPE, "SwitchNotPredictable",
+                                        Switch);
+        return snp
                << "Switch instruction is not predictable.";
       });
       return;
@@ -551,8 +553,9 @@ private:
     // Stop exploring paths after visiting MaxPathLength blocks
     if (PathDepth > MaxPathLength) {
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "MaxPathLengthReached",
-                                          Switch)
+        OptimizationRemarkAnalysis mplr(DEBUG_TYPE, "MaxPathLengthReached",
+                                          Switch);
+        return mplr
                << "Exploration stopped after visiting MaxPathLength="
                << ore::NV("MaxPathLength", MaxPathLength) << " blocks.";
       });
@@ -766,8 +769,9 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "non-duplicatable instructions.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NonDuplicatableInst",
-                                          Switch)
+          OptimizationRemarkMissed ndi(DEBUG_TYPE, "NonDuplicatableInst",
+                                          Switch);
+          return ndi
                  << "Contains non-duplicatable instructions.";
         });
         return false;
@@ -777,7 +781,8 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "convergent instructions.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "ConvergentInst", Switch)
+          OptimizationRemarkMissed c(DEBUG_TYPE, "ConvergentInst", Switch);
+          return c
                  << "Contains convergent instructions.";
         });
         return false;
@@ -787,7 +792,8 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "instructions with invalid cost.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "ConvergentInst", Switch)
+          OptimizationRemarkMissed ci(DEBUG_TYPE, "ConvergentInst", Switch);
+          return ci
                  << "Contains instructions with invalid cost.";
         });
         return false;
@@ -824,7 +830,8 @@ private:
       LLVM_DEBUG(dbgs() << "Not jump threading, duplication cost exceeds the "
                         << "cost threshold.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "NotProfitable", Switch)
+        OptimizationRemarkMissed np(DEBUG_TYPE, "NotProfitable", Switch);
+        return np
                << "Duplication cost exceeds the cost threshold (cost="
                << ore::NV("Cost", DuplicationCost)
                << ", threshold=" << ore::NV("Threshold", CostThreshold) << ").";
@@ -833,7 +840,8 @@ private:
     }
 
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "JumpThreaded", Switch)
+      OptimizationRemark jt(DEBUG_TYPE, "JumpThreaded", Switch);
+      return jt
              << "Switch statement jump-threaded.";
     });
 


diff --git a/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp b/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
index 5c9799235017..dc53bfff2583 100644
--- a/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
+++ b/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
@@ -181,7 +181,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPInvokeOnly && isa<CallInst>(CB)) {
       LLVM_DEBUG(dbgs() << " Not promote: User options.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UserOptions", &CB)
+        OptimizationRemarkMissed uo(DEBUG_TYPE, "UserOptions", &CB);
+        return uo
                << " Not promote: User options";
       });
       break;
@@ -189,7 +190,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPCallOnly && isa<InvokeInst>(CB)) {
       LLVM_DEBUG(dbgs() << " Not promote: User option.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UserOptions", &CB)
+        OptimizationRemarkMissed uo(DEBUG_TYPE, "UserOptions", &CB);
+        return uo
                << " Not promote: User options";
       });
       break;
@@ -197,7 +199,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPCutOff != 0 && NumOfPGOICallPromotion >= ICPCutOff) {
       LLVM_DEBUG(dbgs() << " Not promote: Cutoff reached.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CutOffReached", &CB)
+        OptimizationRemarkMissed cor(DEBUG_TYPE, "CutOffReached", &CB);
+        return cor
                << " Not promote: Cutoff reached";
       });
       break;
@@ -214,7 +217,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (TargetFunction == nullptr || TargetFunction->isDeclaration()) {
       LLVM_DEBUG(dbgs() << " Not promote: Cannot find the target\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnableToFindTarget", &CB)
+        OptimizationRemarkMissed utft(DEBUG_TYPE, "UnableToFindTarget", &CB);
+        return utft
                << "Cannot promote indirect call: target with md5sum "
                << ore::NV("target md5sum", Target) << " not found";
       });
@@ -226,7 +230,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
       using namespace ore;
 
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnableToPromote", &CB)
+        OptimizationRemarkMissed utp(DEBUG_TYPE, "UnableToPromote", &CB);
+        return utp
                << "Cannot promote indirect call to "
                << NV("TargetFunction", TargetFunction) << " with count of "
                << NV("Count", Count) << ": " << Reason;
@@ -266,7 +271,8 @@ CallBase &llvm::pgo::promoteIndirectCall(CallBase &CB, Function *DirectCallee,
 
   if (ORE)
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Promoted", &CB)
+      OptimizationRemark p(DEBUG_TYPE, "Promoted", &CB);
+      return p
              << "Promote indirect call to " << NV("DirectCallee", DirectCallee)
              << " with count " << NV("Count", Count) << " out of "
              << NV("TotalCount", TotalCount);
diff --git a/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp b/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
index 2906fe190984..9203ad6c4ee2 100644
--- a/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
+++ b/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
@@ -446,7 +446,8 @@ bool MemOPSizeOpt::perform(MemOp MO) {
 
   ORE.emit([&]() {
     using namespace ore;
-    return OptimizationRemark(DEBUG_TYPE, "memopt-opt", MO.I)
+    OptimizationRemark mo(DEBUG_TYPE, "memopt-opt", MO.I);
+    return mo
            << "optimized " << NV("Memop", MO.getName(TLI)) << " with count "
            << NV("Count", SumForOpt) << " out of " << NV("Total", TotalCount)
            << " for " << NV("Versions", Version) << " versions";


diff --git a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
index 3c8f25d73c62..f7dc5e6a62d7 100644
--- a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
+++ b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
@@ -1956,8 +1956,9 @@ static void verifyFuncBFI(PGOUseFunc &Func, LoopInfo &LI,
   }
   if (BBMisMatchNum)
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "bfi-verify",
-                                        F.getSubprogram(), &F.getEntryBlock())
+      OptimizationRemarkAnalysis bv(DEBUG_TYPE, "bfi-verify",
+                                        F.getSubprogram(), &F.getEntryBlock());
+      return bv
              << "In Func " << ore::NV("Function", F.getName())
              << ": Num_of_BB=" << ore::NV("Count", BBNum)
              << ", Num_of_non_zerovalue_BB=" << ore::NV("Count", NonZeroBBNum)
@@ -2238,7 +2239,8 @@ void llvm::setProfMetadata(Module *M, Instruction *TI,
     Function *F = TI->getParent()->getParent();
     OptimizationRemarkEmitter ORE(F);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "pgo-instrumentation", TI)
+      OptimizationRemark pi(DEBUG_TYPE, "pgo-instrumentation", TI);
+      return pi
              << BrCondStr << " is true with probability : " << BranchProbStr;
     });
   }


diff --git a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
index 3e3be536defc..d4fd64b50226 100644
--- a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
+++ b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
@@ -778,7 +778,8 @@ CHRScope * CHR::findScope(Region *R) {
         ++Stats.NumBranches;
         if (!RI.HasBranch) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE, "BranchNotBiased", BI)
+            OptimizationRemarkMissed bnb(DEBUG_TYPE, "BranchNotBiased", BI);
+            return bnb
                 << "Branch not biased";
           });
         }
@@ -824,7 +825,8 @@ CHRScope * CHR::findScope(Region *R) {
             RI.Selects.push_back(SI);
           else
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "SelectNotBiased", SI)
+              OptimizationRemarkMissed snb(DEBUG_TYPE, "SelectNotBiased", SI);
+              return snb
                   << "Select not biased";
             });
       };
@@ -900,8 +902,9 @@ void CHR::checkScopeHoistable(CHRScope *Scope) {
       if (!IsHoistable) {
         CHR_DEBUG(dbgs() << "Dropping select " << *SI << "\n");
         ORE.emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE,
-                                          "DropUnhoistableSelect", SI)
+          OptimizationRemarkMissed dus(DEBUG_TYPE,
+                                          "DropUnhoistableSelect", SI);
+          return dus
               << "Dropped unhoistable select";
         });
         it = Selects.erase(it);
@@ -930,8 +933,9 @@ void CHR::checkScopeHoistable(CHRScope *Scope) {
             });
         for (SelectInst *SI : Selects) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
-                                            "DropSelectUnhoistableBranch", SI)
+            OptimizationRemarkMissed dsub(DEBUG_TYPE,
+                                            "DropSelectUnhoistableBranch", SI);
+            return dsub
                 << "Dropped select due to unhoistable branch";
           });
         }
@@ -1166,9 +1170,10 @@ SmallVector<CHRScope *, 8> CHR::splitScope(
           PrevConditionValues = ConditionValues;
           PrevInsertPoint = InsertPoint;
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
+            OptimizationRemarkMissed ssfo(DEBUG_TYPE,
                                             "SplitScopeFromOuter",
-                                            RI.R->getEntry()->getTerminator())
+                                            RI.R->getEntry()->getTerminator());
+            return ssfo
                 << "Split scope from outer due to unhoistable branch/select "
                 << "and/or lack of common condition values";
           });
@@ -1202,9 +1207,10 @@ SmallVector<CHRScope *, 8> CHR::splitScope(
         PrevInsertPoint = InsertPoint;
         PrevSplitFromOuter = true;
         ORE.emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE,
+          OptimizationRemarkMissed ssfp(DEBUG_TYPE,
                                           "SplitScopeFromPrev",
-                                          RI.R->getEntry()->getTerminator())
+                                          RI.R->getEntry()->getTerminator());
+          return ssfp
               << "Split scope from previous due to unhoistable branch/select "
               << "and/or lack of common condition values";
         });
@@ -1330,10 +1336,11 @@ void CHR::filterScopes(SmallVectorImpl<CHRScope *> &Input,
                 << " true-selects " << Scope->TrueBiasedSelects.size()
                 << " false-selects " << Scope->FalseBiasedSelects.size() << "\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(
+        OptimizationRemarkMissed dswobos(
             DEBUG_TYPE,
             "DropScopeWithOneBranchOrSelect",
-            Scope->RegInfos[0].R->getEntry()->getTerminator())
+            Scope->RegInfos[0].R->getEntry()->getTerminator());
+        return dswobos
             << "Drop scope with < "
             << ore::NV("CHRMergeThreshold", CHRMergeThreshold)
             << " biased branch(es) or select(s)";
@@ -1685,8 +1692,9 @@ void CHR::transformScopes(CHRScope *Scope, DenseSet<PHINode *> &TrivialPHIs) {
       CHR_DEBUG(dbgs() << "Reached the dup threshold of " << Duplication
                        << " for this region");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "DupThresholdReached",
-                                        R->getEntry()->getTerminator())
+        OptimizationRemarkMissed dtr(DEBUG_TYPE, "DupThresholdReached",
+                                        R->getEntry()->getTerminator());
+        return dtr
                << "Reached the duplication threshold for the region";
       });
       return;
@@ -1859,10 +1867,11 @@ void CHR::fixupBranchesAndSelects(CHRScope *Scope,
   Stats.NumBranchesDelta += NumCHRedBranches - 1;
   Stats.WeightedNumBranchesDelta += (NumCHRedBranches - 1) * ProfileCount;
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE,
+    OptimizationRemark chr(DEBUG_TYPE,
                               "CHR",
                               // Refer to the hot (original) path
-                              MergedBR->getSuccessor(0)->getTerminator())
+                              MergedBR->getSuccessor(0)->getTerminator());
+    return chr
         << "Merged " << ore::NV("NumCHRedBranches", NumCHRedBranches)
         << " branches or selects";
   });
@@ -2052,7 +2061,8 @@ bool CHR::run() {
   if (Changed) {
     CHR_DEBUG(dumpIR(F, "after", &Stats));
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Stats", &F)
+      OptimizationRemark s(DEBUG_TYPE, "Stats", &F);
+      return s
           << ore::NV("Function", &F) << " "
           << "Reduced the number of branches in hot paths by "
           << ore::NV("NumBranchesDelta", Stats.NumBranchesDelta)


diff --git a/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp b/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
index 5b0951252c07..b26f61cf95ad 100644
--- a/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
+++ b/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
@@ -1011,7 +1011,8 @@ Value *LibCallSimplifier::optimizeStringLength(CallInst *CI, IRBuilderBase &B,
     uint64_t LenFalse = GetStringLength(SI->getFalseValue(), CharSize);
     if (LenTrue && LenFalse) {
       ORE.emit([&]() {
-        return OptimizationRemark("instcombine", "simplify-libcalls", CI)
+        OptimizationRemark ic("instcombine", "simplify-libcalls", CI);
+        return ic
                << "folded strlen(select) to select of constants";
       });
       return B.CreateSelect(SI->getCondition(),


diff --git a/llvm/lib/Transforms/Utils/MisExpect.cpp b/llvm/lib/Transforms/Utils/MisExpect.cpp
index 6f5a25a26821..400a372ef4d1 100644
--- a/llvm/lib/Transforms/Utils/MisExpect.cpp
+++ b/llvm/lib/Transforms/Utils/MisExpect.cpp
@@ -112,7 +112,8 @@ void emitMisexpectDiagnostic(Instruction *I, LLVMContext &Ctx,
   if (isMisExpectDiagEnabled(Ctx))
     Ctx.diagnose(DiagnosticInfoMisExpect(Cond, Msg));
   OptimizationRemarkEmitter ORE(I->getParent()->getParent());
-  ORE.emit(OptimizationRemark(DEBUG_TYPE, "misexpect", Cond) << RemStr.str());
+  OptimizationRemark me(DEBUG_TYPE, "misexpect", Cond);
+  ORE.emit(me << RemStr.str());
 }
 
 } // namespace


diff --git a/llvm/lib/Transforms/Utils/LoopUnroll.cpp b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
index 511dd61308f9..c722831cb06e 100644
--- a/llvm/lib/Transforms/Utils/LoopUnroll.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
@@ -461,8 +461,9 @@ LoopUnrollResult llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,
                       << " with trip count " << ULO.Count << "!\n");
     if (ORE)
       ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark fu(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
+                                  L->getHeader());
+        return fu
                << "completely unrolled loop with "
                << NV("UnrollCount", ULO.Count) << " iterations";
       });
diff --git a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
index 31b8cd34eb24..342e5908648e 100644
--- a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
@@ -264,8 +264,9 @@ llvm::UnrollAndJamLoop(Loop *L, unsigned Count, unsigned TripCount,
     LLVM_DEBUG(dbgs() << "COMPLETELY UNROLL AND JAMMING loop %"
                       << Header->getName() << " with trip count " << TripCount
                       << "!\n");
-    ORE->emit(OptimizationRemark(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
-                                 L->getHeader())
+    OptimizationRemark fu(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
+                                 L->getHeader());
+    ORE->emit(fu
               << "completely unroll and jammed loop with "
               << NV("UnrollCount", TripCount) << " iterations");
   } else {
@@ -281,12 +282,13 @@ llvm::UnrollAndJamLoop(Loop *L, unsigned Count, unsigned TripCount,
     if (TripMultiple != 1) {
       LLVM_DEBUG(dbgs() << " with " << TripMultiple << " trips per branch");
       ORE->emit([&]() {
-        return DiagBuilder() << " with " << NV("TripMultiple", TripMultiple)
+        auto dlg = DiagBuilder();
+        return dlg << " with " << NV("TripMultiple", TripMultiple)
                              << " trips per branch";
       });
     } else {
       LLVM_DEBUG(dbgs() << " with run-time trip count");
-      ORE->emit([&]() { return DiagBuilder() << " with run-time trip count"; });
+      ORE->emit([&]() { auto dlg = DiagBuilder(); return dlg << " with run-time trip count"; });
     }
     LLVM_DEBUG(dbgs() << "!\n");
   }


diff --git a/polly/lib/Transform/ManualOptimizer.cpp b/polly/lib/Transform/ManualOptimizer.cpp
index 264491b7577b..e9b20a2ac30e 100644
--- a/polly/lib/Transform/ManualOptimizer.cpp
+++ b/polly/lib/Transform/ManualOptimizer.cpp
@@ -167,8 +167,8 @@ private:
       LLVM_DEBUG(dbgs() << "Still accepting transformation due to "
                            "-polly-pragma-ignore-depcheck\n");
       if (ORE) {
-        ORE->emit(
-            OptimizationRemark(DEBUG_TYPE, RemarkName, TransformLoc, CodeRegion)
+        OptimizationRemark ppid(DEBUG_TYPE, RemarkName, TransformLoc, CodeRegion);
+        ORE->emit(ppid
             << (Twine("Could not verify dependencies for ") +
                 TransformationName +
                 "; still applying because of -polly-pragma-ignore-depcheck")
@@ -180,8 +180,9 @@ private:
     LLVM_DEBUG(dbgs() << "Rolling back transformation\n");
 
     if (ORE) {
-      ORE->emit(DiagnosticInfoOptimizationFailure(DEBUG_TYPE, RemarkName,
-                                                  TransformLoc, CodeRegion)
+      DiagnosticInfoOptimizationFailure diof(DEBUG_TYPE, RemarkName,
+                                                  TransformLoc, CodeRegion);
+      ORE->emit(diof
                 << (Twine("not applying ") + TransformationName +
                     ": cannot ensure semantic equivalence due to possible "
                     "dependency violations")


diff --git a/polly/lib/Transform/MaximalStaticExpansion.cpp b/polly/lib/Transform/MaximalStaticExpansion.cpp
index e32a69d47f69..5aefb6e3bf32 100644
--- a/polly/lib/Transform/MaximalStaticExpansion.cpp
+++ b/polly/lib/Transform/MaximalStaticExpansion.cpp
@@ -80,8 +80,8 @@ class MaximalStaticExpansionImpl {
 
   /// Emit remark
   void emitRemark(StringRef Msg, Instruction *Inst) {
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ExpansionRejection", Inst)
-             << Msg);
+    OptimizationRemarkAnalysis er(DEBUG_TYPE, "ExpansionRejection", Inst);
+    ORE.emit(er << Msg);
   }
 
   /// Filter the dependences to have only one related to current memory access.


diff --git a/polly/lib/Analysis/ScopBuilder.cpp b/polly/lib/Analysis/ScopBuilder.cpp
index 0e3de8b5b6c5..3d09e4f1c330 100644
--- a/polly/lib/Analysis/ScopBuilder.cpp
+++ b/polly/lib/Analysis/ScopBuilder.cpp
@@ -1377,9 +1377,8 @@ void ScopBuilder::addUserAssumptions(
     ParameterSetTy DetectedParams;
     auto &R = scop->getRegion();
     if (!isAffineConstraint(Val, &R, L, SE, DetectedParams)) {
-      ORE.emit(
-          OptimizationRemarkAnalysis(DEBUG_TYPE, "IgnoreUserAssumption", CI)
-          << "Non-affine user assumption ignored.");
+      OptimizationRemarkAnalysis iua(DEBUG_TYPE, "IgnoreUserAssumption", CI);
+      ORE.emit(iua << "Non-affine user assumption ignored.");
       continue;
     }
 
@@ -1429,8 +1428,8 @@ void ScopBuilder::addUserAssumptions(
             isl_set_project_out(AssumptionCtx, isl_dim_param, u--, 1);
       }
     }
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "UserAssumption", CI)
-             << "Use user assumption: "
+    OptimizationRemarkAnalysis ua(DEBUG_TYPE, "UserAssumption", CI);
+    ORE.emit(ua << "Use user assumption: "
              << stringFromIslObj(AssumptionCtx, "null"));
     isl::set newContext =
         scop->getContext().intersect(isl::manage(AssumptionCtx));
@@ -3291,8 +3290,9 @@ bool ScopBuilder::buildAliasGroup(
     return true;
 
   for (MemoryAccess *Access : AliasGroup) {
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "PossibleAlias",
-                                        Access->getAccessInstruction())
+    OptimizationRemarkAnalysis pa(DEBUG_TYPE, "PossibleAlias",
+                                        Access->getAccessInstruction());
+    ORE.emit(pa
              << "Possibly aliasing pointer, use restrict keyword.");
     const ScopArrayInfo *Array = Access->getScopArrayInfo();
     if (HasWriteAccess.count(Array)) {
@@ -3615,8 +3615,8 @@ ScopBuilder::ScopBuilder(Region *R, AssumptionCache &AC, AAResults &AA,
   getDebugLocations(P, Beg, End);
 
   std::string Msg = "SCoP begins here.";
-  ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEntry", Beg, P.first)
-           << Msg);
+  OptimizationRemarkAnalysis se(DEBUG_TYPE, "ScopEntry", Beg, P.first);
+  ORE.emit(se << Msg);
 
   buildScop(*R, AC);
 
@@ -3635,10 +3635,11 @@ ScopBuilder::ScopBuilder(Region *R, AssumptionCache &AC, AAResults &AA,
       ++RichScopFound;
   }
 
-  if (R->isTopLevelRegion())
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEnd", End, P.first)
-             << Msg);
-  else
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEnd", End, P.second)
-             << Msg);
+  if (R->isTopLevelRegion()) {
+    OptimizationRemarkAnalysis setlr(DEBUG_TYPE, "ScopEnd", End, P.first);
+    ORE.emit(setlr << Msg);
+  } else {
+    OptimizationRemarkAnalysis sentlr(DEBUG_TYPE, "ScopEnd", End, P.second);
+    ORE.emit(sentlr << Msg);
+  }
 }
diff --git a/polly/lib/Analysis/ScopDetectionDiagnostic.cpp b/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
index 0bac2cfd1555..327fb6bcc1ba 100644
--- a/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
+++ b/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
@@ -137,31 +137,31 @@ void emitRejectionRemarks(const BBPair &P, const RejectLog &Log,
   DebugLoc Begin, End;
   getDebugLocations(P, Begin, End);
 
-  ORE.emit(
-      OptimizationRemarkMissed(DEBUG_TYPE, "RejectionErrors", Begin, P.first)
+  OptimizationRemarkMissed re(DEBUG_TYPE, "RejectionErrors", Begin, P.first);
+  ORE.emit(re
       << "The following errors keep this region from being a Scop.");
 
   for (RejectReasonPtr RR : Log) {
 
-    if (const DebugLoc &Loc = RR->getDebugLoc())
-      ORE.emit(OptimizationRemarkMissed(DEBUG_TYPE, RR->getRemarkName(), Loc,
-                                        RR->getRemarkBB())
-               << RR->getEndUserMessage());
-    else
-      ORE.emit(OptimizationRemarkMissed(DEBUG_TYPE, RR->getRemarkName(), Begin,
-                                        RR->getRemarkBB())
-               << RR->getEndUserMessage());
+    if (const DebugLoc &Loc = RR->getDebugLoc()) {
+      OptimizationRemarkMissed dl(DEBUG_TYPE, RR->getRemarkName(), Loc,
+                                        RR->getRemarkBB());
+      ORE.emit(dl << RR->getEndUserMessage());
+    } else {
+      OptimizationRemarkMissed ndl(DEBUG_TYPE, RR->getRemarkName(), Begin,
+                                        RR->getRemarkBB());
+      ORE.emit(ndl << RR->getEndUserMessage());
+    }
   }
 
   /* Check to see if Region is a top level region, getExit = NULL*/
-  if (P.second)
-    ORE.emit(
-        OptimizationRemarkMissed(DEBUG_TYPE, "InvalidScopEnd", End, P.second)
-        << "Invalid Scop candidate ends here.");
-  else
-    ORE.emit(
-        OptimizationRemarkMissed(DEBUG_TYPE, "InvalidScopEnd", End, P.first)
-        << "Invalid Scop candidate ends here.");
+  if (P.second) {
+    OptimizationRemarkMissed is(DEBUG_TYPE, "InvalidScopEnd", End, P.second);
+    ORE.emit(is << "Invalid Scop candidate ends here.");
+  } else {
+    OptimizationRemarkMissed ise(DEBUG_TYPE, "InvalidScopEnd", End, P.first);
+    ORE.emit(ise << "Invalid Scop candidate ends here.");
+  }
 }
 
 //===----------------------------------------------------------------------===//


diff --git a/polly/lib/Analysis/ScopInfo.cpp b/polly/lib/Analysis/ScopInfo.cpp
index ffa61bb7787f..04ced7e48165 100644
--- a/polly/lib/Analysis/ScopInfo.cpp
+++ b/polly/lib/Analysis/ScopInfo.cpp
@@ -1994,13 +1994,14 @@ bool Scop::trackAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,
 
   auto Suffix = Sign == AS_ASSUMPTION ? " assumption:\t" : " restriction:\t";
   std::string Msg = toString(Kind) + Suffix + stringFromIslObj(Set);
-  if (BB)
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "AssumpRestrict", Loc, BB)
-             << Msg);
-  else
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "AssumpRestrict", Loc,
-                                        R.getEntry())
-             << Msg);
+  if (BB) {
+    OptimizationRemarkAnalysis arbb(DEBUG_TYPE, "AssumpRestrict", Loc, BB);
+    ORE.emit(arbb << Msg);
+  } else {
+    OptimizationRemarkAnalysis ar(DEBUG_TYPE, "AssumpRestrict", Loc,
+                                        R.getEntry());
+    ORE.emit(ar << Msg);
+  }
   return true;
 }
 


diff --git a/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp b/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
index 7cd8e53e6521..eabc643fe831 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
@@ -1273,9 +1273,10 @@ void AMDGPUAsmPrinter::emitResourceUsageRemarks(
       LabelStr = Indent + LabelStr;
 
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(Name, RemarkName,
+      MachineOptimizationRemarkAnalysis mora(Name, RemarkName,
                                                MF.getFunction().getSubprogram(),
-                                               &MF.front())
+                                               &MF.front());
+      return mora
              << LabelStr << ore::NV(RemarkName, Argument);
     });
   };


diff --git a/llvm/lib/Target/AMDGPU/SIISelLowering.cpp b/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
index 3148f49ff0d5..d89f56e843d3 100644
--- a/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
+++ b/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
@@ -14048,9 +14048,9 @@ SITargetLowering::shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {
     auto MemScope = SSNs[RMW->getSyncScopeID()].empty()
                         ? "system"
                         : SSNs[RMW->getSyncScopeID()];
+    OptimizationRemark p(DEBUG_TYPE, "Passed", RMW);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Passed", RMW)
-             << "Hardware instruction generated for atomic "
+      return p << "Hardware instruction generated for atomic "
              << RMW->getOperationName(RMW->getOperation())
              << " operation at memory scope " << MemScope
              << " due to an unsafe request.";


diff --git a/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp b/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
index 580352fb8cf4..a5d6ef47a5eb 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
@@ -115,7 +115,8 @@ void reportFunctionRemoved(Function &F, unsigned Feature) {
     // debug info is not present, users get "<unknown>:0:0" as the debug
     // loc. If we didn't print the function name there would be no way to
     // tell which function got removed.
-    return OptimizationRemark(DEBUG_TYPE, "AMDGPUIncompatibleFnRemoved", &F)
+    OptimizationRemark amdgpuifr(DEBUG_TYPE, "AMDGPUIncompatibleFnRemoved", &F);
+    return amdgpuifr
            << "removing function '" << F.getName() << "': +"
            << getFeatureName(Feature)
            << " is not supported on the current target";


diff --git a/llvm/lib/Transforms/Scalar/LoopFuse.cpp b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
index d35b562be0aa..5a051cc90d94 100644
--- a/llvm/lib/Transforms/Scalar/LoopFuse.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
@@ -373,8 +373,9 @@ private:
     assert(L && Preheader && "Fusion candidate not initialized properly!");
 #if LLVM_ENABLE_STATS
     ++Stat;
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, Stat.getName(),
-                                        L->getStartLoc(), Preheader)
+    OptimizationRemarkAnalysis ora(DEBUG_TYPE, Stat.getName(),
+                                        L->getStartLoc(), Preheader);
+    ORE.emit(ora
              << "[" << Preheader->getParent()->getName() << "]: "
              << "Loop is not a candidate for fusion: " << Stat.getDesc());
 #endif
@@ -1785,8 +1786,9 @@ private:
     using namespace ore;
 #if LLVM_ENABLE_STATS
     ++Stat;
-    ORE.emit(RemarkKind(DEBUG_TYPE, Stat.getName(), FC0.L->getStartLoc(),
-                        FC0.Preheader)
+    RemarkKind rk(DEBUG_TYPE, Stat.getName(), FC0.L->getStartLoc(),
+                        FC0.Preheader);
+    ORE.emit(rk
              << "[" << FC0.Preheader->getParent()->getName()
              << "]: " << NV("Cand1", StringRef(FC0.Preheader->getName()))
              << " and " << NV("Cand2", StringRef(FC1.Preheader->getName()))


diff --git a/lld/MachO/InputFiles.cpp b/lld/MachO/InputFiles.cpp
index c89f6f4722dc..f1fc12d98e17 100644
--- a/lld/MachO/InputFiles.cpp
+++ b/lld/MachO/InputFiles.cpp
@@ -2218,6 +2218,8 @@ BitcodeFile::BitcodeFile(MemoryBufferRef mb, StringRef archiveName,
     parse();
 }
 
+BitcodeFile::~BitcodeFile() {}
+
 void BitcodeFile::parse() {
   // Convert LTO Symbols to LLD Symbols in order to perform resolution. The
   // "winning" symbol will then be marked as Prevailing at LTO compilation
diff --git a/lld/MachO/InputFiles.h b/lld/MachO/InputFiles.h
index 66d46e46fa73..21e865e8af63 100644
--- a/lld/MachO/InputFiles.h
+++ b/lld/MachO/InputFiles.h
@@ -302,6 +302,7 @@ public:
   explicit BitcodeFile(MemoryBufferRef mb, StringRef archiveName,
                        uint64_t offsetInArchive, bool lazy = false,
                        bool forceHidden = false);
+  ~BitcodeFile();
   static bool classof(const InputFile *f) { return f->kind() == BitcodeKind; }
   void parse();
 
















