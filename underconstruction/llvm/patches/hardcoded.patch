

# diff --git a/clang/lib/Basic/Targets/PPC.h b/clang/lib/Basic/Targets/PPC.h
# index ac52eb219..8cf7f8f77 100644
# --- a/clang/lib/Basic/Targets/PPC.h
# +++ b/clang/lib/Basic/Targets/PPC.h
# @@ -424,11 +424,10 @@ public:
#        LongDoubleFormat = &llvm::APFloat::IEEEdouble();
#      } else if ((Triple.getArch() == llvm::Triple::ppc64le)) {
#        DataLayout = "e-m:e-i64:64-n32:64";
# -      ABI = "elfv2";
#      } else {
#        DataLayout = "E-m:e-i64:64-n32:64";
# -      ABI = "elfv1";
#      }
# +    ABI = "elfv2";
# 
#      if (Triple.isOSFreeBSD() || Triple.isOSOpenBSD() || Triple.isMusl()) {
#        LongDoubleWidth = LongDoubleAlign = 64;

# diff --git a/clang/lib/CodeGen/TargetInfo.cpp b/clang/lib/CodeGen/TargetInfo.cpp
# index 9af3004eb..2b71c282c 100644
# --- a/clang/lib/CodeGen/TargetInfo.cpp
# +++ b/clang/lib/CodeGen/TargetInfo.cpp
# @@ -11342,9 +11342,9 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
#        return SetCGInfo(new AIXTargetCodeGenInfo(Types, /*Is64Bit*/ true));
# 
#      if (Triple.isOSBinFormatELF()) {
# -      PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv1;
# -      if (getTarget().getABI() == "elfv2")
# -        Kind = PPC64_SVR4_ABIInfo::ELFv2;
# +      PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv2;
# +      if (getTarget().getABI() == "elfv1")
# +        Kind = PPC64_SVR4_ABIInfo::ELFv1;
#        bool IsSoftFloat = CodeGenOpts.FloatABI == "soft";
# 
#        return SetCGInfo(

# diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
# index e7ba91240..d81f652cb 100644
# --- a/clang/lib/Driver/ToolChains/Clang.cpp
# +++ b/clang/lib/Driver/ToolChains/Clang.cpp
# @@ -2006,11 +2006,11 @@ void Clang::AddPPCTargetArgs(const ArgList &Args,
#    if (T.isOSBinFormatELF()) {
#      switch (getToolChain().getArch()) {
#      case llvm::Triple::ppc64: {
# -      if ((T.isOSFreeBSD() && T.getOSMajorVersion() >= 13) ||
# -          T.isOSOpenBSD() || T.isMusl())
# +      //if ((T.isOSFreeBSD() && T.getOSMajorVersion() >= 13) ||
# +      //    T.isOSOpenBSD() || T.isMusl())
#          ABIName = "elfv2";
# -      else
# -        ABIName = "elfv1";
# +      // else
# +      //   ABIName = "elfv1";
#        break;
#      }
#      case llvm::Triple::ppc64le:


# diff --git a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# index 3e86cf63c..0b3f17d50 100644
# --- a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# +++ b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
# @@ -1,12 +1,12 @@
# -set(ARM64 aarch64)
# -set(ARM32 arm armhf)
# +set(ARM64 aarch64 aarch64_be)
# +set(ARM32 arm armhf armv6m)
#  set(HEXAGON hexagon)
#  set(X86 i386)
#  set(X86_64 x86_64)
#  set(LOONGARCH64 loongarch64)
#  set(MIPS32 mips mipsel)
#  set(MIPS64 mips64 mips64el)
# -set(PPC32 powerpc powerpcspe)
# +set(PPC32 powerpc powerpcspe powerpcle)
#  set(PPC64 powerpc64 powerpc64le)
#  set(RISCV32 riscv32)
#  set(RISCV64 riscv64)
# @@ -75,7 +75,7 @@ if(APPLE)
#  set(ALL_XRAY_SUPPORTED_ARCH ${X86_64})
#  else()
#  set(ALL_XRAY_SUPPORTED_ARCH ${X86_64} ${ARM32} ${ARM64} ${MIPS32} ${MIPS64}
# -		powerpc64le ${HEXAGON})
# +		${PPC64} ${HEXAGON})
#  endif()
#  set(ALL_SHADOWCALLSTACK_SUPPORTED_ARCH ${ARM64})

diff --git a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
index d14745ef9d13..41ed9c2c28ea 100644
--- a/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
+++ b/compiler-rt/cmake/Modules/AllSupportedArchDefs.cmake
@@ -1,12 +1,12 @@
-set(ARM64 aarch64)
-set(ARM32 arm armhf)
+set(ARM64 aarch64 aarch64_be)
+set(ARM32 arm armhf armv6m)
 set(HEXAGON hexagon)
 set(X86 i386)
 set(X86_64 x86_64)
 set(LOONGARCH64 loongarch64)
 set(MIPS32 mips mipsel)
 set(MIPS64 mips64 mips64el)
-set(PPC32 powerpc powerpcspe)
+set(PPC32 powerpc powerpcspe powerpcle)
 set(PPC64 powerpc64 powerpc64le)
 set(RISCV32 riscv32)
 set(RISCV64 riscv64)


diff --git a/compiler-rt/cmake/base-config-ix.cmake b/compiler-rt/cmake/base-config-ix.cmake
index 9c62320c3922..fcf2cd6868a9 100644
--- a/compiler-rt/cmake/base-config-ix.cmake
+++ b/compiler-rt/cmake/base-config-ix.cmake
@@ -204,8 +204,11 @@ macro(test_targets)
       add_default_target_arch(${COMPILER_RT_DEFAULT_TARGET_ARCH})
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "i[2-6]86|x86|amd64")
       if(NOT MSVC)
-        test_target_arch(x86_64 "" "-m64")
-        test_target_arch(i386 __i386__ "-m32")
+        if (CMAKE_SIZEOF_VOID_P EQUAL 8)
+          test_target_arch(x86_64 __x86_64__ "-m64")
+        else()
+          test_target_arch(i386 __i386__ "-m32")
+        endif()
       else()
         if (CMAKE_SIZEOF_VOID_P EQUAL 4)
           test_target_arch(i386 "" "")
@@ -218,8 +221,10 @@ macro(test_targets)
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpc64le|ppc64le")
       test_target_arch(powerpc64le "" "-m64")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpc")
-      test_target_arch(powerpc "" "-m32")
+      test_target_arch(powerpc "" "-m32" "-mbig-endian" )
       test_target_arch(powerpc64 "" "-m64")
+    elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "powerpcle|ppcle")
+      test_target_arch(powerpcle "" "-m32" "-mlittle-endian" )
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "s390x")
       test_target_arch(s390x "" "")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "sparc")
@@ -255,6 +260,8 @@ macro(test_targets)
       test_target_arch(aarch32 "" "-march=armv8-a")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "aarch64")
       test_target_arch(aarch64 "" "-march=armv8-a")
+    elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "aarch64_be")
+      test_target_arch(aarch64_be "" "-march=armv8-a" "-mbig-endian" )
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "riscv32")
       test_target_arch(riscv32 "" "")
     elseif("${COMPILER_RT_DEFAULT_TARGET_ARCH}" MATCHES "riscv64")


# diff --git a/compiler-rt/cmake/builtin-config-ix.cmake b/compiler-rt/cmake/builtin-config-ix.cmake
# index c422ad45e..8aa50fc19 100644
# --- a/compiler-rt/cmake/builtin-config-ix.cmake
# +++ b/compiler-rt/cmake/builtin-config-ix.cmake
# @@ -44,7 +44,7 @@
#  asm(\"cas w0, w1, [x2]\");
#  ")
# 
# -set(ARM64 aarch64)
# +set(ARM64 aarch64 aarch64_be)
#  set(ARM32 arm armhf armv4t armv5te armv6 armv6m armv7m armv7em armv7 armv7s armv7k armv8m.main armv8.1m.main)
#  set(AVR avr)
#  set(HEXAGON hexagon)
# @@ -53,7 +53,7 @@
#  set(LOONGARCH64 loongarch64)
#  set(MIPS32 mips mipsel)
#  set(MIPS64 mips64 mips64el)
# -set(PPC32 powerpc powerpcspe)
# +set(PPC32 powerpc powerpcspe powerpcle)
#  set(PPC64 powerpc64 powerpc64le)
#  set(RISCV32 riscv32)
#  set(RISCV64 riscv64)

diff --git a/compiler-rt/cmake/crt-config-ix.cmake b/compiler-rt/cmake/crt-config-ix.cmake
index dc3265e60984..983f12f8a727 100644
--- a/compiler-rt/cmake/crt-config-ix.cmake
+++ b/compiler-rt/cmake/crt-config-ix.cmake
@@ -18,7 +18,7 @@ else()
   set(OS_NAME "${CMAKE_SYSTEM_NAME}")
 endif()
 
-set(ARM64 aarch64)
+set(ARM64 aarch64 aarch64_be)
 set(ARM32 arm armhf)
 set(HEXAGON hexagon)
 set(X86 i386)
@@ -26,7 +26,7 @@ set(X86_64 x86_64)
 set(LOONGARCH64 loongarch64)
 set(MIPS32 mips mipsel)
 set(MIPS64 mips64 mips64el)
-set(PPC32 powerpc powerpcspe)
+set(PPC32 powerpc powerpcspe powerpcle)
 set(PPC64 powerpc64 powerpc64le)
 set(RISCV32 riscv32)
 set(RISCV64 riscv64)



# diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
# index ea5ad9cdb..886ff1afd 100644
# --- a/compiler-rt/lib/builtins/CMakeLists.txt
# +++ b/compiler-rt/lib/builtins/CMakeLists.txt
# @@ -223,7 +223,7 @@
# 
#  option(COMPILER_RT_EXCLUDE_ATOMIC_BUILTIN
#    "Skip the atomic builtin (these should normally be provided by a shared library)"
# -  On)
# +  OFF)
# 
#  if(NOT FUCHSIA AND NOT COMPILER_RT_BAREMETAL_BUILD)
#    set(GENERIC_SOURCES
# @@ -568,6 +568,7 @@
#  set(arm64_SOURCES ${aarch64_SOURCES})
#  set(arm64e_SOURCES ${aarch64_SOURCES})
#  set(arm64_32_SOURCES ${aarch64_SOURCES})
# +set(aarch64_be_SOURCES ${aarch64_SOURCES})
# 
#  # macho_embedded archs
#  set(armv6m_SOURCES ${thumb1_SOURCES})
# @@ -628,6 +629,7 @@
#  set(mips64el_SOURCES ${GENERIC_TF_SOURCES}
#                       ${mips_SOURCES})
# 
# +set(powerpcle_SOURCES ${GENERIC_SOURCES})
#  set(powerpc_SOURCES ${GENERIC_SOURCES})
# 
#  set(powerpcspe_SOURCES ${GENERIC_SOURCES})
# @@ -775,6 +777,16 @@
#          )
# 
#          set(deps_aarch64 lse_builtin_symlinks)
# +      endif()
# +
# +      if(arch STREQUAL "aarch64_be")
# +        add_custom_target(
# +          lse_builtin_symlinks
# +          BYPRODUCTS ${lse_builtins}
# +          ${arm64_lse_commands}
# +        )
# +
# +        set(deps_aarch64_be lse_builtin_symlinks)
#        endif()
# 
#        add_compiler_rt_runtime(clang_rt.builtins

# diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
# index 7f00391d1dce..0743df4224f6 100644
# --- a/compiler-rt/lib/builtins/CMakeLists.txt
# +++ b/compiler-rt/lib/builtins/CMakeLists.txt
# @@ -220,7 +220,7 @@ set(GENERIC_TF_SOURCES
#  
#  option(COMPILER_RT_EXCLUDE_ATOMIC_BUILTIN
#    "Skip the atomic builtin (these should normally be provided by a shared library)"
# -  On)
# +  ON)
#  
#  if(NOT FUCHSIA AND NOT COMPILER_RT_BAREMETAL_BUILD)
#    set(GENERIC_SOURCES
# @@ -600,6 +600,7 @@ set(armv7k_SOURCES ${arm_SOURCES})
#  set(arm64_SOURCES ${aarch64_SOURCES})
#  set(arm64e_SOURCES ${aarch64_SOURCES})
#  set(arm64_32_SOURCES ${aarch64_SOURCES})
# +set(aarch64_be_SOURCES ${aarch64_SOURCES})
#  
#  # macho_embedded archs
#  set(armv6m_SOURCES ${thumb1_SOURCES})
# @@ -669,6 +670,7 @@ set(mips64_SOURCES ${GENERIC_TF_SOURCES}
#  set(mips64el_SOURCES ${GENERIC_TF_SOURCES}
#                       ${mips_SOURCES})
#  
# +set(powerpcle_SOURCES ${GENERIC_SOURCES})
#  set(powerpc_SOURCES ${GENERIC_SOURCES})
#  
#  set(powerpcspe_SOURCES ${GENERIC_SOURCES})
# @@ -839,6 +841,16 @@ else ()
#          set(deps_aarch64 lse_builtin_symlinks)
#        endif()
#  
# +      if(arch STREQUAL "aarch64_be")
# +        add_custom_target(
# +          lse_builtin_symlinks
# +          BYPRODUCTS ${lse_builtins}
# +          ${arm64_lse_commands}
# +        )
# +
# +        set(deps_aarch64_be lse_builtin_symlinks)
# +      endif()
# +
#        add_compiler_rt_runtime(clang_rt.builtins
#                                STATIC
#                                ARCHS ${arch}


diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
index 7f00391d1dce..9c26c4423d50 100644
--- a/compiler-rt/lib/builtins/CMakeLists.txt
+++ b/compiler-rt/lib/builtins/CMakeLists.txt
@@ -54,6 +54,19 @@ include(builtin-config-ix)
 include(CMakeDependentOption)
 include(CMakePushCheckState)
 
+set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set (CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
+add_definitions(-D __ELF__)
+
 option(COMPILER_RT_BUILTINS_HIDE_SYMBOLS
   "Do not export any symbols from the static library." ON)
 
@@ -600,6 +613,7 @@ set(armv7k_SOURCES ${arm_SOURCES})
 set(arm64_SOURCES ${aarch64_SOURCES})
 set(arm64e_SOURCES ${aarch64_SOURCES})
 set(arm64_32_SOURCES ${aarch64_SOURCES})
+set(aarch64_be_SOURCES ${aarch64_SOURCES})
 
 # macho_embedded archs
 set(armv6m_SOURCES ${thumb1_SOURCES})
@@ -669,6 +683,7 @@ set(mips64_SOURCES ${GENERIC_TF_SOURCES}
 set(mips64el_SOURCES ${GENERIC_TF_SOURCES}
                      ${mips_SOURCES})
 
+set(powerpcle_SOURCES ${GENERIC_SOURCES})
 set(powerpc_SOURCES ${GENERIC_SOURCES})
 
 set(powerpcspe_SOURCES ${GENERIC_SOURCES})
@@ -767,7 +782,7 @@ else ()
     endif()
   endif()
 
-  set(BUILTIN_DEFS "")
+  set(BUILTIN_DEFS " __ELF__ ")
 
   if(COMPILER_RT_BUILTINS_HIDE_SYMBOLS)
     append_list_if(COMPILER_RT_HAS_VISIBILITY_HIDDEN_FLAG VISIBILITY_HIDDEN BUILTIN_DEFS)

diff --git a/compiler-rt/lib/builtins/clear_cache.c b/compiler-rt/lib/builtins/clear_cache.c
index 8993761eb3d4..783edf766936 100644
--- a/compiler-rt/lib/builtins/clear_cache.c
+++ b/compiler-rt/lib/builtins/clear_cache.c
@@ -183,7 +183,7 @@ void __clear_cache(void *start, void *end) {
   const register void *end_reg __asm("a1") = end;
   // "0" means that we clear cache for all threads (SYS_RISCV_FLUSH_ICACHE_ALL)
   const register long flags __asm("a2") = 0;
-  const register long syscall_nr __asm("a7") = __NR_riscv_flush_icache;
+  const register long syscall_nr __asm("a7") = 259; // JD
   __asm __volatile("ecall"
                    : "=r"(start_reg)
                    : "r"(start_reg), "r"(end_reg), "r"(flags), "r"(syscall_nr));
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
index d2b3b63f3a7a..9deccbbc642f 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_linux.cpp
@@ -74,6 +74,10 @@
 #include <sys/utsname.h>
 #endif
 
+#  if SANITIZER_LINUX && defined(__powerpc__)
+#    include <asm/ptrace.h>
+#  endif
+
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
 #include <sys/personality.h>
 #endif
diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
index 32b8f47ed..e56d1c877 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_platform_limits_posix.cpp
@@ -94,7 +94,7 @@
 # include <utime.h>
 # include <sys/ptrace.h>
 #    if defined(__mips64) || defined(__aarch64__) || defined(__arm__) || \
-        defined(__hexagon__) || defined(__loongarch__) ||SANITIZER_RISCV64
+        defined(__hexagon__) || defined(__powerpc__) || defined(__loongarch__) || SANITIZER_RISCV64
 #      include <asm/ptrace.h>
 #      ifdef __arm__
 typedef struct user_fpregs elf_fpregset_t;

diff --git a/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp b/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
index 403bda117..b8f454e2f 100644
--- a/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
+++ b/compiler-rt/lib/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp
@@ -31,7 +31,7 @@
 #include <sys/types.h> // for pid_t
 #include <sys/uio.h> // for iovec
 #include <elf.h> // for NT_PRSTATUS
-#if (defined(__aarch64__) || SANITIZER_RISCV64 || SANITIZER_LOONGARCH64) && \
+#if (defined(__aarch64__) || defined(__powerpc__) || SANITIZER_RISCV64 || SANITIZER_LOONGARCH64) && \
      !SANITIZER_ANDROID
 // GLIBC 2.20+ sys/user does not include asm/ptrace.h
 # include <asm/ptrace.h>

diff --git a/compiler-rt/lib/xray/xray_powerpc64.inc b/compiler-rt/lib/xray/xray_powerpc64.inc
index 7e872b5b4..0fc24c203 100644
--- a/compiler-rt/lib/xray/xray_powerpc64.inc
+++ b/compiler-rt/lib/xray/xray_powerpc64.inc
@@ -13,7 +13,7 @@
 #include <cstdint>
 #include <mutex>
 #ifdef __linux__
-#include <sys/platform/ppc.h>
+// #include <sys/platform/ppc.h>
 #elif defined(__FreeBSD__)
 #include <sys/types.h>
 #include <sys/sysctl.h>

# diff --git a/compiler-rt/lib/xray/xray_powerpc64.inc b/compiler-rt/lib/xray/xray_powerpc64.inc
# index e4e16d5b2..c9590e1fe 100644
# --- a/compiler-rt/lib/xray/xray_powerpc64.inc
# +++ b/compiler-rt/lib/xray/xray_powerpc64.inc
# @@ -12,22 +12,26 @@
# 
#  #include <cstdint>
#  #include <mutex>
# -#ifdef __linux__
# +#ifdef __GLIBC__
#  #include <sys/platform/ppc.h>
#  #elif defined(__FreeBSD__)
#  #include <sys/types.h>
#  #include <sys/sysctl.h>
# 
#  #define __ppc_get_timebase __builtin_ppc_get_timebase
# 
#  uint64_t __ppc_get_timebase_freq (void)
#  {
#    uint64_t tb_freq = 0;
#    size_t length = sizeof(tb_freq);
#    sysctlbyname("kern.timecounter.tc.timebase.frequency", &tb_freq, &length, nullptr, 0);
#    return tb_freq;
#  }
# +#else
# +#include <cctype>
# +#include <cstring>
# +#include <cstdlib>
#  #endif
# 
#  #include "xray_defs.h"
# 
# @@ -35,13 +39,45 @@ namespace __xray {
# 
#  ALWAYS_INLINE uint64_t readTSC(uint8_t &CPU) XRAY_NEVER_INSTRUMENT {
#    CPU = 0;
# +#ifdef __GLIBC__
#    return __ppc_get_timebase();
# +#else
# +  return __builtin_ppc_get_timebase();
# +#endif
#  }
# 
#  inline uint64_t getTSCFrequency() XRAY_NEVER_INSTRUMENT {
#    static std::mutex M;
#    std::lock_guard<std::mutex> Guard(M);
# +#ifdef __GLIBC__
#    return __ppc_get_timebase_freq();
# +#else
# +  /* FIXME: a less dirty implementation? */
# +  static uint64_t base;
# +  if (!base) {
# +    FILE *f = fopen("/proc/cpuinfo", "rb");
# +    if (f) {
# +      ssize_t nr;
# +      /* virtually always big enough to hold the line */
# +      char buf[512];
# +      while (fgets(buf, sizeof(buf), f)) {
# +        char *ret = strstr(buf, "timebase");
# +        if (!ret) {
# +          continue;
# +        }
# +        ret += sizeof("timebase") - 1;
# +        ret = strchr(ret, ':');
# +        if (!ret) {
# +          continue;
# +        }
# +        base = strtoul(ret + 1, nullptr, 10);
# +        break;
# +      }
# +      fclose(f);
# +    }
# +  }
# +  return base;
# +#endif
#  }
# 
#  inline bool probeRequiredCPUFeatures() XRAY_NEVER_INSTRUMENT {


diff --git a/libcxx/include/limits b/libcxx/include/limits
index 9f5949e63cff..f0eeb887f0f5 100644
--- a/libcxx/include/limits
+++ b/libcxx/include/limits
@@ -430,8 +430,14 @@ protected:
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}
 
-#if defined(__powerpc__) && defined(__LONG_DOUBLE_IBM128__)
-    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
+#if (defined(__powerpc__) || defined(__powerpc64__)) && defined(__LONG_DOUBLE_IBM128__)
+#  if (__LDBL_MAX_EXP__ > __DBL_MAX_EXP__) || (__LDBL_MANT_DIG__ == __DBL_MANT_DIG__)
+     /* IEEE 754 quadruple or double precision */
+     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
+#  else
+     /* 128-bit IBM double-double */
+     static _LIBCPP_CONSTEXPR const bool is_iec559 = false;
+#  endif
 #else
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
 #endif


# diff --git a/libcxx/include/locale b/libcxx/include/locale
# index 7c2d2361f..1d6811b6f 100644
# --- a/libcxx/include/locale
# +++ b/libcxx/include/locale
# @@ -758,7 +758,7 @@
#          __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
#          errno = 0;
#          char *__p2;
# -        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
# +        long long __ll = strtoll_l(__a, &__p2, __base);
#          __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
#          if (__current_errno == 0)
#              errno = __save_errno;
# @@ -798,7 +798,7 @@
#          __libcpp_remove_reference_t<decltype(errno)> __save_errno = errno;
#          errno = 0;
#          char *__p2;
# -        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
# +        unsigned long long __ll = strtoull_l(__a, &__p2, __base);
#          __libcpp_remove_reference_t<decltype(errno)> __current_errno = errno;
#          if (__current_errno == 0)
#              errno = __save_errno;


# diff --git a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# index b1de8d00f..988bf275b 100644
# --- a/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# +++ b/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp
# @@ -225,9 +225,7 @@ static std::unique_ptr<TargetLoweringObjectFile> createTLOF(const Triple &TT) {
# 
#  static PPCTargetMachine::PPCABI computeTargetABI(const Triple &TT,
#                                                   const TargetOptions &Options) {
# -  if (Options.MCOptions.getABIName().startswith("elfv1"))
# -    return PPCTargetMachine::PPC_ABI_ELFv1;
# -  else if (Options.MCOptions.getABIName().startswith("elfv2"))
# +  if (Options.MCOptions.getABIName().startswith("elfv2"))
#      return PPCTargetMachine::PPC_ABI_ELFv2;
# 
#    assert(Options.MCOptions.getABIName().empty() &&
# @@ -237,7 +235,7 @@ static PPCTargetMachine::PPCABI computeTargetABI(const Triple &TT,
#    case Triple::ppc64le:
#      return PPCTargetMachine::PPC_ABI_ELFv2;
#    case Triple::ppc64:
# -    return PPCTargetMachine::PPC_ABI_ELFv1;
# +    return PPCTargetMachine::PPC_ABI_ELFv2;
#    default:
#      return PPCTargetMachine::PPC_ABI_UNKNOWN;
#    }

# Ignore it temporarily
# diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
# index 195dba9d2..770b3bfbb 100644
# --- a/llvm/runtimes/CMakeLists.txt
# +++ b/llvm/runtimes/CMakeLists.txt
# @@ -64,7 +64,7 @@ macro(set_enable_per_target_runtime_dir)
#    # May have been set by llvm/CMakeLists.txt.
#    if (NOT DEFINED LLVM_ENABLE_PER_TARGET_RUNTIME_DIR)
#      # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -    if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +    if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{LLVM_TARGET_TRIPLE}")
#        set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR OFF)
#      else()
#        set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON)
# @@ -86,6 +86,16 @@ function(builtin_default_target compiler_rt_path)
#                                        -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${BUILTINS_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES COMPILER_RT
# @@ -113,14 +123,28 @@ function(builtin_register_target compiler_rt_path target)
# 
#    llvm_ExternalProject_Add(builtins-${target}
#                             ${compiler_rt_path}/lib/builtins
# +                           ${compiler_rt_path}
#                             DEPENDS ${ARG_DEPENDS}
#                             CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
#                                        -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=OFF
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCMAKE_CXX_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=-nostdlib
# +                                      -DCMAKE_CXX_FLAGS=-nostdlib
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${target}_extra_args}
#                             USE_TOOLCHAIN
# @@ -218,6 +242,11 @@ function(runtime_default_target)
#      set_property(GLOBAL APPEND PROPERTY LLVM_ALL_LIT_TESTSUITES "@${LLVM_BINARY_DIR}/runtimes/runtimes-bins/lit.tests")
#      list(APPEND test_targets runtimes-test-depends check-runtimes)
#    endif()
# +  set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
# +
# +  set(RT_C_FLAGS "${CMAKE_C_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_CXX_FLAGS "${CMAKE_CXX_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_ASM_FLAGS "${CMAKE_ASM_FLAGS} --sysroot=${KISS_ROOT}")
# 
#    set_enable_per_target_runtime_dir()
# 
# @@ -234,6 +263,17 @@ function(runtime_default_target)
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=${RT_C_FLAGS}
# +                                      -DCMAKE_CXX_FLAGS=${RT_CXX_FLAGS}
# +                                      -DCMAKE_ASM_FLAGS=${RT_ASM_FLAGS}
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${RUNTIMES_CMAKE_ARGS}
#                                        ${ARG_CMAKE_ARGS}
# @@ -362,6 +402,16 @@ function(runtime_register_target name target)
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        -DLLVM_RUNTIMES_TARGET=${name}
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${name}_extra_args}
# 

# diff --git a/compiler-rt/lib/builtins/CMakeLists.txt b/compiler-rt/lib/builtins/CMakeLists.txt
# index 5e2274d52256..e66ce23701e1 100644
# --- a/compiler-rt/lib/builtins/CMakeLists.txt
# +++ b/compiler-rt/lib/builtins/CMakeLists.txt
# @@ -1,4 +1,4 @@
# -# This directory contains a large amount of C code which provides
# +# This
#  # generic implementations of the core runtime library along with optimized
#  # architecture-specific code in various subdirectories.

# Temporarily closed

# diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
# index 694f346ee8e9..f47fc2cebd03 100644
# --- a/llvm/runtimes/CMakeLists.txt
# +++ b/llvm/runtimes/CMakeLists.txt
# @@ -65,7 +65,7 @@ function(builtin_default_target compiler_rt_path)
# 
#    set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON)
#    # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -  if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +  if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{LLVM_TARGET_TRIPLE}")
#      set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
#    endif()
# 
# @@ -78,6 +78,16 @@ function(builtin_default_target compiler_rt_path)
#                                        -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${BUILTINS_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES COMPILER_RT
# @@ -105,14 +115,28 @@ function(builtin_register_target compiler_rt_path target)
# 
#    llvm_ExternalProject_Add(builtins-${target}
#                             ${compiler_rt_path}/lib/builtins
# +                           ${compiler_rt_path}
#                             DEPENDS ${ARG_DEPENDS}
#                             CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
#                                        -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCMAKE_CXX_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=-nostdlib
# +                                      -DCMAKE_CXX_FLAGS=-nostdlib
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${target}_extra_args}
#                             USE_TOOLCHAIN
# @@ -219,10 +243,14 @@ function(runtime_default_target)
# 
#    set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON)
#    # AIX should fold 32-bit & 64-bit arch libraries into a single archive.
# -  if (LLVM_TARGET_TRIPLE MATCHES "aix")
# +  if (LLVM_TARGET_TRIPLE MATCHES "aix" OR LLVM_TARGET_TRIPLE MATCHES "$ENV{LLVM_TARGET_TRIPLE}")
#      set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF)
#    endif()
# 
# +  set(RT_C_FLAGS "${CMAKE_C_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_CXX_FLAGS "${CMAKE_CXX_FLAGS} --sysroot=${KISS_ROOT}")
# +  set(RT_ASM_FLAGS "${CMAKE_ASM_FLAGS} --sysroot=${KISS_ROOT}")
# +
#    llvm_ExternalProject_Add(runtimes
#                             ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
#                             DEPENDS ${ARG_DEPENDS}
# @@ -236,6 +264,17 @@ function(runtime_default_target)
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
# +                                      -DCMAKE_C_FLAGS=${RT_C_FLAGS}
# +                                      -DCMAKE_CXX_FLAGS=${RT_CXX_FLAGS}
# +                                      -DCMAKE_ASM_FLAGS=${RT_ASM_FLAGS}
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${RUNTIMES_CMAKE_ARGS}
#                             PASSTHROUGH_PREFIXES LLVM_ENABLE_RUNTIMES
# @@ -356,11 +395,21 @@ function(runtime_register_target name target)
#                                        -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
#                                        -DLLVM_DEFAULT_TARGET_TRIPLE=${target}
#                                        -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
# -                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
# +                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default}
#                                        -DCMAKE_C_COMPILER_WORKS=ON
#                                        -DCMAKE_CXX_COMPILER_WORKS=ON
#                                        -DCMAKE_ASM_COMPILER_WORKS=ON
#                                        -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
# +                                      -DCOMPILER_RT_BUILD_CRT=ON
# +                                      -DCOMPILER_RT_BUILD_BUILTINS=ON
# +                                      -DCOMPILER_RT_BUILD_SANITIZERS=OFF
# +                                      -DCOMPILER_RT_BUILD_XRAY=OFF
# +                                      -DCOMPILER_RT_BUILD_LIBFUZZER=OFF
# +                                      -DCOMPILER_RT_BUILD_PROFILE=OFF
# +                                      -DCOMPILER_RT_BUILD_MEMPROF=OFF
# +                                      -DCOMPILER_RT_BUILD_ORC=OFF
# +                                      -DCOMPILER_RT_BUILD_GWP_ASAN=OFF
# +                                      -DCOMPILER_RT_ENABLE_CET=OFF
#                                        -DLLVM_RUNTIMES_TARGET=${name}
#                                        ${COMMON_CMAKE_ARGS}
#                                        ${${name}_extra_args}



diff --git a/llvm/runtimes/CMakeLists.txt b/llvm/runtimes/CMakeLists.txt
index 75256c1326be..3cb953da7cb9 100644
--- a/llvm/runtimes/CMakeLists.txt
+++ b/llvm/runtimes/CMakeLists.txt
@@ -86,6 +86,9 @@ function(builtin_default_target compiler_rt_path)
                                       -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${BUILTINS_CMAKE_ARGS}
                            PASSTHROUGH_PREFIXES COMPILER_RT
@@ -99,7 +102,12 @@ endfunction()
 function(builtin_register_target compiler_rt_path name)
   cmake_parse_arguments(ARG "" "" "DEPENDS;CMAKE_ARGS;EXTRA_ARGS" ${ARGN})
 
+  message(WARNING "\${compiler_rt_path}:  ${compiler_rt_path}")
+  message(WARNING "\${COMMON_CMAKE_ARGS}:  ${COMMON_CMAKE_ARGS}")
+  message(WARNING "target \${name}:  ${name}")
+  message(WARNING "\${ARG_CMAKE_ARGS}:  ${ARG_CMAKE_ARGS}")
   set(${name}_extra_args ${ARG_CMAKE_ARGS})
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
   get_cmake_property(variable_names VARIABLES)
   foreach(variable_name ${variable_names})
     string(FIND "${variable_name}" "BUILTINS_${name}" out)
@@ -110,15 +118,22 @@ function(builtin_register_target compiler_rt_path name)
     endif()
   endforeach()
 
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
+  message(WARNING "\${EXTRA_ARGS}:  ${EXTRA_ARGS}")
+  message(WARNING "\${ARG_EXTRA_ARGS}:  ${ARG_EXTRA_ARGS}")
+
   llvm_ExternalProject_Add(builtins-${name}
                            ${compiler_rt_path}/lib/builtins
                            DEPENDS ${ARG_DEPENDS}
                            CMAKE_ARGS -DLLVM_LIBRARY_OUTPUT_INTDIR=${LLVM_LIBRARY_DIR}
                                       -DLLVM_RUNTIME_OUTPUT_INTDIR=${LLVM_TOOLS_BINARY_DIR}
-                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=ON
+                                      -DLLVM_ENABLE_PER_TARGET_RUNTIME_DIR=${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR}
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
-                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=${COMPILER_RT_DEFAULT_TARGET_ONLY}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${${name}_extra_args}
                            USE_TOOLCHAIN
@@ -230,7 +245,7 @@ function(runtime_default_target)
                            ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
                            DEPENDS ${ARG_DEPENDS}
                            # Builtins were built separately above
-                           CMAKE_ARGS -DCOMPILER_RT_BUILD_BUILTINS=Off
+                           CMAKE_ARGS -DCOMPILER_RT_BUILD_BUILTINS=OFF
                                       -DLLVM_INCLUDE_TESTS=${LLVM_INCLUDE_TESTS}
                                       -DLLVM_DEFAULT_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       -DLLVM_ENABLE_PROJECTS_USED=${LLVM_ENABLE_PROJECTS_USED}
@@ -239,11 +254,13 @@ function(runtime_default_target)
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${RUNTIMES_CMAKE_ARGS}
                                       ${ARG_CMAKE_ARGS}
                            PASSTHROUGH_PREFIXES LLVM_ENABLE_RUNTIMES
-                                                LLVM_USE_LINKER
                                                 ${ARG_PREFIXES}
                            EXTRA_TARGETS ${extra_targets}
                                          ${test_targets}
@@ -318,7 +335,6 @@ function(runtime_register_target name)
   set(${name}_extra_args ${ARG_CMAKE_ARGS})
   string(REPLACE ";" "|" LLVM_ENABLE_RUNTIMES_PASSTHROUGH "${LLVM_ENABLE_RUNTIMES}")
   list(APPEND ${name}_extra_args -DLLVM_ENABLE_RUNTIMES=${LLVM_ENABLE_RUNTIMES_PASSTHROUGH})
-  list(APPEND ${name}_extra_args -DLLVM_USE_LINKER=${LLVM_USE_LINKER})
 
   get_cmake_property(variable_names VARIABLES)
   foreach(extra_name IN ITEMS ${ARG_BASE_NAME} ${name})
@@ -334,6 +350,10 @@ function(runtime_register_target name)
 
   set_enable_per_target_runtime_dir()
 
+  message(WARNING "target \${${name}_extra_args}:  ${${name}_extra_args}")
+  message(WARNING "\${EXTRA_ARGS}:  ${EXTRA_ARGS}")
+  message(WARNING "\${ARG_EXTRA_ARGS}:  ${ARG_EXTRA_ARGS}")
+
   llvm_ExternalProject_Add(runtimes-${name}
                            ${CMAKE_CURRENT_SOURCE_DIR}/../../runtimes
                            DEPENDS ${ARG_DEPENDS}
@@ -345,8 +365,11 @@ function(runtime_register_target name)
                                       -DCMAKE_C_COMPILER_WORKS=ON
                                       -DCMAKE_CXX_COMPILER_WORKS=ON
                                       -DCMAKE_ASM_COMPILER_WORKS=ON
-                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON
+                                      -DCOMPILER_RESOURCE_DIR=${COMPILER_RESOURCE_DIR}
+                                      -DCLANG_RESOURCE_DIR=${CLANG_RESOURCE_DIR}
+                                      -DCOMPILER_RT_DEFAULT_TARGET_ONLY=${COMPILER_RT_DEFAULT_TARGET_ONLY}
                                       -DLLVM_RUNTIMES_TARGET=${name}
+                                      -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                                       ${COMMON_CMAKE_ARGS}
                                       ${${name}_extra_args}
                            EXTRA_TARGETS ${${name}_extra_targets}


diff --git a/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll b/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
index 8b1cf6b58..296a2afa6 100644
--- a/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
+++ b/llvm/test/CodeGen/PowerPC/ppc64-elf-abi.ll
@@ -1,4 +1,5 @@
-; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv1
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv2
+; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-musl < %s | FileCheck %s -check-prefix=CHECK-ELFv2
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu -target-abi elfv1 < %s | FileCheck %s -check-prefix=CHECK-ELFv1
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64-unknown-linux-gnu -target-abi elfv2 < %s | FileCheck %s -check-prefix=CHECK-ELFv2
 ; RUN: llc -verify-machineinstrs -mtriple=powerpc64le-unknown-linux-gnu < %s | FileCheck %s -check-prefix=CHECK-ELFv2
# diff --git a/llvm/cmake/modules/LLVMInstallSymlink.cmake b/llvm/cmake/modules/LLVMInstallSymlink.cmake
# index 1400233b7..0a7b38737 100644
# --- a/llvm/cmake/modules/LLVMInstallSymlink.cmake
# +++ b/llvm/cmake/modules/LLVMInstallSymlink.cmake
# @@ -2,6 +2,9 @@
#  # DESTDIR environment variable may be unset at configuration time.
#  # See PR8397.
# 
# +# Set to an arbitrary directory to silence GNUInstallDirs warnings
# +# regarding being unable to determine libdir.
# +set(CMAKE_INSTALL_LIBDIR "lib")
#  include(GNUInstallDirs)
# 
#  function(install_symlink name target outdir)

# @@ -454,7 +458,8 @@
#  # LIBCXX_COMPILE_FLAGS: Compile only flags.
#  # LIBCXX_LINK_FLAGS: Linker only flags.
#  # LIBCXX_LIBRARIES: libraries libc++ is linked to.
# -set(LIBCXX_COMPILE_FLAGS "")
# +set(LIBCXX_COMPILE_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +set(CMAKE_CXX_FLAGS "${LIBCXX_COMPILE_FLAGS}")
#  set(LIBCXX_LINK_FLAGS "")
#  set(LIBCXX_LIBRARIES "")

# diff --git a/runtimes/CMakeLists.txt b/runtimes/CMakeLists.txt
# index 1400233b7..0a7b38737 100644
# --- a/runtimes/CMakeLists.txt
# +++ b/runtimes/CMakeLists.txt
# @@ -23,7 +23,7 @@
#  # We order libraries to mirror roughly how they are layered, except that compiler-rt can depend
#  # on libc++, so we put it after.
#  set(LLVM_DEFAULT_RUNTIMES "libc;libunwind;libcxxabi;pstl;libcxx;compiler-rt;openmp")
# -set(LLVM_SUPPORTED_RUNTIMES "${LLVM_DEFAULT_RUNTIMES};llvm-libgcc")
# +# set(LLVM_SUPPORTED_RUNTIMES "${LLVM_DEFAULT_RUNTIMES};llvm-libgcc")
#  set(LLVM_ENABLE_RUNTIMES "" CACHE STRING
#    "Semicolon-separated list of runtimes to build, or \"all\" (${LLVM_DEFAULT_RUNTIMES}). Supported runtimes are ${LLVM_SUPPORTED_RUNTIMES}.")
#  if(LLVM_ENABLE_RUNTIMES STREQUAL "all" )
# @@ -149,6 +149,8 @@
#    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
#  endif()
# 
# +set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} --sysroot=${KISS_ROOT}")
# +
#  # Avoid checking whether the compiler is working.
#  set(LLVM_COMPILER_CHECKED ON)
# 
# @@ -164,8 +166,8 @@
#  set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
#    "Default target for which the runtimes will be built.")
# 
# -option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
# -option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
# +option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." OFF)
# +option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." OFF)
#  option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)
# 
#  # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.
# 

# diff --git a/runtimes/CMakeLists.txt b/runtimes/CMakeLists.txt
# index 599529852688..e45f95d3014b 100644
# --- a/runtimes/CMakeLists.txt
# +++ b/runtimes/CMakeLists.txt
# @@ -143,10 +143,10 @@ llvm_check_compiler_linker_flag(CXX "-nostdlib++" CXX_SUPPORTS_NOSTDLIBXX_FLAG)
#  if (CXX_SUPPORTS_NOSTDLIBXX_FLAG)
#    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdlib++")
#  endif()
# -check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# -endif()
# +# check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +# if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +#   set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# +# endif()
#  
#  # Avoid checking whether the compiler is working.
#  set(LLVM_COMPILER_CHECKED ON)


# diff --git a/runtimes/CMakeLists.txt b/runtimes/CMakeLists.txt
# index 599529852688..e32324357332 100644
# --- a/runtimes/CMakeLists.txt
# +++ b/runtimes/CMakeLists.txt
# @@ -163,6 +163,9 @@ get_host_triple(LLVM_HOST_TRIPLE)
#  set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
#    "Default target for which the runtimes will be built.")
#  
# +add_definitions(-U_GLIBCXX_ASSERTIONS)
# +add_definitions(-U_LIBCPP_ENABLE_ASSERTIONS)
# +
#  option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
#  option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
#  option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)


diff --git a/runtimes/CMakeLists.txt b/runtimes/CMakeLists.txt
index 599529852688..56752ac90e06 100644
--- a/runtimes/CMakeLists.txt
+++ b/runtimes/CMakeLists.txt
@@ -45,17 +45,41 @@ function(runtime_register_component name)
   set_property(GLOBAL APPEND PROPERTY SUB_COMPONENTS ${name})
 endfunction()
 
-find_package(LLVM PATHS "${LLVM_BINARY_DIR}" NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
-find_package(Clang PATHS "${LLVM_BINARY_DIR}" NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
-
-set(LLVM_THIRD_PARTY_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../third-party")
-
 # If building standalone by pointing CMake at this runtimes directory,
 # LLVM_BINARY_DIR isn't set, find_package(LLVM) will fail and these
 # intermediate paths are unset.
 if (NOT LLVM_BINARY_DIR)
+  message(WARNING "\${CMAKE_CURRENT_BINARY_DIR} = ${CMAKE_CURRENT_BINARY_DIR}")
+  if (NOT CMAKE_CURRENT_BINARY_DIR STREQUAL "$ENV{OUTPUT_DIR}")
+    message(FATAL_ERROR "\${CMAKE_CURRENT_BINARY_DIR} = ${CMAKE_CURRENT_BINARY_DIR}")
+  endif()
   set(LLVM_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
 endif()
+message(WARNING "\${LLVM_BINARY_DIR} = ${LLVM_BINARY_DIR}")
+
+if (NOT LLVM_DIR)
+  message(WARNING "\$ENV{LLVM_DIR} = $ENV{LLVM_DIR}")
+  if (NOT DEFINED ENV{LLVM_DIR} OR ENV{LLVM_DIR} STREQUAL "")
+    message(FATAL_ERROR "\$ENV{LLVM_DIR} = $ENV{LLVM_DIR}")
+  endif()
+  set(LLVM_DIR $ENV{LLVM_DIR})
+endif()
+message(WARNING "\${LLVM_DIR} = ${LLVM_DIR}")
+
+# This variable makes sure that e.g. llvm-lit is found.
+set(LLVM_MAIN_SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../llvm)
+set(LLVM_CMAKE_DIR ${LLVM_MAIN_SRC_DIR}/cmake/modules)
+list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
+list(APPEND CMAKE_MODULE_PATH "${LLVM_BINARY_DIR}/lib/cmake/llvm")
+list(APPEND CMAKE_MODULE_PATH "${LLVM_BINARY_DIR}/lib/cmake/clang")
+list(APPEND CMAKE_PREFIX_PATH "${LLVM_BINARY_DIR}/lib/cmake/*")
+
+find_package(LLVM  REQUIRED HINTS "${LLVM_CMAKE_DIR}" PATHS "${LLVM_BINARY_DIR}/lib/cmake/llvm"  NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
+list(APPEND CMAKE_MODULE_PATH "${LLVM_DIR}")
+find_package(Clang REQUIRED HINTS "${LLVM_CMAKE_DIR}" PATHS "${LLVM_BINARY_DIR}/lib/cmake/clang" NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
+
+set(LLVM_THIRD_PARTY_DIR "${CMAKE_CURRENT_SOURCE_DIR}/../third-party")
+
 if (NOT LLVM_FOUND)
   set(LLVM_TOOLS_BINARY_DIR ${LLVM_BINARY_DIR}/bin)
   set(LLVM_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/include)
@@ -67,10 +91,6 @@ endif()
 set(LLVM_LIBRARY_OUTPUT_INTDIR ${LLVM_LIBRARY_DIR})
 set(LLVM_RUNTIME_OUTPUT_INTDIR ${LLVM_TOOLS_BINARY_DIR})
 
-# This variable makes sure that e.g. llvm-lit is found.
-set(LLVM_MAIN_SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../llvm)
-set(LLVM_CMAKE_DIR ${LLVM_MAIN_SRC_DIR}/cmake/modules)
-
 # This variable is used by individual runtimes to locate LLVM files.
 set(LLVM_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../llvm)
 
@@ -163,6 +183,9 @@ get_host_triple(LLVM_HOST_TRIPLE)
 set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
   "Default target for which the runtimes will be built.")
 
+add_definitions(-U_GLIBCXX_ASSERTIONS)
+add_definitions(-U_LIBCPP_ENABLE_ASSERTIONS)
+
 option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
 option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
 option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)
@@ -237,7 +260,7 @@ foreach(entry ${runtimes})
   add_subdirectory(${entry} ${projName})
 endforeach()
 
-if(LLVM_INCLUDE_TESTS)
+if(LLVM_INCLUDE_TESTS AND TARGET scudo_standalone)
   # LLVM_RUNTIMES_LIT_DEPENDS is populated when lit tests are added between
   # umbrella_list_testsuite begin and end. The bootstrap runtimes builds
   # currently assumes this target exists.


diff --git a/cmake/Modules/CMakePolicy.cmake b/cmake/Modules/CMakePolicy.cmake
index 0ec32ad8637f..5ea248692216 100644
--- a/cmake/Modules/CMakePolicy.cmake
+++ b/cmake/Modules/CMakePolicy.cmake
@@ -2,11 +2,11 @@
 
 # CMP0114: ExternalProject step targets fully adopt their steps.
 # New in CMake 3.19: https://cmake.org/cmake/help/latest/policy/CMP0114.html
-if(POLICY CMP0114)
-  cmake_policy(SET CMP0114 OLD)
-endif()
+# if(POLICY CMP0114)
+#   cmake_policy(SET CMP0114 OLD)
+# endif()
 # CMP0116: Ninja generators transform `DEPFILE`s from `add_custom_command()`
 # New in CMake 3.20. https://cmake.org/cmake/help/latest/policy/CMP0116.html
-if(POLICY CMP0116)
-  cmake_policy(SET CMP0116 OLD)
-endif()
+# if(POLICY CMP0116)
+#   cmake_policy(SET CMP0116 OLD)
+# endif()


diff --git a/cmake/Modules/HandleCompilerRT.cmake b/cmake/Modules/HandleCompilerRT.cmake
index 6865f45175ed..ef802b87800d 100644
--- a/cmake/Modules/HandleCompilerRT.cmake
+++ b/cmake/Modules/HandleCompilerRT.cmake
@@ -70,19 +70,34 @@ function(find_compiler_rt_library name variable)
       list(APPEND clang_command "--target=${target}")
     endif()
     get_property(cxx_flags CACHE CMAKE_CXX_FLAGS PROPERTY VALUE)
+    message(WARNING "\${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
+    message(WARNING "\${cxx_flags} = ${cxx_flags}")
     string(REPLACE " " ";" cxx_flags "${cxx_flags}")
     list(APPEND clang_command ${cxx_flags})
     set(cmd_prefix "")
     if(MSVC AND ${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
       set(cmd_prefix "/clang:")
     endif()
+    message(WARNING "\${clang_command} = ${clang_command}")
+    if(PRINT_RTLIB_FILE_NAME)
+      set(print_rtlib_file_name "${cmd_prefix}-print-rtlib-file-name")
+    else()
+      set(print_rtlib_file_name "${cmd_prefix}-print-libgcc-file-name")
+    endif()
     execute_process(
-      COMMAND ${clang_command} "${cmd_prefix}--rtlib=compiler-rt" "${cmd_prefix}-print-libgcc-file-name"
+      COMMAND ${clang_command} "${cmd_prefix}--rtlib=compiler-rt" "${print_rtlib_file_name}"
       RESULT_VARIABLE had_error
       OUTPUT_VARIABLE library_file
     )
+    message(WARNING "${print_rtlib_file_name} \${had_error} = ${had_error}")
     string(STRIP "${library_file}" library_file)
     file(TO_CMAKE_PATH "${library_file}" library_file)
+    message(WARNING "\${library_file} = ${library_file}")
+    if(EXISTS "${library_file}")
+      message(STATUS "\${library_file} = ${library_file}")
+    else()
+      message(FATAL_ERROR "${library_file} does not exist")
+    endif()
     get_filename_component(dirname ${library_file} DIRECTORY)
     if(APPLE)
       execute_process(


diff --git a/compiler-rt/cmake/Modules/AddCompilerRT.cmake b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
index a72e279dd75e..bd792ca6236c 100644
--- a/compiler-rt/cmake/Modules/AddCompilerRT.cmake
+++ b/compiler-rt/cmake/Modules/AddCompilerRT.cmake
@@ -1,12 +1,13 @@
 include(ExternalProject)
 include(CompilerRTUtils)
 include(HandleCompilerRT)
+include(CompilerRTCompile)
 
 # CMP0114: ExternalProject step targets fully adopt their steps.
 # New in CMake 3.19: https://cmake.org/cmake/help/latest/policy/CMP0114.html
-if(POLICY CMP0114)
-  cmake_policy(SET CMP0114 OLD)
-endif()
+# if(POLICY CMP0114)
+#   cmake_policy(SET CMP0114 OLD)
+# endif()
 
 function(set_target_output_directories target output_dir)
   # For RUNTIME_OUTPUT_DIRECTORY variable, Multi-configuration generators
@@ -72,7 +73,9 @@ function(add_compiler_rt_object_libraries name)
   )
 
   foreach(libname ${libnames})
-    add_library(${libname} OBJECT ${LIB_SOURCES})
+    if(NOT TARGET ${libname})
+      add_library(${libname} OBJECT ${LIB_SOURCES})
+    endif()
     if(LIB_DEPS)
       add_dependencies(${libname} ${LIB_DEPS})
     endif()
@@ -169,6 +172,7 @@ endmacro()
 #                         PARENT_TARGET <convenience parent target>
 #                         ADDITIONAL_HEADERS <header files>)
 function(add_compiler_rt_runtime name type)
+  message(WARNING "\${name} = ${name}")
   if(NOT type MATCHES "^(OBJECT|STATIC|SHARED|MODULE)$")
     message(FATAL_ERROR
             "type argument must be OBJECT, STATIC, SHARED or MODULE")
@@ -273,6 +277,7 @@ function(add_compiler_rt_runtime name type)
           set_output_name(output_name_${libname} ${name} ${arch})
         endif()
       endif()
+      message(WARNING "\${libname} = ${libname}")
       if(COMPILER_RT_USE_BUILTINS_LIBRARY AND NOT type STREQUAL "OBJECT" AND
          NOT name STREQUAL "clang_rt.builtins")
         get_compiler_rt_target(${arch} target)
@@ -280,13 +285,24 @@ function(add_compiler_rt_runtime name type)
         if(builtins_${libname} STREQUAL "NOTFOUND")
           message(FATAL_ERROR "Cannot find builtins library for the target architecture")
         endif()
+      # else()
+      #   set(builtins_${libname} "clang_rt.builtins")
+      endif()
+      if(DEFINED builtins_${libname} AND NOT builtins_${libname} STREQUAL "" AND EXISTS "${builtins_${libname}}")
+        message(WARNING "\${builtins_${libname}} = ${builtins_${libname}}")
+      else()
+        if(DEFINED builtins_${libname} AND NOT builtins_${libname} STREQUAL "")
+          message(FATAL_ERROR "${builtins_${libname}} does not exist")
+        endif()
       endif()
       set(sources_${libname} ${LIB_SOURCES})
       format_object_libs(sources_${libname} ${arch} ${LIB_OBJECT_LIBS})
       set(libnames ${libnames} ${libname})
       set(extra_cflags_${libname} ${TARGET_${arch}_CFLAGS} ${NO_LTO_FLAGS} ${NO_PGO_FLAGS} ${LIB_CFLAGS})
       get_compiler_rt_output_dir(${arch} output_dir_${libname})
+      message(WARNING "\${output_dir_${libname}} = ${output_dir_${libname}}")
       get_compiler_rt_install_dir(${arch} install_dir_${libname})
+      message(WARNING "\${install_dir_${libname}} = ${install_dir_${libname}}")
     endforeach()
   endif()
 
@@ -354,7 +370,9 @@ function(add_compiler_rt_runtime name type)
         DESTINATION ${install_dir_${libname}}
         ${COMPONENT_OPTION})
     else()
-      add_library(${libname} ${type} ${sources_${libname}})
+      if(NOT TARGET ${libname})
+        add_library(${libname} ${type} ${sources_${libname}})
+      endif()
       set_target_compile_flags(${libname} ${extra_cflags_${libname}})
       set_target_link_flags(${libname} ${extra_link_flags_${libname}})
       set_property(TARGET ${libname} APPEND PROPERTY
@@ -670,6 +688,7 @@ macro(add_custom_libcxx name prefix)
     BINARY_DIR ${prefix}
     CMAKE_ARGS ${CMAKE_PASSTHROUGH_VARIABLES}
                ${compiler_args}
+               -DLLVM_TARGET_TRIPLE=${LLVM_TARGET_TRIPLE}
                -DCMAKE_C_FLAGS=${LIBCXX_C_FLAGS}
                -DCMAKE_CXX_FLAGS=${LIBCXX_CXX_FLAGS}
                -DCMAKE_BUILD_TYPE=Release


diff --git a/compiler-rt/cmake/Modules/CompilerRTUtils.cmake b/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
index 25e7823716fc..079b82c1a6ad 100644
--- a/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
+++ b/compiler-rt/cmake/Modules/CompilerRTUtils.cmake
@@ -169,7 +169,11 @@ macro(detect_target_arch)
   elseif(__AVR)
     add_default_target_arch(avr)
   elseif(__AARCH64)
-    add_default_target_arch(aarch64)
+    if(__AARCH_BIG_ENDIAN)
+        add_default_target_arch(aarch64_be)
+    else()
+        add_default_target_arch(aarch64)
+    endif()
   elseif(__X86_64)
     if(CMAKE_SIZEOF_VOID_P EQUAL "4")
       add_default_target_arch(x32)
@@ -300,7 +304,7 @@ macro(load_llvm_config)
       "You are not using the monorepo layout. This configuration is DEPRECATED.")
   endif()
 
-  find_package(LLVM HINTS "${LLVM_CMAKE_DIR}")
+  find_package(LLVM HINTS "${LLVM_CMAKE_DIR}" PATHS "${LLVM_DIR}")
   if (NOT LLVM_FOUND)
      message(WARNING "UNSUPPORTED COMPILER-RT CONFIGURATION DETECTED: "
                      "LLVM cmake package not found.\n"
@@ -354,20 +358,94 @@ macro(load_llvm_config)
 endmacro()
 
 macro(construct_compiler_rt_default_triple)
+  message(WARNING "Original \${TARGET_TRIPLE}: ${TARGET_TRIPLE}")
+  message(WARNING "Original \${LLVM_DEFAULT_TARGET_TRIPLE}: ${LLVM_DEFAULT_TARGET_TRIPLE}")
   if(COMPILER_RT_DEFAULT_TARGET_ONLY)
-    if(DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE)
+    message(WARNING "CompilerRTUtils: \${COMPILER_RT_DEFAULT_TARGET_ONLY} = ${COMPILER_RT_DEFAULT_TARGET_ONLY} was deduced somewhare")
+    if(DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE AND
+      NOT COMPILER_RT_DEFAULT_TARGET_TRIPLE STREQUAL "")
       message(FATAL_ERROR "COMPILER_RT_DEFAULT_TARGET_TRIPLE isn't supported when building for default target only")
     endif()
     if ("${CMAKE_C_COMPILER_TARGET}" STREQUAL "")
       message(FATAL_ERROR "CMAKE_C_COMPILER_TARGET must also be set when COMPILER_RT_DEFAULT_TARGET_ONLY is ON")
+    else()
+      message(WARNING "CompilerRTUtils: \${CMAKE_C_COMPILER_TARGET} = ${CMAKE_C_COMPILER_TARGET}")
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${CMAKE_C_COMPILER_TARGET} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
     endif()
-    message(STATUS "cmake c compiler target: ${CMAKE_C_COMPILER_TARGET}")
-    set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${CMAKE_C_COMPILER_TARGET})
   else()
-    set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_TARGET_TRIPLE} CACHE STRING
-          "Default triple for which compiler-rt runtimes will be built.")
+    message(WARNING "CompilerRTUtils: \${COMMON_CMAKE_ARGS} = ${COMMON_CMAKE_ARGS}")
+    message(WARNING "CompilerRTUtils: \${HAVE_LLVM_LIT} = ${HAVE_LLVM_LIT}")
+    message(WARNING "CompilerRTUtils: \${EXTRA_ARGS} = ${EXTRA_ARGS}")
+    message(WARNING "CompilerRTUtils: \${LLVM_BUILTIN_TARGETS} = ${LLVM_BUILTIN_TARGETS}")
+    message(WARNING "CompilerRTUtils: \${ARG_EXTRA_ARGS} = ${ARG_EXTRA_ARGS}")
+    message(WARNING "CompilerRTUtils: \${LLVM_TARGET_TRIPLE} = ${LLVM_TARGET_TRIPLE}")
+    message(WARNING "CompilerRTUtils: \${LLVM_DEFAULT_TARGET_TRIPLE} = ${LLVM_DEFAULT_TARGET_TRIPLE}")
+    message(WARNING "CompilerRTUtils: \${LLVM_RUNTIMES_TARGET} = ${LLVM_RUNTIMES_TARGET}")
+
+    if (DEFINED LLVM_DEFAULT_TARGET_TRIPLE)
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_DEFAULT_TARGET_TRIPLE} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    elseif (DEFINED LLVM_BUILTIN_TARGETS)
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_BUILTIN_TARGETS} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    elseif (DEFINED LLVM_RUNTIMES_TARGET)
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_RUNTIMES_TARGET} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    elseif (DEFINED LLVM_TARGET_TRIPLE)
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_TARGET_TRIPLE} CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    endif()
+
+    if (NOT DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE AND DEFINED ENV{LLVM_DEFAULT_TARGET_TRIPLE})
+      if (NOT DEFINED LLVM_DEFAULT_TARGET_TRIPLE)
+        set(LLVM_DEFAULT_TARGET_TRIPLE "$ENV{LLVM_DEFAULT_TARGET_TRIPLE}" CACHE STRING "Some gaps exist" FORCE)
+      endif()
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE "$ENV{LLVM_DEFAULT_TARGET_TRIPLE}" CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    endif()
+
+    if (NOT DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE AND DEFINED ENV{LLVM_TARGET_TRIPLE})
+      if (NOT DEFINED LLVM_TARGET_TRIPLE)
+        set(LLVM_TARGET_TRIPLE "$ENV{LLVM_TARGET_TRIPLE}" CACHE STRING "Some gaps exist" FORCE)
+      endif()
+      set(COMPILER_RT_DEFAULT_TARGET_TRIPLE "$ENV{LLVM_TARGET_TRIPLE}" CACHE STRING
+        "Default triple for which compiler-rt runtimes will be built." FORCE)
+    endif()
+
+    if (NOT DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE)
+      if(NOT DEFINED LLVM_TARGET_TRIPLE OR "${LLVM_TARGET_TRIPLE}" STREQUAL "")
+        load_llvm_config()
+        get_property(LLVM_TARGET_TRIPLE GLOBAL PROPERTY LLVM_TARGET_TRIPLE)
+        message(WARNING "CompilerRTUtils: \$ENV{KISS_XHOST_TRIPLE} = $ENV{KISS_XHOST_TRIPLE}")
+        message(WARNING "CompilerRTUtils: \$ENV{LLVM_TARGET_TRIPLE} = $ENV{LLVM_TARGET_TRIPLE}")
+        message(WARNING "CompilerRTUtils: \${COMMON_CMAKE_ARGS} = ${COMMON_CMAKE_ARGS}")
+        message(WARNING "CompilerRTUtils: \${HAVE_LLVM_LIT} = ${HAVE_LLVM_LIT}")
+        message(WARNING "CompilerRTUtils: \${EXTRA_ARGS} = ${EXTRA_ARGS}")
+        message(WARNING "CompilerRTUtils: \${LLVM_BUILTIN_TARGETS} = ${LLVM_BUILTIN_TARGETS}")
+        message(WARNING "CompilerRTUtils: \${ARG_EXTRA_ARGS} = ${ARG_EXTRA_ARGS}")
+        message(WARNING "CompilerRTUtils: \${LLVM_TARGET_TRIPLE} = ${LLVM_TARGET_TRIPLE}")
+        message(WARNING "CompilerRTUtils: \${LLVM_DEFAULT_TARGET_TRIPLE} = ${LLVM_DEFAULT_TARGET_TRIPLE}")
+        message(WARNING "CompilerRTUtils: \${LLVM_RUNTIMES_TARGET} = ${LLVM_RUNTIMES_TARGET}")
+        if ("${LLVM_TARGET_TRIPLE}" STREQUAL "")
+          message(FATAL_ERROR "LLVM_TARGET_TRIPLE must also be set when COMPILER_RT_DEFAULT_TARGET_ONLY is OFF")
+        endif()
+      endif()
+      if (${LLVM_TARGET_TRIPLE} STREQUAL "$ENV{LLVM_TARGET_TRIPLE}")
+        set(COMPILER_RT_DEFAULT_TARGET_TRIPLE ${LLVM_TARGET_TRIPLE} CACHE STRING
+          "Default triple for which compiler-rt runtimes will be built." FORCE)
+      else()
+        set(LLVM_TARGET_TRIPLE "$ENV{LLVM_TARGET_TRIPLE}" CACHE STRING "Some gaps exist" FORCE)
+        set(COMPILER_RT_DEFAULT_TARGET_TRIPLE "$ENV{LLVM_TARGET_TRIPLE}" CACHE STRING
+          "Default triple for which compiler-rt runtimes will be built." FORCE)
+      endif()
+    endif()
+
+    message(WARNING "CompilerRTUtils: \${LLVM_TARGET_TRIPLE} = ${LLVM_TARGET_TRIPLE}")
   endif()
 
+  message(WARNING "CompilerRTUtils: Final \${COMPILER_RT_DEFAULT_TARGET_TRIPLE} = ${COMPILER_RT_DEFAULT_TARGET_TRIPLE}")
+
   string(REPLACE "-" ";" LLVM_TARGET_TRIPLE_LIST ${COMPILER_RT_DEFAULT_TARGET_TRIPLE})
   list(GET LLVM_TARGET_TRIPLE_LIST 0 COMPILER_RT_DEFAULT_TARGET_ARCH)
 
@@ -414,6 +492,10 @@ function(filter_builtin_sources inout_var name)
 endfunction()
 
 function(get_compiler_rt_target arch variable)
+  if (NOT DEFINED COMPILER_RT_DEFAULT_TARGET_TRIPLE OR
+      COMPILER_RT_DEFAULT_TARGET_TRIPLE STREQUAL "")
+    construct_compiler_rt_default_triple()
+  endif()
   string(FIND ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} "-" dash_index)
   string(SUBSTRING ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} ${dash_index} -1 triple_suffix)
   string(SUBSTRING ${COMPILER_RT_DEFAULT_TARGET_TRIPLE} 0 ${dash_index} triple_cpu)
@@ -546,17 +628,21 @@ function(add_compiler_rt_install_targets name)
   # We only want to generate per-library install targets if you aren't using
   # an IDE because the extra targets get cluttered in IDEs.
   if(NOT CMAKE_CONFIGURATION_TYPES)
-    add_custom_target(install-${name}
-                      DEPENDS ${name}
-                      COMMAND "${CMAKE_COMMAND}"
-                              -DCMAKE_INSTALL_COMPONENT=${name}
-                              -P "${CMAKE_BINARY_DIR}/cmake_install.cmake")
-    add_custom_target(install-${name}-stripped
-                      DEPENDS ${name}
-                      COMMAND "${CMAKE_COMMAND}"
-                              -DCMAKE_INSTALL_COMPONENT=${name}
-                              -DCMAKE_INSTALL_DO_STRIP=1
-                              -P "${CMAKE_BINARY_DIR}/cmake_install.cmake")
+    if ( NOT TARGET install-${name} )
+      add_custom_target(install-${name}
+        DEPENDS ${name}
+        COMMAND "${CMAKE_COMMAND}"
+        -DCMAKE_INSTALL_COMPONENT=${name}
+        -P "${CMAKE_BINARY_DIR}/cmake_install.cmake")
+    endif()
+    if ( NOT TARGET install-${name}-stripped )
+      add_custom_target(install-${name}-stripped
+        DEPENDS ${name}
+        COMMAND "${CMAKE_COMMAND}"
+        -DCMAKE_INSTALL_COMPONENT=${name}
+        -DCMAKE_INSTALL_DO_STRIP=1
+        -P "${CMAKE_BINARY_DIR}/cmake_install.cmake")
+    endif()
     # If you have a parent target specified, we bind the new install target
     # to the parent install target.
     if(LIB_PARENT_TARGET)


diff --git a/llvm/cmake/modules/HandleLLVMOptions.cmake b/llvm/cmake/modules/HandleLLVMOptions.cmake
index 19d6c58d991b..1cb244be4e7e 100644
--- a/llvm/cmake/modules/HandleLLVMOptions.cmake
+++ b/llvm/cmake/modules/HandleLLVMOptions.cmake
@@ -318,7 +318,6 @@ if( LLVM_ENABLE_LLD )
       set(CMAKE_LINKER ${LLD_LINK})
     endif()
   else()
-    set(LLVM_USE_LINKER "lld")
   endif()
 endif()
 
@@ -1126,7 +1125,7 @@ endif()
 # linker directly, it isn't sufficient to pass -fsanitize=* to the linker.
 if (CLANG_CL AND (LLVM_BUILD_INSTRUMENTED OR LLVM_USE_SANITIZER))
   execute_process(
-    COMMAND ${CMAKE_CXX_COMPILER} /clang:-print-libgcc-file-name /clang:--rtlib=compiler-rt
+    COMMAND ${CMAKE_CXX_COMPILER} /clang:-print-rtlib-file-name /clang:--rtlib=compiler-rt
     OUTPUT_VARIABLE clang_compiler_rt_file
     ERROR_VARIABLE clang_cl_stderr
     OUTPUT_STRIP_TRAILING_WHITESPACE


# --- ./llvm/cmake/modules/HandleLLVMOptions.cmake
# +++ ./llvm/cmake/modules/HandleLLVMOptions.cmake
# @@ -313,12 +313,51 @@
#  endif()
# 
#  if( LLVM_USE_LINKER )
# -  append("-fuse-ld=${LLVM_USE_LINKER}"
# -    CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)
# -  check_cxx_source_compiles("int main() { return 0; }" CXX_SUPPORTS_CUSTOM_LINKER)
# -  if ( NOT CXX_SUPPORTS_CUSTOM_LINKER )
# -    message(FATAL_ERROR "Host compiler does not support '-fuse-ld=${LLVM_USE_LINKER}'")
# -  endif()
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +    set(cl_cache "${CMAKE_C_LINKER_FLAGS}")
# +    set(cxxl_cache "${CMAKE_CXX_LINKER_FLAGS}")
# +    set(el_cache "${CMAKE_EXE_LINKER_FLAGS}")
# +    set(ml_cache "${CMAKE_MODULE_LINKER_FLAGS}")
# +    set(sl_cache "${CMAKE_SHARED_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_EXE_LINKER_FLAGS} = ${CMAKE_EXE_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_C_LINKER_FLAGS} = ${CMAKE_C_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_CXX_LINKER_FLAGS} = ${CMAKE_CXX_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_MODULE_LINKER_FLAGS} = ${CMAKE_MODULE_LINKER_FLAGS}")
# +    message(STATUS "llvm/cmake/modules/HandleLLVMOptions.cmake \${CMAKE_SHARED_LINKER_FLAGS} = ${CMAKE_SHARED_LINKER_FLAGS}")
# +    set(CMAKE_C_LINKER_FLAGS "")
# +    set(CMAKE_CXX_LINKER_FLAGS "")
# +    set(CMAKE_EXE_LINKER_FLAGS "")
# +    set(CMAKE_MODULE_LINKER_FLAGS "")
# +    set(CMAKE_SHARED_LINKER_FLAGS "")
# +    append("-fuse-ld=${LLVM_USE_LINKER}"
# +        CMAKE_EXE_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS)
# +
# +    set(CMAKE_LINKER "$ENV{ORIGIN}/lld" CACHE FILEPATH "")
# +    set(CMAKE_LINK_EXECUTABLE "$ENV{ORIGIN}/lld" CACHE FILEPATH "")
# +    message(STATUS "\${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +    message(STATUS "\${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +    set(cxx_cache "${CMAKE_CXX_FLAGS}")
# +    set(c_cache "${CMAKE_C_FLAGS}")
# +    set(CMAKE_CXX_FLAGS "")
# +    check_cxx_source_compiles("int main() { return 0; }" CXX_SUPPORTS_CUSTOM_LINKER)
# +    set(CMAKE_CXX_FLAGS "${cxx_cache}")
# +    unset(cxx_cache CACHE)
# +    set(CMAKE_C_FLAGS "${c_cache}")
# +    unset(c_cache CACHE)
# +    set(CMAKE_C_LINKER_FLAGS "${cl_cache}")
# +    unset(cl_cache CACHE)
# +    set(CMAKE_CXX_LINKER_FLAGS "${cxxl_cache}")
# +    unset(cxxl_cache CACHE)
# +    set(CMAKE_EXE_LINKER_FLAGS "${el_cache}")
# +    unset(el_cache CACHE)
# +    set(CMAKE_MODULE_LINKER_FLAGS "${ml_cache}")
# +    unset(ml_cache CACHE)
# +    set(CMAKE_SHARED_LINKER_FLAGS "${sl_cache}")
# +    unset(sl_cache CACHE)
# +    if ( NOT CXX_SUPPORTS_CUSTOM_LINKER )
# +        message(FATAL_ERROR "Host compiler does not support '-fuse-ld=${LLVM_USE_LINKER}'")
# +    endif()
#  endif()
# 
#  if( LLVM_ENABLE_PIC )

# @@ -69,6 +69,8 @@
#  # This variable is used by individual runtimes to locate LLVM files.
#  set(LLVM_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../llvm)
# 
# +set(CMAKE_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +
#  include(CheckLibraryExists)
#  include(LLVMCheckCompilerLinkerFlag)
#  include(CheckCCompilerFlag)
# @@ -132,15 +134,17 @@
#  # Check for -nostdlib++ first; if there's no C++ standard library yet,
#  # all check_cxx_compiler_flag commands will fail until we add -nostdlib++
#  # (or -nodefaultlibs).
# -llvm_check_compiler_linker_flag(C "-nostdlib++" CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# -if (CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# +# llvm_check_compiler_linker_flag(C "-nostdlib++" CXX_SUPPORTS_NOSTDLIBXX_FLAG)
# +# if (CXX_SUPPORTS_NOSTDLIBXX_FLAG)
#    set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdlib++")
# -endif()
# -check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# -  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# -endif()
# +# endif()
# +# check_cxx_compiler_flag(-nostdinc++ CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +# if (CXX_SUPPORTS_NOSTDINCXX_FLAG)
# +#  set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} -nostdinc++")
# +# endif()
# 
# +set(CMAKE_REQUIRED_FLAGS "${CMAKE_REQUIRED_FLAGS} --sysroot=${KISS_ROOT}")
# +
#  # Avoid checking whether the compiler is working.
#  set(LLVM_COMPILER_CHECKED ON)
# 
# @@ -156,8 +160,8 @@
#  set(LLVM_DEFAULT_TARGET_TRIPLE "${LLVM_HOST_TRIPLE}" CACHE STRING
#    "Default target for which the runtimes will be built.")
# 
# -option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." ON)
# -option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." ON)
# +option(LLVM_INCLUDE_TESTS "Generate build targets for the runtimes unit tests." OFF)
# +option(LLVM_INCLUDE_DOCS "Generate build targets for the runtimes documentation." OFF)
#  option(LLVM_ENABLE_SPHINX "Use Sphinx to generate the runtimes documentation." OFF)
# 
#  # Use libtool instead of ar if you are both on an Apple host, and targeting Apple.

# --- ./lldb/utils/TableGen/CMakeLists.txt
# +++ ./lldb/utils/TableGen/CMakeLists.txt
# @@ -1,6 +1,9 @@
#  # tablegen targets get exported via llvm for LLVMConfig.cmake. So standalone
#  # builds of lldb can potentially import this via LLVMConfig and also attempt to
#  # build it in tree. So only build it if it doesn't exist.
# +
# +set(CMAKE_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# +
#  if (NOT DEFINED LLDB_TABLEGEN_EXE)
#    if (TARGET lldb-tblgen)
#      set(LLDB_TABLEGEN_EXE $<TARGET_FILE:lldb-tblgen> CACHE STRING "")

# # diff --git a/libcxxabi/CMakeLists.txt b/libcxxabi/CMakeLists.txt
# # index 1400233b7..0a7b38737 100644
# --- a/libcxxabi/CMakeLists.txt
# +++ b/libcxxabi/CMakeLists.txt
# @@ -47,7 +47,7 @@
#  option(LIBCXXABI_ENABLE_WERROR "Fail and stop if a warning is triggered." OFF)
# -option(LIBCXXABI_USE_LLVM_UNWINDER "Build and use the LLVM unwinder." OFF)
# +option(LIBCXXABI_USE_LLVM_UNWINDER "Build and use the LLVM unwinder." ON)
#  option(LIBCXXABI_ENABLE_STATIC_UNWINDER "Statically link the LLVM unwinder." OFF)
# -option(LIBCXXABI_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
# +option(LIBCXXABI_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
#  option(LIBCXXABI_ENABLE_THREADS "Build with threads enabled" ON)
#  option(LIBCXXABI_HAS_PTHREAD_API "Ignore auto-detection and force use of pthread API" OFF)
#  option(LIBCXXABI_HAS_WIN32_THREAD_API "Ignore auto-detection and force use of win32 thread API" OFF)
# @@ -465,6 +465,11 @@
# 
#  string(REPLACE ";" " " LIBCXXABI_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
#  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${LIBCXXABI_CXX_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -isystem /usr/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +${CMAKE_CXX_FLAGS}")
#  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${LIBCXXABI_C_FLAGS}")
# 
#  # On AIX, avoid picking up VMX extensions(i.e. vec_malloc) which would change
# 
# # @@ -224,7 +224,7 @@
# #  # LIBCXXABI_LIBRARIES: libraries libc++abi is linked to.
# # 
# #  set(LIBCXXABI_C_FLAGS "")
# # -set(LIBCXXABI_CXX_FLAGS "")
# # +set(LIBCXXABI_CXX_FLAGS "-isystem /usr/include/c++/v1 ${CMAKE_CXX_FLAGS}")
# #  set(LIBCXXABI_COMPILE_FLAGS "")
# #  set(LIBCXXABI_LINK_FLAGS "")
# #  set(LIBCXXABI_LIBRARIES "")
# # @@ -455,7 +455,7 @@
# #  endif()
# # 
# #  string(REPLACE ";" " " LIBCXXABI_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
# # -set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${LIBCXXABI_CXX_FLAGS}")
# # +set(CMAKE_CXX_FLAGS "${LIBCXXABI_CXX_FLAGS}")
# #  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${LIBCXXABI_C_FLAGS}")
# # 
# #  # On AIX, avoid picking up VMX extensions(i.e. vec_malloc) which would change


# diff --git a/libunwind/src/CMakeLists.txt b/libunwind/src/CMakeLists.txt
# index e5897fedd212..0ec7b99aebdb 100644
# --- a/libunwind/src/CMakeLists.txt
# +++ b/libunwind/src/CMakeLists.txt
# @@ -17,9 +17,13 @@ set(LIBUNWIND_C_SOURCES
#      UnwindLevel1-gcc-ext.c
#      Unwind-sjlj.c
#      )
# +
# +set_source_files_properties(${LIBUNWIND_C_SOURCES}
# +  PROPERTIES
# +  COMPILE_FLAGS "-std=c99")
#  set_source_files_properties(${LIBUNWIND_C_SOURCES}
# -                            PROPERTIES
# -                              COMPILE_FLAGS "-std=c99")
# +  PROPERTIES
# +  COMPILE_FLAGS "-fPIC")
#  
#  set(LIBUNWIND_ASM_SOURCES
#      UnwindRegistersRestore.S
# @@ -121,6 +125,8 @@ set_property(SOURCE ${LIBUNWIND_C_SOURCES}
#  # ease, but does not rely on C++ at runtime.
#  set(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "")
#  
# +add_compile_options (-fPIC)
# +
#  include(WarningFlags)
#  
#  # Build the shared library.
# @@ -137,12 +143,13 @@ target_link_libraries(unwind_shared_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRA
#  set_target_properties(unwind_shared_objects
#    PROPERTIES
#      CXX_EXTENSIONS OFF
# -    CXX_STANDARD 11
# +    CXX_STANDARD 23
#      CXX_STANDARD_REQUIRED ON
#      COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
#  )
#  if (CMAKE_POSITION_INDEPENDENT_CODE OR NOT DEFINED CMAKE_POSITION_INDEPENDENT_CODE)
#    set_target_properties(unwind_shared_objects PROPERTIES POSITION_INDEPENDENT_CODE ON) # must set manually because it's an object library
# +  set_property(TARGET unwind_shared_objects APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
#  endif()
#  
#  if (LIBUNWIND_ENABLE_SHARED)
# @@ -157,6 +164,8 @@ if (LIBUNWIND_ENABLE_SHARED)
#        SOVERSION "1"
#    )
#  
# +  set_property(TARGET unwind_shared APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +
#    list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_shared")
#    if (LIBUNWIND_INSTALL_SHARED_LIBRARY)
#      list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_shared")
# @@ -177,12 +186,20 @@ target_link_libraries(unwind_static_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRA
#  set_target_properties(unwind_static_objects
#    PROPERTIES
#      CXX_EXTENSIONS OFF
# -    CXX_STANDARD 11
# +    CXX_STANDARD 23
#      CXX_STANDARD_REQUIRED ON
#      COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
#  )
#  
# +if (CMAKE_POSITION_INDEPENDENT_CODE OR NOT DEFINED CMAKE_POSITION_INDEPENDENT_CODE)
# +  set_target_properties(unwind_static_objects PROPERTIES POSITION_INDEPENDENT_CODE ON) # must set manually because it's an object library
# +  set_property(TARGET unwind_static_objects APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +endif()
# +
#  if(LIBUNWIND_HIDE_SYMBOLS)
# +  if (NOT WIN32)
# +    message(WARNING "Should not see this on non-win32 \${LIBUNWIND_HIDE_SYMBOLS} = ${LIBUNWIND_HIDE_SYMBOLS}")
# +  endif()
#    target_add_compile_flags_if_supported(unwind_static_objects PRIVATE -fvisibility=hidden)
#    target_add_compile_flags_if_supported(unwind_static_objects PRIVATE -fvisibility-global-new-delete-hidden)
#    target_compile_definitions(unwind_static_objects PRIVATE _LIBUNWIND_HIDE_SYMBOLS)
# @@ -198,6 +215,8 @@ if (LIBUNWIND_ENABLE_STATIC)
#        OUTPUT_NAME "${LIBUNWIND_STATIC_OUTPUT_NAME}"
#    )
#  
# +  set_property(TARGET unwind_static APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +
#    list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_static")
#    if (LIBUNWIND_INSTALL_STATIC_LIBRARY)
#      list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_static")


diff --git a/libunwind/src/CMakeLists.txt b/libunwind/src/CMakeLists.txt
index e5897fedd212..f5f4fff3da52 100644
--- a/libunwind/src/CMakeLists.txt
+++ b/libunwind/src/CMakeLists.txt
@@ -17,9 +17,13 @@ set(LIBUNWIND_C_SOURCES
     UnwindLevel1-gcc-ext.c
     Unwind-sjlj.c
     )
+
+set_source_files_properties(${LIBUNWIND_C_SOURCES}
+  PROPERTIES
+  COMPILE_FLAGS "-std=c99")
 set_source_files_properties(${LIBUNWIND_C_SOURCES}
-                            PROPERTIES
-                              COMPILE_FLAGS "-std=c99")
+  PROPERTIES
+  COMPILE_FLAGS "-fPIC")
 
 set(LIBUNWIND_ASM_SOURCES
     UnwindRegistersRestore.S
@@ -112,6 +116,17 @@ string(REPLACE ";" " " LIBUNWIND_CXX_FLAGS "${LIBUNWIND_CXX_FLAGS}")
 string(REPLACE ";" " " LIBUNWIND_C_FLAGS "${LIBUNWIND_C_FLAGS}")
 string(REPLACE ";" " " LIBUNWIND_LINK_FLAGS "${LIBUNWIND_LINK_FLAGS}")
 
+foreach(link_flag LIBUNWIND_LINK_FLAGS CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS)
+  if(NOT "${link_flag}" STREQUAL "")
+    string(REGEX REPLACE "^--unwindlib=libunwind$" "--unwindlib=none" ${link_flag} "${${link_flag}}")
+    string(REGEX REPLACE "^-Wl,-lunwind$" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++experimental" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++abi" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++" "" ${link_flag} "${${link_flag}}")
+    set(${link_flag} " -lc++experimental ${${link_flag}}")
+  endif()
+endforeach()
+
 set_property(SOURCE ${LIBUNWIND_CXX_SOURCES}
              APPEND_STRING PROPERTY COMPILE_FLAGS " ${LIBUNWIND_CXX_FLAGS}")
 set_property(SOURCE ${LIBUNWIND_C_SOURCES}
@@ -121,6 +136,8 @@ set_property(SOURCE ${LIBUNWIND_C_SOURCES}
 # ease, but does not rely on C++ at runtime.
 set(CMAKE_CXX_IMPLICIT_LINK_LIBRARIES "")
 
+add_compile_options (-fPIC)
+
 include(WarningFlags)
 
 # Build the shared library.
@@ -137,12 +154,13 @@ target_link_libraries(unwind_shared_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRA
 set_target_properties(unwind_shared_objects
   PROPERTIES
     CXX_EXTENSIONS OFF
-    CXX_STANDARD 11
+    CXX_STANDARD 23
     CXX_STANDARD_REQUIRED ON
     COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
 )
 if (CMAKE_POSITION_INDEPENDENT_CODE OR NOT DEFINED CMAKE_POSITION_INDEPENDENT_CODE)
   set_target_properties(unwind_shared_objects PROPERTIES POSITION_INDEPENDENT_CODE ON) # must set manually because it's an object library
+  set_property(TARGET unwind_shared_objects APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
 endif()
 
 if (LIBUNWIND_ENABLE_SHARED)
@@ -157,6 +175,25 @@ if (LIBUNWIND_ENABLE_SHARED)
       SOVERSION "1"
   )
 
+  set_property(TARGET unwind_shared APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+
+  get_target_property(link_options unwind_shared LINK_OPTIONS)
+  if(NOT "${link_options}" STREQUAL "link_options-NOTFOUND")
+    message(WARNING "Original value of \${link_options}: ${link_options}")
+    list(REMOVE_ITEM link_options "--unwindlib=libunwind")
+    list(REMOVE_ITEM link_options "-Wl,-lunwind")
+    list(REMOVE_ITEM link_options "-lc++")
+    list(REMOVE_ITEM link_options "-lc++abi")
+    string(REGEX MATCH "--unwindlib=none" unwindlibnone_found ${link_options})
+    if(NOT unwindlibnone_found)
+      list(APPEND link_options "--unwindlib=none")
+    endif()
+    message(WARNING "Modified value of \${link_options}: ${link_options}")
+    set_target_properties(unwind_shared PROPERTIES LINK_OPTIONS "${link_options}")
+    get_target_property(link_options unwind_shared LINK_OPTIONS)
+    message(WARNING "Written-back value of \${link_options}: ${link_options}")
+  endif()
+
   list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_shared")
   if (LIBUNWIND_INSTALL_SHARED_LIBRARY)
     list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_shared")
@@ -177,12 +214,20 @@ target_link_libraries(unwind_static_objects PUBLIC "${LIBUNWIND_ADDITIONAL_LIBRA
 set_target_properties(unwind_static_objects
   PROPERTIES
     CXX_EXTENSIONS OFF
-    CXX_STANDARD 11
+    CXX_STANDARD 23
     CXX_STANDARD_REQUIRED ON
     COMPILE_FLAGS "${LIBUNWIND_COMPILE_FLAGS}"
 )
 
+if (CMAKE_POSITION_INDEPENDENT_CODE OR NOT DEFINED CMAKE_POSITION_INDEPENDENT_CODE)
+  set_target_properties(unwind_static_objects PROPERTIES POSITION_INDEPENDENT_CODE ON) # must set manually because it's an object library
+  set_property(TARGET unwind_static_objects APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+endif()
+
 if(LIBUNWIND_HIDE_SYMBOLS)
+  if (NOT WIN32)
+    message(WARNING "Should not see this on non-win32 \${LIBUNWIND_HIDE_SYMBOLS} = ${LIBUNWIND_HIDE_SYMBOLS}")
+  endif()
   target_add_compile_flags_if_supported(unwind_static_objects PRIVATE -fvisibility=hidden)
   target_add_compile_flags_if_supported(unwind_static_objects PRIVATE -fvisibility-global-new-delete-hidden)
   target_compile_definitions(unwind_static_objects PRIVATE _LIBUNWIND_HIDE_SYMBOLS)
@@ -198,6 +243,25 @@ if (LIBUNWIND_ENABLE_STATIC)
       OUTPUT_NAME "${LIBUNWIND_STATIC_OUTPUT_NAME}"
   )
 
+  set_property(TARGET unwind_static APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+
+  get_target_property(link_options unwind_static LINK_OPTIONS)
+  if(NOT "${link_options}" STREQUAL "link_options-NOTFOUND")
+    message(WARNING "Original value of \${link_options}: ${link_options}")
+    list(REMOVE_ITEM link_options "--unwindlib=libunwind")
+    list(REMOVE_ITEM link_options "-Wl,-lunwind")
+    list(REMOVE_ITEM link_options "-lc++")
+    list(REMOVE_ITEM link_options "-lc++abi")
+    string(REGEX MATCH "--unwindlib=none" unwindlibnone_found ${link_options})
+    if(NOT unwindlibnone_found)
+      list(APPEND link_options "--unwindlib=none")
+    endif()
+    message(WARNING "Modified value of \${link_options}: ${link_options}")
+    set_target_properties(unwind_static PROPERTIES LINK_OPTIONS "${link_options}")
+    get_target_property(link_options unwind_static LINK_OPTIONS)
+    message(WARNING "Written-back value of \${link_options}: ${link_options}")
+  endif()
+
   list(APPEND LIBUNWIND_BUILD_TARGETS "unwind_static")
   if (LIBUNWIND_INSTALL_STATIC_LIBRARY)
     list(APPEND LIBUNWIND_INSTALL_TARGETS "unwind_static")


# diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
# index 660bbadb2..82d9f02f2 100644
# --- a/libunwind/CMakeLists.txt
# +++ b/libunwind/CMakeLists.txt
# @@ -182,7 +182,7 @@ set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIBUNWIND_LIBRARY_DIR})
# 
#  set(LIBUNWIND_C_FLAGS "")
#  set(LIBUNWIND_CXX_FLAGS "")
# -set(LIBUNWIND_COMPILE_FLAGS "")
# +set(LIBUNWIND_COMPILE_FLAGS "$ENV{KISS_LIBUNWIND_FLAGS}")
#  set(LIBUNWIND_LINK_FLAGS "")
# 
#  # Include macros for adding and removing libunwind flags.


# diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
# index bc2a820fe98e..13fb13c88887 100644
# --- a/libunwind/CMakeLists.txt
# +++ b/libunwind/CMakeLists.txt
# @@ -44,7 +44,7 @@ option(LIBUNWIND_ENABLE_CROSS_UNWINDING "Enable cross-platform unwinding support
#  option(LIBUNWIND_ENABLE_ARM_WMMX "Enable unwinding support for ARM WMMX registers." OFF)
#  option(LIBUNWIND_ENABLE_THREADS "Build libunwind with threading support." ON)
#  option(LIBUNWIND_WEAK_PTHREAD_LIB "Use weak references to refer to pthread functions." OFF)
# -option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
# +option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
#  option(LIBUNWIND_INCLUDE_DOCS "Build the libunwind documentation." ${LLVM_INCLUDE_DOCS})
#  option(LIBUNWIND_INCLUDE_TESTS "Build the libunwind tests." ${LLVM_INCLUDE_TESTS})
#  option(LIBUNWIND_IS_BAREMETAL "Build libunwind for baremetal targets." OFF)
# @@ -139,15 +139,26 @@ set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBUNWIND_LIBRARY_DIR})
#  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBUNWIND_LIBRARY_DIR})
#  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIBUNWIND_LIBRARY_DIR})
#  
# -set(LIBUNWIND_C_FLAGS "")
# -set(LIBUNWIND_CXX_FLAGS "")
# -set(LIBUNWIND_COMPILE_FLAGS "")
# -set(LIBUNWIND_LINK_FLAGS "")
# -set(LIBUNWIND_ADDITIONAL_COMPILE_FLAGS "" CACHE STRING
# +set(LIBUNWIND_C_FLAGS "" CACHE STRING "")
# +set(LIBUNWIND_CXX_FLAGS "" CACHE STRING "")
# +set(LIBUNWIND_COMPILE_FLAGS "" CACHE STRING "")
# +set(LIBUNWIND_LINK_FLAGS "" CACHE STRING "")
# +set(LIBUNWIND_ADDITIONAL_COMPILE_FLAGS "$ENV{LIBUNWIND_ADDITIONAL_COMPILE_FLAGS}" CACHE STRING
#      "Additional Compile only flags which can be provided in cache")
#  set(LIBUNWIND_ADDITIONAL_LIBRARIES "" CACHE STRING
#      "Additional libraries libunwind is linked to which can be provided in cache")
#  
# +# set_property(TARGET libunwind APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +STRING( FIND "${CMAKE_C_FLAGS}" "-fPIC" PIC_INDEX )
# +if("${PIC_INDEX}" STREQUAL "-1" )
# +  set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
# +endif()
# +STRING( FIND "${CMAKE_CXX_FLAGS}" "-fPIC" PIC_INDEX )
# +if("${PIC_INDEX}" STREQUAL "-1" )
# +  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
# +endif()
# +add_compile_options (-fPIC)
# +
#  # Include macros for adding and removing libunwind flags.
#  include(HandleLibunwindFlags)
#  
# @@ -302,6 +313,6 @@ if (LIBUNWIND_INCLUDE_DOCS)
#    add_subdirectory(docs)
#  endif()
#  
# -if (LIBUNWIND_INCLUDE_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
# +if (LIBUNWIND_INCLUDE_TESTS AND LLVM_BUILD_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
#    add_subdirectory(test)
#  endif()


# diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
# index bc2a820fe98e..f75241fe5c0f 100644
# --- a/libunwind/CMakeLists.txt
# +++ b/libunwind/CMakeLists.txt
# @@ -44,7 +44,7 @@ option(LIBUNWIND_ENABLE_CROSS_UNWINDING "Enable cross-platform unwinding support
#  option(LIBUNWIND_ENABLE_ARM_WMMX "Enable unwinding support for ARM WMMX registers." OFF)
#  option(LIBUNWIND_ENABLE_THREADS "Build libunwind with threading support." ON)
#  option(LIBUNWIND_WEAK_PTHREAD_LIB "Use weak references to refer to pthread functions." OFF)
# -option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
# +option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
#  option(LIBUNWIND_INCLUDE_DOCS "Build the libunwind documentation." ${LLVM_INCLUDE_DOCS})
#  option(LIBUNWIND_INCLUDE_TESTS "Build the libunwind tests." ${LLVM_INCLUDE_TESTS})
#  option(LIBUNWIND_IS_BAREMETAL "Build libunwind for baremetal targets." OFF)
# @@ -148,6 +148,17 @@ set(LIBUNWIND_ADDITIONAL_COMPILE_FLAGS "" CACHE STRING
#  set(LIBUNWIND_ADDITIONAL_LIBRARIES "" CACHE STRING
#      "Additional libraries libunwind is linked to which can be provided in cache")
#  
# +# set_property(TARGET libunwind APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +STRING( FIND "${CMAKE_C_FLAGS}" "-fPIC" PIC_INDEX )
# +if("${PIC_INDEX}" STREQUAL "-1" )
# +  set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
# +endif()
# +STRING( FIND "${CMAKE_CXX_FLAGS}" "-fPIC" PIC_INDEX )
# +if("${PIC_INDEX}" STREQUAL "-1" )
# +  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
# +endif()
# +add_compile_options (-fPIC)
# +
#  # Include macros for adding and removing libunwind flags.
#  include(HandleLibunwindFlags)
#  
# @@ -302,6 +313,6 @@ if (LIBUNWIND_INCLUDE_DOCS)
#    add_subdirectory(docs)
#  endif()
#  
# -if (LIBUNWIND_INCLUDE_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
# +if (LIBUNWIND_INCLUDE_TESTS AND LLVM_BUILD_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
#    add_subdirectory(test)
#  endif()


diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
index bc2a820fe98e..c832c64cef00 100644
--- a/libunwind/CMakeLists.txt
+++ b/libunwind/CMakeLists.txt
@@ -44,7 +44,7 @@ option(LIBUNWIND_ENABLE_CROSS_UNWINDING "Enable cross-platform unwinding support
 option(LIBUNWIND_ENABLE_ARM_WMMX "Enable unwinding support for ARM WMMX registers." OFF)
 option(LIBUNWIND_ENABLE_THREADS "Build libunwind with threading support." ON)
 option(LIBUNWIND_WEAK_PTHREAD_LIB "Use weak references to refer to pthread functions." OFF)
-option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" OFF)
+option(LIBUNWIND_USE_COMPILER_RT "Use compiler-rt instead of libgcc" ON)
 option(LIBUNWIND_INCLUDE_DOCS "Build the libunwind documentation." ${LLVM_INCLUDE_DOCS})
 option(LIBUNWIND_INCLUDE_TESTS "Build the libunwind tests." ${LLVM_INCLUDE_TESTS})
 option(LIBUNWIND_IS_BAREMETAL "Build libunwind for baremetal targets." OFF)
@@ -148,9 +148,31 @@ set(LIBUNWIND_ADDITIONAL_COMPILE_FLAGS "" CACHE STRING
 set(LIBUNWIND_ADDITIONAL_LIBRARIES "" CACHE STRING
     "Additional libraries libunwind is linked to which can be provided in cache")
 
+# set_property(TARGET libunwind APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+STRING( FIND "${CMAKE_C_FLAGS}" "-fPIC" PIC_INDEX )
+if("${PIC_INDEX}" STREQUAL "-1" )
+  set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC")
+endif()
+STRING( FIND "${CMAKE_CXX_FLAGS}" "-fPIC" PIC_INDEX )
+if("${PIC_INDEX}" STREQUAL "-1" )
+  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+endif()
+add_compile_options (-fPIC)
+
 # Include macros for adding and removing libunwind flags.
 include(HandleLibunwindFlags)
 
+foreach(link_flag LIBUNWIND_LINK_FLAGS CMAKE_EXE_LINKER_FLAGS CMAKE_SHARED_LINKER_FLAGS CMAKE_MODULE_LINKER_FLAGS)
+  if(NOT "${link_flag}" STREQUAL "")
+    string(REGEX REPLACE "^--unwindlib=libunwind$" "--unwindlib=none" ${link_flag} "${${link_flag}}")
+    string(REGEX REPLACE "^-Wl,-lunwind$" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++experimental" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++abi" "" ${link_flag} "${${link_flag}}")
+    string(REPLACE "-lc++" "" ${link_flag} "${${link_flag}}")
+    set(${link_flag} " -lc++experimental ${${link_flag}}")
+  endif()
+endforeach()
+
 #===============================================================================
 # Setup Compiler Flags
 #===============================================================================
@@ -302,6 +324,6 @@ if (LIBUNWIND_INCLUDE_DOCS)
   add_subdirectory(docs)
 endif()
 
-if (LIBUNWIND_INCLUDE_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
+if (LIBUNWIND_INCLUDE_TESTS AND LLVM_BUILD_TESTS AND EXISTS ${LLVM_CMAKE_DIR})
   add_subdirectory(test)
 endif()


# diff --git a/libunwind/src/UnwindRegistersRestore.S b/libunwind/src/UnwindRegistersRestore.S
# index 951189ea54dd..7a24bad687ab 100644
# --- a/libunwind/src/UnwindRegistersRestore.S
# +++ b/libunwind/src/UnwindRegistersRestore.S
# @@ -20,9 +20,7 @@
#    .text
#  #endif
#  
# -#if !defined(__USING_SJLJ_EXCEPTIONS__)
#  
# -#if defined(__i386__)
#  DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_jumpto)
#  #
#  # extern "C" void __libunwind_Registers_x86_jumpto(Registers_x86 *);
# @@ -66,7 +64,6 @@ DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_jumpto)
#    # skip fs
#    # skip gs
#  
# -#elif defined(__x86_64__)
#  
#  DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_64_jumpto)
#  #
# @@ -137,7 +134,7 @@ DEFINE_LIBUNWIND_FUNCTION(__libunwind_Registers_x86_64_jumpto)
#    jmpq   *%rcx
#  
#  
# -#elif defined(__powerpc64__)
# +#if defined(__powerpc64__)
#  
#  DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind15Registers_ppc646jumptoEv)
#  //
# @@ -1228,7 +1225,6 @@ DEFINE_LIBUNWIND_FUNCTION(_ZN9libunwind19Registers_loongarch6jumptoEv)
#  
#  #endif
#  
# -#endif /* !defined(__USING_SJLJ_EXCEPTIONS__) */
#  
#  NO_EXEC_STACK_DIRECTIVE
#  
#  


diff --git a/compiler-rt/CMakeLists.txt b/compiler-rt/CMakeLists.txt
index 1545340aa8a8..c580039e9323 100644
--- a/compiler-rt/CMakeLists.txt
+++ b/compiler-rt/CMakeLists.txt
@@ -16,6 +16,12 @@ if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR OR COMPILER_RT_STANDALONE
   set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 endif()
 
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+add_definitions(-D __ELF__)
+list(APPEND SANITIZER_COMMON_CFLAGS $ENV{LIBUNWIND_ADDITIONAL_COMPILE_FLAGS})
+
 # Add path for custom compiler-rt modules.
 list(INSERT CMAKE_MODULE_PATH 0
   "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
@@ -75,7 +81,7 @@ set(COMPILER_RT_BAREMETAL_BUILD OFF CACHE BOOL
   "Build for a bare-metal target.")
 
 if (COMPILER_RT_STANDALONE_BUILD)
-  set(CMAKE_CXX_STANDARD 17 CACHE STRING "C++ standard to conform to")
+  set(CMAKE_CXX_STANDARD 23 CACHE STRING "C++ standard to conform to")
   set(CMAKE_CXX_STANDARD_REQUIRED YES)
   set(CMAKE_CXX_EXTENSIONS NO)
 
@@ -117,6 +123,9 @@ if (COMPILER_RT_STANDALONE_BUILD)
   set(LLVM_LIT_OUTPUT_DIR "${COMPILER_RT_EXEC_OUTPUT_DIR}")
 endif()
 
+if (NOT LLVM_RUNTIMES_BUILD)
+  load_llvm_config()
+endif()
 construct_compiler_rt_default_triple()
 if ("${COMPILER_RT_DEFAULT_TARGET_TRIPLE}" MATCHES ".*hf$")
   if (${COMPILER_RT_DEFAULT_TARGET_ARCH} MATCHES "^arm")
@@ -241,9 +250,9 @@ set(CXXLIBS none default libstdc++ libc++)
 set_property(CACHE SANITIZER_TEST_CXX PROPERTY STRINGS ;${CXXLIBS})
 handle_default_cxx_lib(SANITIZER_TEST_CXX)
 
-option(COMPILER_RT_USE_LLVM_UNWINDER "Use the LLVM unwinder." OFF)
+option(COMPILER_RT_USE_LLVM_UNWINDER "Use the LLVM unwinder." ON)
 cmake_dependent_option(COMPILER_RT_ENABLE_STATIC_UNWINDER
-  "Statically link the LLVM unwinder." OFF
+  "Statically link the LLVM unwinder." ON
   "COMPILER_RT_USE_LLVM_UNWINDER" OFF)
 
 set(DEFAULT_SANITIZER_USE_STATIC_LLVM_UNWINDER OFF)
@@ -284,7 +293,7 @@ cmake_dependent_option(COMPILER_RT_STATIC_CXX_LIBRARY
   "Statically link the C++ library." OFF
   "COMPILER_RT_CXX_LIBRARY" OFF)
 
-set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY OFF)
+set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
 if (FUCHSIA)
   set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
 endif()
@@ -582,6 +591,7 @@ if (COMPILER_RT_CXX_LIBRARY STREQUAL "libcxx")
   append_list_if(COMPILER_RT_HAS_NOSTDLIBXX_FLAG -nostdlib++ COMPILER_RT_COMMON_LINK_FLAGS)
   # Use the in-tree libc++ through explicit include and library paths.
   set(COMPILER_RT_CXX_CFLAGS "$<$<TARGET_EXISTS:cxx-headers>:$<IF:$<BOOL:${MSVC}>,/imsvc,-isystem>$<JOIN:$<TARGET_PROPERTY:cxx-headers,INTERFACE_INCLUDE_DIRECTORIES>,$<SEMICOLON>$<IF:$<BOOL:${MSVC}>,/imsvc,-isystem>>>")
+  list(APPEND COMPILER_RT_CXX_CFLAGS ${COMPILER_RESOURCE_DIR}/include)
   if (COMPILER_RT_STATIC_CXX_LIBRARY)
     set(COMPILER_RT_CXX_LINK_LIBS "$<TARGET_LINKER_FILE:cxx_static>")
   else()
@@ -743,7 +753,7 @@ pythonize_bool(COMPILER_RT_TEST_USE_LLD)
 
 add_subdirectory(lib)
 
-if(COMPILER_RT_INCLUDE_TESTS)
+if(COMPILER_RT_INCLUDE_TESTS AND TARGET scudo_standalone)
   add_subdirectory(unittests)
   add_subdirectory(test)
   # Don't build llvm-lit for runtimes-build, it will clean up map_config.


# diff --git a/compiler-rt/CMakeLists.txt b/compiler-rt/CMakeLists.txt
# index 1545340aa8a8..812764262aeb 100644
# --- a/compiler-rt/CMakeLists.txt
# +++ b/compiler-rt/CMakeLists.txt
# @@ -16,6 +16,20 @@ if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR OR COMPILER_RT_STANDALONE
#    set_property(GLOBAL PROPERTY USE_FOLDERS ON)
#  endif()
#  
# +set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
# +set (CMAKE_CXX_FLAGS " \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
# +add_definitions(-D __ELF__)
# +list(APPEND SANITIZER_COMMON_CFLAGS $ENV{LIBUNWIND_ADDITIONAL_COMPILE_FLAGS})
# +
#  # Add path for custom compiler-rt modules.
#  list(INSERT CMAKE_MODULE_PATH 0
#    "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
# @@ -75,7 +89,7 @@ set(COMPILER_RT_BAREMETAL_BUILD OFF CACHE BOOL
#    "Build for a bare-metal target.")
#  
#  if (COMPILER_RT_STANDALONE_BUILD)
# -  set(CMAKE_CXX_STANDARD 17 CACHE STRING "C++ standard to conform to")
# +  set(CMAKE_CXX_STANDARD 23 CACHE STRING "C++ standard to conform to")
#    set(CMAKE_CXX_STANDARD_REQUIRED YES)
#    set(CMAKE_CXX_EXTENSIONS NO)
#  
# @@ -117,6 +131,9 @@ if (COMPILER_RT_STANDALONE_BUILD)
#    set(LLVM_LIT_OUTPUT_DIR "${COMPILER_RT_EXEC_OUTPUT_DIR}")
#  endif()
#  
# +if (NOT LLVM_RUNTIMES_BUILD)
# +  load_llvm_config()
# +endif()
#  construct_compiler_rt_default_triple()
#  if ("${COMPILER_RT_DEFAULT_TARGET_TRIPLE}" MATCHES ".*hf$")
#    if (${COMPILER_RT_DEFAULT_TARGET_ARCH} MATCHES "^arm")
# @@ -241,9 +258,9 @@ set(CXXLIBS none default libstdc++ libc++)
#  set_property(CACHE SANITIZER_TEST_CXX PROPERTY STRINGS ;${CXXLIBS})
#  handle_default_cxx_lib(SANITIZER_TEST_CXX)
#  
# -option(COMPILER_RT_USE_LLVM_UNWINDER "Use the LLVM unwinder." OFF)
# +option(COMPILER_RT_USE_LLVM_UNWINDER "Use the LLVM unwinder." ON)
#  cmake_dependent_option(COMPILER_RT_ENABLE_STATIC_UNWINDER
# -  "Statically link the LLVM unwinder." OFF
# +  "Statically link the LLVM unwinder." ON
#    "COMPILER_RT_USE_LLVM_UNWINDER" OFF)
#  
#  set(DEFAULT_SANITIZER_USE_STATIC_LLVM_UNWINDER OFF)
# @@ -284,7 +301,7 @@ cmake_dependent_option(COMPILER_RT_STATIC_CXX_LIBRARY
#    "Statically link the C++ library." OFF
#    "COMPILER_RT_CXX_LIBRARY" OFF)
#  
# -set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY OFF)
# +set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
#  if (FUCHSIA)
#    set(DEFAULT_COMPILER_RT_USE_BUILTINS_LIBRARY ON)
#  endif()


diff --git a/compiler-rt/lib/scudo/standalone/CMakeLists.txt b/compiler-rt/lib/scudo/standalone/CMakeLists.txt
index 094c23a73f36..5933f000f72d 100644
--- a/compiler-rt/lib/scudo/standalone/CMakeLists.txt
+++ b/compiler-rt/lib/scudo/standalone/CMakeLists.txt
@@ -12,9 +12,24 @@ list(APPEND SCUDO_CFLAGS
   -g
   -nostdinc++)
 
+message(WARNING "CMAKE_CXX_FLAGS        = ${CMAKE_CXX_FLAGS}")
+message(WARNING "COMPILER_RESOURCE_DIR  = ${COMPILER_RESOURCE_DIR}")
+message(WARNING "CLANG_RESOURCE_DIR     = ${CLANG_RESOURCE_DIR}")
+message(WARNING "\$ENV{DESTDIR}         = $ENV{DESTDIR}")
+message(WARNING "\$ENV{CXXFLAGS}        = $ENV{CXXFLAGS}")
+message(WARNING "\$ENV{CFLAGS}          = $ENV{CFLAGS}")
+message(WARNING "\$ENV{LDFLAGS}         = $ENV{LDFLAGS}")
+
 # Remove -stdlib= which is unused when passing -nostdinc++.
 string(REGEX REPLACE "-stdlib=[a-zA-Z+]*" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
 
+set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set (CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
 append_list_if(COMPILER_RT_HAS_FVISIBILITY_HIDDEN_FLAG -fvisibility=hidden SCUDO_CFLAGS)
 
 append_list_if(COMPILER_RT_HAS_FNO_EXCEPTIONS_FLAG -fno-exceptions SCUDO_CFLAGS)
@@ -33,8 +48,16 @@ endif()
 append_list_if(COMPILER_RT_HAS_WTHREAD_SAFETY_FLAG -Werror=thread-safety
   SCUDO_CFLAGS)
 
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
 set(SCUDO_LINK_FLAGS)
 
+if(LLVM_ENABLE_BACKTRACES)
+  list(APPEND SCUDO_LINK_FLAGS -lexecinfo)
+endif()
+
 list(APPEND SCUDO_LINK_FLAGS -Wl,-z,defs,-z,now,-z,relro)
 
 list(APPEND SCUDO_LINK_FLAGS -ffunction-sections -fdata-sections -Wl,--gc-sections)
@@ -182,6 +205,7 @@ endif()
 append_list_if(COMPILER_RT_HAS_LIBPTHREAD -pthread SCUDO_LINK_FLAGS)
 
 append_list_if(FUCHSIA zircon SCUDO_LINK_LIBS)
+append_list_if(LLVM_ENABLE_BACKTRACES execinfo SCUDO_LINK_LIBS)
 
 if(COMPILER_RT_DEFAULT_TARGET_ARCH MATCHES "mips|mips64|mipsel|mips64el")
   list(APPEND SCUDO_LINK_LIBS atomic)


# diff --git a/polly/lib/CMakeLists.txt b/polly/lib/CMakeLists.txt
# index 5b58d0ba8d2d..fc2962ef97de 100644
# --- a/polly/lib/CMakeLists.txt
# +++ b/polly/lib/CMakeLists.txt
# @@ -108,6 +108,8 @@ add_llvm_pass_plugin(Polly
#    )
#  set_target_properties(obj.Polly PROPERTIES FOLDER "Polly")
#  set_target_properties(Polly PROPERTIES FOLDER "Polly")
# +set_property(TARGET Polly APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +add_compile_options (-fPIC)
# 
#  if (MSVC_IDE OR XCODE)
#    # Configure source groups for Polly source files. By default, in the IDE there


# diff --git a/polly/CMakeLists.txt b/polly/CMakeLists.txt
# index 5d0f2cd7f00e..b01c310be6d7 100644
# --- a/polly/CMakeLists.txt
# +++ b/polly/CMakeLists.txt
# @@ -8,6 +8,22 @@ endif()
#  # Must go below project(..)
#  include(GNUInstallDirs)
#  
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include -isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_CXX_FLAGS}")
# +message(STATUS "polly/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "polly/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "polly/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "polly/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +
#  if(POLLY_STANDALONE_BUILD)
#    # Where is LLVM installed?
#    find_package(LLVM CONFIG REQUIRED)


# diff --git a/polly/lib/External/CMakeLists.txt b/polly/lib/External/CMakeLists.txt
# index c0a5b32e283f..26bd1befdd8e 100644
# --- a/polly/lib/External/CMakeLists.txt
# +++ b/polly/lib/External/CMakeLists.txt
# @@ -12,6 +12,22 @@ else ()
#    set(DISABLE_WARNING_FLAGS "-w")
#  endif ()
# 
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem /usr/include/c++/v1 \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include -isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem /usr/include/c++/v1 \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include -isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_CXX_FLAGS}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# 
#  # External: Integer Set Library
#  if (POLLY_BUNDLED_ISL)
# @@ -308,6 +324,8 @@ if (POLLY_BUNDLED_ISL)
# 
#    # ISL requires at least C99 to compile. gcc < 5.0 use -std=gnu89 as default.
#    set_property(TARGET PollyISL polly-isl-test PROPERTY C_STANDARD 99)
# +  set_property(TARGET PollyISL APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +  add_compile_options (-fPIC)
# 
#    target_compile_options(PollyISL PRIVATE ${DISABLE_WARNING_FLAGS})
#    target_compile_options(polly-isl-test PRIVATE ${DISABLE_WARNING_FLAGS})


# diff --git a/polly/lib/External/CMakeLists.txt b/polly/lib/External/CMakeLists.txt
# index 458925f9b6e4..a3fe810f6ab5 100644
# --- a/polly/lib/External/CMakeLists.txt
# +++ b/polly/lib/External/CMakeLists.txt
# @@ -12,6 +12,35 @@ else ()
#    set(DISABLE_WARNING_FLAGS "-w")
#  endif ()
#  
# +set(CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
# +set(CMAKE_CXX_FLAGS " \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
# +message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_C_COMPILER}    = ${CMAKE_C_COMPILER}")
# +message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_COMPILER}  = ${CMAKE_CXX_COMPILER}")
# +message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_C_FLAGS}       = ${CMAKE_C_FLAGS}")
# +message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_FLAGS}     = ${CMAKE_CXX_FLAGS}")
# +
# +set(SAFE_CMAKE_REQUIRED_DEFINITIONS "${CMAKE_REQUIRED_DEFINITIONS}")
# +list(APPEND CMAKE_REQUIRED_FLAGS ${CMAKE_C_FLAGS} ${CMAKE_CXX_FLAGS})
# +list(APPEND CMAKE_REQUIRED_INCLUDES
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/clang/${CLANG_VERSION}/include
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
# +$ENV{MAKE_DIR}/libcxx/include
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
# +)
# +
# +foreach(path ${CMAKE_REQUIRED_INCLUDES})
# +  message(WARNING "CMAKE_REQUIRED_INCLUDES : ${path}")
# +endforeach()
#  
#  # External: Integer Set Library
#  if (POLLY_BUNDLED_ISL)
# @@ -59,7 +88,11 @@ if (POLLY_BUNDLED_ISL)
#    function (check_c_type_exists _type _files _variable)
#      set(_includes "")
#      foreach (file_name ${_files})
# -      set(_includes "${_includes}#include<${file_name}>\n")
# +      if("${file_name}" STREQUAL "stdint.h")
# +        set(_includes "${_includes}#include \"$ENV{XHOST_PREFIX}/include/${file_name}\"\n")
# +      else()
# +        set(_includes "${_includes}#include<${file_name}>\n")
# +      endif()
#      endforeach()
#      check_c_source_compiles("
#      ${_includes}
# @@ -68,6 +101,11 @@ if (POLLY_BUNDLED_ISL)
#      return 0;
#      }
#      " ${_variable})
# +    if ("${${_variable}}")
# +      set("${_variable}" 1 PARENT_SCOPE)
# +    else ()
# +      set("${_variable}" 0 PARENT_SCOPE)
# +    endif ()
#    endfunction ()
#  
#  
# @@ -141,7 +179,11 @@ if (POLLY_BUNDLED_ISL)
#    #include <stdio.h>
#    int main(void) { snprintf((void*)0, 0, \" \"); return 0; }
#    " HAVE_DECL_SNPRINTF)
# -
# +  if(NOT $ENV{SNPRINTF_EXISTS} STREQUAL "")
# +    set(HAVE_DECL_SNPRINTF ON)
# +  else()
# +    set(HAVE_DECL_SNPRINTF OFF)
# +  endif()
#    check_c_source_compiles_numeric("
#    #include <stdio.h>
#    int main(void) { _snprintf((void*)0, 0, \" \"); return 0; }
# @@ -153,7 +195,12 @@ if (POLLY_BUNDLED_ISL)
#  
#  
#    check_c_type_exists(uint8_t "" HAVE_UINT8T)
# -  check_c_type_exists(uint8_t "stdint.h" HAVE_STDINT_H)
# +  if(EXISTS "$ENV{XHOST_PREFIX}/include/stdint.h")
# +    # check_c_type_exists(uint8_t "stdint.h" HAVE_STDINT_H)
# +    set(HAVE_STDINT_H ON)
# +  else()
# +    set(HAVE_STDINT_H OFF)
# +  endif()
#    check_c_type_exists(uint8_t "inttypes.h" HAVE_INTTYPES_H)
#    check_c_type_exists(uint8_t "sys/types.h" HAVE_SYS_INTTYPES_H)
#    if (HAVE_UINT8T)
# @@ -314,3 +361,4 @@ if (POLLY_BUNDLED_ISL)
#    target_compile_options(PollyISL PRIVATE ${DISABLE_WARNING_FLAGS})
#    target_compile_options(polly-isl-test PRIVATE ${DISABLE_WARNING_FLAGS})
#  endif (POLLY_BUNDLED_ISL)
# +


diff --git a/polly/lib/External/CMakeLists.txt b/polly/lib/External/CMakeLists.txt
index 458925f9b6e4..c141130baaf0 100644
--- a/polly/lib/External/CMakeLists.txt
+++ b/polly/lib/External/CMakeLists.txt
@@ -12,6 +12,25 @@ else ()
   set(DISABLE_WARNING_FLAGS "-w")
 endif ()
 
+set(CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set(CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
+message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_C_COMPILER}    = ${CMAKE_C_COMPILER}")
+message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_COMPILER}  = ${CMAKE_CXX_COMPILER}")
+message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_C_FLAGS}       = ${CMAKE_C_FLAGS}")
+message(WARNING "polly/lib/External/CMakeLists.txt \${CMAKE_CXX_FLAGS}     = ${CMAKE_CXX_FLAGS}")
+
+foreach(path ${CMAKE_REQUIRED_INCLUDES})
+  message(WARNING "CMAKE_REQUIRED_INCLUDES : ${path}")
+endforeach()
 
 # External: Integer Set Library
 if (POLLY_BUNDLED_ISL)
@@ -59,7 +78,11 @@ if (POLLY_BUNDLED_ISL)
   function (check_c_type_exists _type _files _variable)
     set(_includes "")
     foreach (file_name ${_files})
-      set(_includes "${_includes}#include<${file_name}>\n")
+      if("${file_name}" STREQUAL "stdint.h")
+        set(_includes "${_includes}#include \"$ENV{XHOST_PREFIX}/include/${file_name}\"\n")
+      else()
+        set(_includes "${_includes}#include<${file_name}>\n")
+      endif()
     endforeach()
     check_c_source_compiles("
     ${_includes}
@@ -68,6 +91,11 @@ if (POLLY_BUNDLED_ISL)
     return 0;
     }
     " ${_variable})
+    if ("${${_variable}}")
+      set("${_variable}" 1 PARENT_SCOPE)
+    else ()
+      set("${_variable}" 0 PARENT_SCOPE)
+    endif ()
   endfunction ()
 
 
@@ -141,7 +169,11 @@ if (POLLY_BUNDLED_ISL)
   #include <stdio.h>
   int main(void) { snprintf((void*)0, 0, \" \"); return 0; }
   " HAVE_DECL_SNPRINTF)
-
+  if(NOT $ENV{SNPRINTF_EXISTS} STREQUAL "")
+    set(HAVE_DECL_SNPRINTF ON)
+  else()
+    set(HAVE_DECL_SNPRINTF OFF)
+  endif()
   check_c_source_compiles_numeric("
   #include <stdio.h>
   int main(void) { _snprintf((void*)0, 0, \" \"); return 0; }
@@ -153,7 +185,12 @@ if (POLLY_BUNDLED_ISL)
 
 
   check_c_type_exists(uint8_t "" HAVE_UINT8T)
-  check_c_type_exists(uint8_t "stdint.h" HAVE_STDINT_H)
+  if(EXISTS "$ENV{XHOST_PREFIX}/include/stdint.h")
+    # check_c_type_exists(uint8_t "stdint.h" HAVE_STDINT_H)
+    set(HAVE_STDINT_H ON)
+  else()
+    set(HAVE_STDINT_H OFF)
+  endif()
   check_c_type_exists(uint8_t "inttypes.h" HAVE_INTTYPES_H)
   check_c_type_exists(uint8_t "sys/types.h" HAVE_SYS_INTTYPES_H)
   if (HAVE_UINT8T)


# diff --git a/llvm/lib/Support/CMakeLists.txt b/llvm/lib/Support/CMakeLists.txt
# index 87fe7bebf688..21677e146ee2 100644
# --- a/llvm/lib/Support/CMakeLists.txt
# +++ b/llvm/lib/Support/CMakeLists.txt
# @@ -272,7 +272,7 @@ add_llvm_component_library(LLVMSupport
#    ${Backtrace_INCLUDE_DIRS}
#  
#    LINK_LIBS
# -  ${system_libs} ${imported_libs} ${delayload_flags}
# +  ${system_libs} ${imported_libs} ${delayload_flags} "--unwindlib=libunwind"
#  
#    LINK_COMPONENTS
#    Demangle
# @@ -318,10 +318,24 @@ endif()
#  
#  set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS "${llvm_system_libs}")
#  
# +set_property(TARGET LLVMSupport APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
# +add_compile_options (-fPIC)
# +remove_definitions( -DHAVE_LSEEK64=1 )
# +add_definitions( -UHAVE_LSEEK64 )
# +set_property(TARGET LLVMSupport PROPERTY HAVE_LSEEK64 0)
# +add_compile_options (-UHAVE_LSEEK64)
# +target_compile_options(LLVMSupport PRIVATE -UHAVE_LSEEK64)
# +get_target_property(defs LLVMSupport DEFINITIONS)
# +list(FILTER defs EXCLUDE REGEX [[^HAVE_LSEEK64=.*$]])
# +set_property(TARGET LLVMSupport PROPERTY DEFINITIONS ${defs})
# +target_include_directories(LLVMSupport PUBLIC
# +$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/llvm/include
# +$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/clang/include)
#  
#  if(LLVM_INTEGRATED_CRT_ALLOC)
#    if(LLVM_INTEGRATED_CRT_ALLOC MATCHES "snmalloc$")
# -    set_property(TARGET LLVMSupport PROPERTY CXX_STANDARD 17)
# +    set_property(TARGET LLVMSupport PROPERTY CXX_STANDARD 23)
#      add_compile_definitions(_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING)
#      if ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang" AND
#          "${CMAKE_SYSTEM_PROCESSOR}" MATCHES "x86_64")


diff --git a/llvm/lib/Support/CMakeLists.txt b/llvm/lib/Support/CMakeLists.txt
index 87fe7bebf688..a8882e3d1bf6 100644
--- a/llvm/lib/Support/CMakeLists.txt
+++ b/llvm/lib/Support/CMakeLists.txt
@@ -272,12 +272,58 @@ add_llvm_component_library(LLVMSupport
   ${Backtrace_INCLUDE_DIRS}
 
   LINK_LIBS
-  ${system_libs} ${imported_libs} ${delayload_flags}
+  ${system_libs} ${imported_libs} ${delayload_flags} "--unwindlib=libunwind"
 
   LINK_COMPONENTS
   Demangle
   )
 
+set_property(TARGET LLVMSupport APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+add_compile_options (-fPIC)
+remove_definitions( -DHAVE_LSEEK64=1 )
+add_definitions( -UHAVE_LSEEK64 )
+set_property(TARGET LLVMSupport PROPERTY HAVE_LSEEK64 0)
+add_compile_options (-UHAVE_LSEEK64)
+target_compile_options(LLVMSupport PRIVATE -UHAVE_LSEEK64)
+get_target_property(defs LLVMSupport DEFINITIONS)
+list(FILTER defs EXCLUDE REGEX [[^HAVE_LSEEK64=.*$]])
+set_property(TARGET LLVMSupport PROPERTY DEFINITIONS ${defs})
+
+message(WARNING "Original \${CLANG_VERSION} = ${CLANG_VERSION}")
+if (NOT DEFINED CLANG_VERSION OR CLANG_VERSION STREQUAL "")
+  set (CLANG_VERSION $ENV{CLANG_VERSION} CACHE STRING "" )
+  if (NOT DEFINED CLANG_VERSION OR CLANG_VERSION STREQUAL "")
+    message(FATAL_ERROR "Failed to set \${CLANG_VERSION} = ${CLANG_VERSION}")
+  endif ()
+endif ()
+
+message(WARNING "Current \${CLANG_VERSION} = ${CLANG_VERSION}")
+target_include_directories(LLVMSupport PUBLIC
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/llvm/include
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/clang/include)
+
+set (CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES "")
+
+target_include_directories(LLVMSupport SYSTEM
+    PRIVATE
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/${LLVM_DEFAULT_TARGET_TRIPLE}/c++/v1
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/clang/${CLANG_VERSION}/include
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
+)
+
+# list(APPEND CMAKE_REQUIRED_INCLUDES
+# $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/${LLVM_DEFAULT_TARGET_TRIPLE}/c++/v1
+# $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1
+# $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/clang/${CLANG_VERSION}/include
+# $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
+# )
+
+foreach(path ${CMAKE_REQUIRED_INCLUDES})
+  message(WARNING "CMAKE_REQUIRED_INCLUDES : ${path}")
+endforeach()
+
 set(llvm_system_libs ${system_libs})
 
 # This block is only needed for llvm-config. When we deprecate llvm-config and
@@ -317,11 +363,13 @@ if(LLVM_ENABLE_TERMINFO)
 endif()
 
 set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS "${llvm_system_libs}")
-
+message(WARNING "\${LLVM_SYSTEM_LIBS} = ${LLVM_SYSTEM_LIBS}")
+message(WARNING "\${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
+message(WARNING "\${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
 
 if(LLVM_INTEGRATED_CRT_ALLOC)
   if(LLVM_INTEGRATED_CRT_ALLOC MATCHES "snmalloc$")
-    set_property(TARGET LLVMSupport PROPERTY CXX_STANDARD 17)
+    set_property(TARGET LLVMSupport PROPERTY CXX_STANDARD 23)
     add_compile_definitions(_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING)
     if ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang" AND
         "${CMAKE_SYSTEM_PROCESSOR}" MATCHES "x86_64")
@@ -336,3 +384,45 @@ if(LLVM_WITH_Z3)
     ${Z3_INCLUDE_DIR}
     )
 endif()
+
+get_target_property(LLVMSupport_INCLUDE_DIRECTORIES LLVMSupport INCLUDE_DIRECTORIES)
+
+foreach(path ${LLVMSupport_INCLUDE_DIRECTORIES})
+  message(WARNING "LLVMSupport_INCLUDE_DIRECTORIES : ${path}")
+endforeach()
+
+list(APPEND CMAKE_MODULE_PATH "$ENV{MAKE_DIR}/files")
+include(env)
+
+if(CMAKE_SYSROOT_COMPILE)
+  set(_cmake_sysroot_compile "${CMAKE_SYSROOT_COMPILE}")
+else()
+  set(_cmake_sysroot_compile "${CMAKE_SYSROOT}")
+endif()
+
+if (NOT DEFINED _cmake_sysroot_compile OR _cmake_sysroot_compile STREQUAL "")
+  set (_cmake_sysroot_compile "$ENV{CMAKE_SYSROOT_COMPILE}")
+  if (NOT DEFINED _cmake_sysroot_compile OR _cmake_sysroot_compile STREQUAL "")
+    set (_cmake_sysroot_compile "$ENV{CMAKE_SYSROOT}")
+    if (NOT DEFINED _cmake_sysroot_compile OR _cmake_sysroot_compile STREQUAL "")
+      message (FATAL_ERROR "Failed to set \${_cmake_sysroot_compile} = ${_cmake_sysroot_compile}")
+    endif ()
+  endif ()
+endif ()
+
+filter_prefixed("${CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES}"   ${_cmake_sysroot_compile} CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES)
+filter_prefixed("${CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES}" ${_cmake_sysroot_compile} CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES)
+filter_prefixed("${CMAKE_ASM_IMPLICIT_INCLUDE_DIRECTORIES}" ${_cmake_sysroot_compile} CMAKE_ASM_IMPLICIT_INCLUDE_DIRECTORIES)
+
+unset(_cmake_sysroot_compile)
+foreach(implicit_dir ${CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES})
+  message(WARNING "CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES : ${implicit_dir}")
+  # list(APPEND implicit_dir -I ${implicitDir})
+endforeach()
+
+
+
+
+
+
+


diff --git a/llvm/lib/Target/CMakeLists.txt b/llvm/lib/Target/CMakeLists.txt
index 2739233f9ccb..a02eb9f2b7d9 100644
--- a/llvm/lib/Target/CMakeLists.txt
+++ b/llvm/lib/Target/CMakeLists.txt
@@ -41,3 +41,18 @@ endforeach()
 # logic in llvm_map_components_to_libnames is order dependent on the target
 # libraries being created.
 set_property(GLOBAL PROPERTY LLVM_TARGETS_CONFIGURED On)
+
+set_property(TARGET LLVMTarget APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+add_compile_options (-fPIC)
+remove_definitions( -DHAVE_LSEEK64=1 )
+add_definitions( -UHAVE_LSEEK64 )
+set_property(TARGET LLVMTarget PROPERTY HAVE_LSEEK64 0)
+add_compile_options (-UHAVE_LSEEK64)
+target_compile_options(LLVMTarget PRIVATE -UHAVE_LSEEK64)
+get_target_property(defs LLVMTarget DEFINITIONS)
+list(FILTER defs EXCLUDE REGEX [[^HAVE_LSEEK64=.*$]])
+set_property(TARGET LLVMTarget PROPERTY DEFINITIONS ${defs})
+target_include_directories(LLVMTarget PUBLIC
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/llvm/include
+$ENV{MAKE_DIR}/utils/bazel/llvm-project-overlay/clang/include)


diff --git a/llvm/lib/Target/X86/MCTargetDesc/CMakeLists.txt b/llvm/lib/Target/X86/MCTargetDesc/CMakeLists.txt
index f2e7d43fc17f..e26d4af41f09 100644
--- a/llvm/lib/Target/X86/MCTargetDesc/CMakeLists.txt
+++ b/llvm/lib/Target/X86/MCTargetDesc/CMakeLists.txt
@@ -28,3 +28,9 @@ add_llvm_component_library(LLVMX86Desc
   ADD_TO_COMPONENT
   X86
   )
+
+
+set_property(TARGET LLVMX86Desc APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+add_compile_options (-fPIC)
+


# diff --git a/clang/lib/Lex/CMakeLists.txt b/clang/lib/Lex/CMakeLists.txt
# index 766336b89a23..c557c1729e53 100644
# --- a/clang/lib/Lex/CMakeLists.txt
# +++ b/clang/lib/Lex/CMakeLists.txt
# @@ -5,6 +5,15 @@ set(LLVM_LINK_COMPONENTS
#    TargetParser
#    )
#  
# +set (CMAKE_C_FLAGS " $ENV{cflags} ")
# +set (CMAKE_CXX_FLAGS " \
# +$ENV{cxxflags} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
#  add_clang_library(clangLex
#    DependencyDirectivesScanner.cpp
#    HeaderMap.cpp


# diff --git a/llvm/lib/Support/BLAKE3/CMakeLists.txt b/llvm/lib/Support/BLAKE3/CMakeLists.txt
# index 85fe4f6f4206..8f745a2784a5 100644
# --- a/llvm/lib/Support/BLAKE3/CMakeLists.txt
# +++ b/llvm/lib/Support/BLAKE3/CMakeLists.txt
# @@ -79,4 +79,7 @@ else()
#  endif()
# 
#  add_library(LLVMSupportBlake3 OBJECT EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES})
# +set_property(TARGET LLVMSupportBlake3 APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
# +add_compile_options (-fPIC)
#  llvm_update_compile_flags(LLVMSupportBlake3)


diff --git a/llvm/lib/Support/BLAKE3/CMakeLists.txt b/llvm/lib/Support/BLAKE3/CMakeLists.txt
index cb4f840461f7..1a0b31020f65 100644
--- a/llvm/lib/Support/BLAKE3/CMakeLists.txt
+++ b/llvm/lib/Support/BLAKE3/CMakeLists.txt
@@ -78,5 +78,17 @@ else()
   disable_blake3_x86_simd()
 endif()
 
+set (CMAKE_C_FLAGS " $ENV{CFLAGS} ")
+set (CMAKE_CXX_FLAGS " \
+$ENV{CXXFLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
 add_library(LLVMSupportBlake3 OBJECT EXCLUDE_FROM_ALL ${LLVM_BLAKE3_FILES})
+set_property(TARGET LLVMSupportBlake3 APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
+set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+add_compile_options (-fPIC)
 llvm_update_compile_flags(LLVMSupportBlake3)


# diff --git a/utils/bazel/llvm-project-overlay/llvm/config.bzl b/utils/bazel/llvm-project-overlay/llvm/config.bzl
# index 5507f80efa0b..b15ec9e1bb39 100644
# --- a/utils/bazel/llvm-project-overlay/llvm/config.bzl
# +++ b/utils/bazel/llvm-project-overlay/llvm/config.bzl
# @@ -48,7 +48,7 @@ posix_defines = [
#  linux_defines = posix_defines + [
#      "_GNU_SOURCE",
#      "HAVE_LINK_H=1",
# -    "HAVE_LSEEK64=1",
# +    "HAVE_LSEEK64=0",
#      "HAVE_MALLINFO=1",
#      "HAVE_SBRK=1",
#      "HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC=1",


# diff --git a/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h b/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# index 8a30957b6120..43698cb46974 100644
# --- a/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# +++ b/utils/bazel/llvm-project-overlay/llvm/include/llvm/Config/config.h
# @@ -146,6 +146,9 @@
# 
#  /* Define to 1 if you have the `lseek64' function. */
#  /* HAVE_LSEEK64 defined in Bazel */
# +#if defined HAVE_LSEEK64
# +#undef HAVE_LSEEK64
# +#endif
# 
#  /* Define to 1 if you have the <mach/mach.h> header file. */
#  /* HAVE_MACH_MACH_H defined in Bazel */


# diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
# index 92b15f14c62f..3e76c8a624dd 100644
# --- a/llvm/lib/Support/raw_ostream.cpp
# +++ b/llvm/lib/Support/raw_ostream.cpp
# @@ -59,6 +59,10 @@
#  #include "llvm/Support/Windows/WindowsSupport.h"
#  #endif
# 
# +#if defined HAVE_LSEEK64
# +#undef HAVE_LSEEK64
# +#endif
# +
#  using namespace llvm;
# 
#  constexpr raw_ostream::Colors raw_ostream::BLACK;


# diff --git a/clang/lib/Headers/CMakeLists.txt b/clang/lib/Headers/CMakeLists.txt
# index bb9a11eabbef..342c4789b581 100644
# --- a/clang/lib/Headers/CMakeLists.txt
# +++ b/clang/lib/Headers/CMakeLists.txt
# @@ -283,7 +283,7 @@ set(openmp_wrapper_files
#    openmp_wrappers/new
#  )
#  
# -set(output_dir ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION_MAJOR}/include)
# +set(output_dir ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION}/include)
#  set(out_files)
#  set(generated_files)
#  
# @@ -437,7 +437,7 @@ add_header_target("openmp-resource-headers" ${openmp_wrapper_files})
#  add_header_target("windows-resource-headers" ${windows_only_files})
#  add_header_target("utility-resource-headers" ${utility_files})
#  
# -set(header_install_dir lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION_MAJOR}/include)
# +set(header_install_dir lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION}/include)
#  
#  #############################################################
#  # Install rules for the catch-all clang-resource-headers target
# diff --git a/clang/lib/Tooling/CMakeLists.txt b/clang/lib/Tooling/CMakeLists.txt
# index e4ce43762d6b..58877218e453 100644
# --- a/clang/lib/Tooling/CMakeLists.txt
# +++ b/clang/lib/Tooling/CMakeLists.txt
# @@ -61,7 +61,7 @@ else()
#        $<TARGET_FILE:clang-ast-dump>
#          # Skip this in debug mode because parsing AST.h is too slow
#          --skip-processing=${skip_expensive_processing}
# -        -I ${LLVM_BINARY_DIR}/lib/clang/${CLANG_VERSION_MAJOR}/include
# +        -I ${LLVM_BINARY_DIR}/lib/clang/${CLANG_VERSION}/include
#          -I ${CLANG_SOURCE_DIR}/include
#          -I ${LLVM_BINARY_DIR}/tools/clang/include
#          -I ${LLVM_BINARY_DIR}/include
# diff --git a/compiler-rt/cmake/base-config-ix.cmake b/compiler-rt/cmake/base-config-ix.cmake
# index 0ad95d57fa74..f50f2a764d45 100644
# --- a/compiler-rt/cmake/base-config-ix.cmake
# +++ b/compiler-rt/cmake/base-config-ix.cmake
# @@ -43,9 +43,9 @@ if (LLVM_TREE_AVAILABLE)
#    string(REGEX MATCH "^[0-9]+" CLANG_VERSION_MAJOR
#           ${PACKAGE_VERSION})
#    # Setup the paths where compiler-rt runtimes and headers should be stored.
# -  set(COMPILER_RT_OUTPUT_DIR ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION_MAJOR})
# +  set(COMPILER_RT_OUTPUT_DIR ${LLVM_LIBRARY_OUTPUT_INTDIR}/clang/${CLANG_VERSION})
#    set(COMPILER_RT_EXEC_OUTPUT_DIR ${LLVM_RUNTIME_OUTPUT_INTDIR})
# -  set(COMPILER_RT_INSTALL_PATH lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION_MAJOR})
# +  set(COMPILER_RT_INSTALL_PATH lib${LLVM_LIBDIR_SUFFIX}/clang/${CLANG_VERSION})
#    option(COMPILER_RT_INCLUDE_TESTS "Generate and build compiler-rt unit tests."
#           ${LLVM_INCLUDE_TESTS})
#    option(COMPILER_RT_ENABLE_WERROR "Fail and stop if warning is triggered"


#   Could NOT find Threads (missing: Threads_FOUND)


diff --git a/openmp/runtime/cmake/config-ix.cmake b/openmp/runtime/cmake/config-ix.cmake
index 9869aeab0354..de79a08fb756 100644
--- a/openmp/runtime/cmake/config-ix.cmake
+++ b/openmp/runtime/cmake/config-ix.cmake
@@ -150,6 +150,12 @@ if(CMAKE_C_COMPILER_ID STREQUAL "Intel" OR CMAKE_C_COMPILER_ID STREQUAL "IntelLL
   check_library_exists(irc_pic _intel_fast_memcpy "" LIBOMP_HAVE_IRC_PIC_LIBRARY)
 endif()
 
+set (CMAKE_THREAD_LIBS_INIT         "-lpthread")
+set (CMAKE_HAVE_THREADS_LIBRARY     1)
+set (CMAKE_USE_WIN32_THREADS_INIT   0)
+set (CMAKE_USE_PTHREADS_INIT        1)
+set (THREADS_PREFER_PTHREAD_FLAG    ON) # set(THREADS_PREFER_PTHREAD_FLAG TRUE)
+
 # Checking Threading requirements
 find_package(Threads REQUIRED)
 if(WIN32)


# diff --git a/openmp/CMakeLists.txt b/openmp/CMakeLists.txt
# index a87ea2fb57c5..64cd7c085609 100644
# --- a/openmp/CMakeLists.txt
# +++ b/openmp/CMakeLists.txt
# @@ -21,6 +21,25 @@ if (OPENMP_STANDALONE_BUILD OR "${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_CURRENT_S
#    endif()
#  endif()
# 
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem /usr/include/c++/v1 \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include -isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem /usr/include/c++/v1 \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include -isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_CXX_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +
# +add_compile_options (-fPIC)
# +
#  # Must go below project(..)
#  include(GNUInstallDirs)
# 
# @@ -58,6 +77,9 @@ else()
#    endif()
#  endif()
# 
# +set (LLVM_CXX_STD "c++20")
# +set (LLVM_REQUIRED_CXX_STANDARD 20)
# +set (CMAKE_SIZEOF_VOID_P "8")
#  # Check and set up common compiler flags.
#  include(config-ix)
#  include(HandleOpenMPOptions)
# @@ -75,7 +97,7 @@ set(ENABLE_LIBOMPTARGET ON)
#  # Since the device plugins are only supported on Linux anyway,
#  # there is no point in trying to compile libomptarget on other OSes.
#  # 32-bit systems are not supported either.
# -if (APPLE OR WIN32 OR NOT OPENMP_HAVE_STD_CPP17_FLAG OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
# +if (APPLE OR WIN32 OR NOT OPENMP_HAS_STD_CPP_FLAG OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#    set(ENABLE_LIBOMPTARGET OFF)
#  endif()
# 
# @@ -99,7 +121,7 @@ if (OPENMP_ENABLE_LIBOMPTARGET)
#    # Check that the library can actually be built.
#    if (APPLE OR WIN32)
#      message(FATAL_ERROR "libomptarget cannot be built on Windows and MacOS X!")
# -  elseif (NOT OPENMP_HAVE_STD_CPP17_FLAG)
# +  elseif (NOT OPENMP_HAS_STD_CPP_FLAG)
#      message(FATAL_ERROR "Host compiler must support C++17 to build libomptarget!")
#    elseif (NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#      message(FATAL_ERROR "libomptarget on 32-bit systems are not supported!")

# diff --git a/openmp/cmake/config-ix.cmake b/openmp/cmake/config-ix.cmake
# index 857cfe5da8d6..a2fd13b7e2f4 100644
# --- a/openmp/cmake/config-ix.cmake
# +++ b/openmp/cmake/config-ix.cmake
# @@ -37,4 +37,5 @@ check_cxx_compiler_flag(-Wextra OPENMP_HAVE_WEXTRA_FLAG)
#  check_cxx_compiler_flag(-Wpedantic OPENMP_HAVE_WPEDANTIC_FLAG)
#  check_cxx_compiler_flag(-Wmaybe-uninitialized OPENMP_HAVE_WMAYBE_UNINITIALIZED_FLAG)
# 
# -check_cxx_compiler_flag(-std=c++17 OPENMP_HAVE_STD_CPP17_FLAG)
# +check_cxx_compiler_flag(-std=c++20 OPENMP_HAS_STD_CPP_FLAG)
# +set (OPENMP_HAS_STD_CPP_FLAG "ON")

# diff --git a/openmp/cmake/HandleOpenMPOptions.cmake b/openmp/cmake/HandleOpenMPOptions.cmake
# index 53a2d053e424..43afc180fc51 100644
# --- a/openmp/cmake/HandleOpenMPOptions.cmake
# +++ b/openmp/cmake/HandleOpenMPOptions.cmake
# @@ -36,4 +36,4 @@ append_if(OPENMP_HAVE_WEXTRA_FLAG "-Wno-extra" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
#  append_if(OPENMP_HAVE_WPEDANTIC_FLAG "-Wno-pedantic" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
#  append_if(OPENMP_HAVE_WMAYBE_UNINITIALIZED_FLAG "-Wno-maybe-uninitialized" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
# 
# -append_if(OPENMP_HAVE_STD_CPP17_FLAG "-std=c++17" CMAKE_CXX_FLAGS)
# +append_if(OPENMP_HAS_STD_CPP_FLAG "-std=c++20" CMAKE_CXX_FLAGS)

# diff --git a/openmp/CMakeLists.txt b/openmp/CMakeLists.txt
# index c1efcaf80b54..facaf617a0ba 100644
# --- a/openmp/CMakeLists.txt
# +++ b/openmp/CMakeLists.txt
# @@ -17,6 +17,35 @@ endif()
#  # Must go below project(..)
#  include(GNUInstallDirs)
#  
# +set(CMAKE_C_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_C_FLAGS}")
# +set(CMAKE_CXX_FLAGS " -D_LIBCPP_STD_VER=23 -fPIC --sysroot=${KISS_ROOT} \
# +-isystem $ENV{MAKE_DIR}/clang/lib/Headers \
# +-isystem $ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +-isystem $ENV{MAKE_DIR}/pstl/include \
# +-isystem $ENV{MAKE_DIR}/libcxx/include \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ${CMAKE_CXX_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_COMPILER} = ${CMAKE_C_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_COMPILER} = ${CMAKE_CXX_COMPILER}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_FLAGS} = ${CMAKE_C_FLAGS}")
# +message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_FLAGS} = ${CMAKE_CXX_FLAGS}")
# +
# +list(APPEND CMAKE_REQUIRED_INCLUDES "\
# +$ENV{MAKE_DIR}/clang/lib/Headers \
# +$ENV{OUTPUT_DIR}/runtimes/runtimes-bins/pstl/generated_headers \
# +$ENV{MAKE_DIR}/pstl/include \
# +$ENV{MAKE_DIR}/libcxx/include \
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include ")
# +
# +add_compile_options (-fPIC)
# +
# +set (LLVM_CXX_STD "c++23")
# +set (LLVM_REQUIRED_CXX_STANDARD 23)
# +set (CMAKE_SIZEOF_VOID_P "8")
# +
#  if (OPENMP_STANDALONE_BUILD)
#    # CMAKE_BUILD_TYPE was not set, default to Release.
#    if (NOT CMAKE_BUILD_TYPE)
# @@ -56,7 +86,7 @@ else()
#  
#    # If not standalone, set CMAKE_CXX_STANDARD but don't set the global cache value,
#    # only set it locally for OpenMP.
# -  set(CMAKE_CXX_STANDARD 17)
# +  set(CMAKE_CXX_STANDARD 23)
#    set(CMAKE_CXX_STANDARD_REQUIRED NO)
#    set(CMAKE_CXX_EXTENSIONS NO)
#  endif()
# @@ -78,7 +108,7 @@ set(ENABLE_LIBOMPTARGET ON)
#  # Since the device plugins are only supported on Linux anyway,
#  # there is no point in trying to compile libomptarget on other OSes.
#  # 32-bit systems are not supported either.
# -if (APPLE OR WIN32 OR NOT "cxx_std_17" IN_LIST CMAKE_CXX_COMPILE_FEATURES OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
# +if (APPLE OR WIN32 OR NOT "cxx_std_23" IN_LIST CMAKE_CXX_COMPILE_FEATURES OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#    set(ENABLE_LIBOMPTARGET OFF)
#  endif()
#  
# @@ -102,7 +132,7 @@ if (OPENMP_ENABLE_LIBOMPTARGET)
#    # Check that the library can actually be built.
#    if (APPLE OR WIN32)
#      message(FATAL_ERROR "libomptarget cannot be built on Windows and MacOS X!")
# -  elseif (NOT "cxx_std_17" IN_LIST CMAKE_CXX_COMPILE_FEATURES)
# +  elseif (NOT "cxx_std_23" IN_LIST CMAKE_CXX_COMPILE_FEATURES)
#      message(FATAL_ERROR "Host compiler must support C++17 to build libomptarget!")
#    elseif (NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
#      message(FATAL_ERROR "libomptarget on 32-bit systems are not supported!")


diff --git a/openmp/CMakeLists.txt b/openmp/CMakeLists.txt
index c1efcaf80b54..039f74f699b3 100644
--- a/openmp/CMakeLists.txt
+++ b/openmp/CMakeLists.txt
@@ -17,6 +17,35 @@ endif()
 # Must go below project(..)
 include(GNUInstallDirs)
 
+set(CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set(CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
+message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_COMPILER}    = ${CMAKE_C_COMPILER}")
+message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_COMPILER}  = ${CMAKE_CXX_COMPILER}")
+message(STATUS "openmp/CMakeLists.txt \${CMAKE_C_FLAGS}       = ${CMAKE_C_FLAGS}")
+message(STATUS "openmp/CMakeLists.txt \${CMAKE_CXX_FLAGS}     = ${CMAKE_CXX_FLAGS}")
+
+list(APPEND CMAKE_REQUIRED_INCLUDES
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/${LLVM_DEFAULT_TARGET_TRIPLE}/c++/v1
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/clang/${CLANG_VERSION}/include
+$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
+)
+
+add_compile_options (-fPIC)
+
+set (LLVM_CXX_STD "c++23")
+set (LLVM_REQUIRED_CXX_STANDARD 23)
+set (CMAKE_SIZEOF_VOID_P "8")
+
 if (OPENMP_STANDALONE_BUILD)
   # CMAKE_BUILD_TYPE was not set, default to Release.
   if (NOT CMAKE_BUILD_TYPE)
@@ -38,25 +67,32 @@ if (OPENMP_STANDALONE_BUILD)
     "C++ compiler to use for testing OpenMP runtime libraries.")
   set(OPENMP_LLVM_TOOLS_DIR "" CACHE PATH "Path to LLVM tools for testing.")
 
-  set(CMAKE_CXX_STANDARD 17 CACHE STRING "C++ standard to conform to")
+  set(CMAKE_CXX_STANDARD 23 CACHE STRING "C++ standard to conform to")
   set(CMAKE_CXX_STANDARD_REQUIRED NO)
   set(CMAKE_CXX_EXTENSIONS NO)
 else()
+
+  list(APPEND CMAKE_MODULE_PATH "$ENV{MAKE_DIR}/files")
+  include(env)
+  env_prepend(PATH "${LLVM_RUNTIME_OUTPUT_INTDIR}")
+  message(WARNING "\$ENV{CMAKE_C_COMPILER} = $ENV{CMAKE_C_COMPILER}")
+  message(WARNING "\$ENV{CMAKE_CXX_COMPILER} = $ENV{CMAKE_CXX_COMPILER}")
+
   set(OPENMP_ENABLE_WERROR ${LLVM_ENABLE_WERROR})
   # If building in tree, we honor the same install suffix LLVM uses.
   set(OPENMP_INSTALL_LIBDIR "lib${LLVM_LIBDIR_SUFFIX}")
 
   if (NOT MSVC)
-    set(OPENMP_TEST_C_COMPILER ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang)
-    set(OPENMP_TEST_CXX_COMPILER ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang++)
+    set(OPENMP_TEST_C_COMPILER $ENV{CMAKE_C_COMPILER})
+    set(OPENMP_TEST_CXX_COMPILER $ENV{CMAKE_CXX_COMPILER})
   else()
-    set(OPENMP_TEST_C_COMPILER ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang.exe)
-    set(OPENMP_TEST_CXX_COMPILER ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang++.exe)
+    set(OPENMP_TEST_C_COMPILER $ENV{CMAKE_C_COMPILER})
+    set(OPENMP_TEST_CXX_COMPILER $ENV{CMAKE_CXX_COMPILER})
   endif()
 
   # If not standalone, set CMAKE_CXX_STANDARD but don't set the global cache value,
   # only set it locally for OpenMP.
-  set(CMAKE_CXX_STANDARD 17)
+  set(CMAKE_CXX_STANDARD 23)
   set(CMAKE_CXX_STANDARD_REQUIRED NO)
   set(CMAKE_CXX_EXTENSIONS NO)
 endif()
@@ -78,7 +114,7 @@ set(ENABLE_LIBOMPTARGET ON)
 # Since the device plugins are only supported on Linux anyway,
 # there is no point in trying to compile libomptarget on other OSes.
 # 32-bit systems are not supported either.
-if (APPLE OR WIN32 OR NOT "cxx_std_17" IN_LIST CMAKE_CXX_COMPILE_FEATURES OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
+if (APPLE OR WIN32 OR NOT "cxx_std_23" IN_LIST CMAKE_CXX_COMPILE_FEATURES OR NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
   set(ENABLE_LIBOMPTARGET OFF)
 endif()
 
@@ -102,7 +138,7 @@ if (OPENMP_ENABLE_LIBOMPTARGET)
   # Check that the library can actually be built.
   if (APPLE OR WIN32)
     message(FATAL_ERROR "libomptarget cannot be built on Windows and MacOS X!")
-  elseif (NOT "cxx_std_17" IN_LIST CMAKE_CXX_COMPILE_FEATURES)
+  elseif (NOT "cxx_std_23" IN_LIST CMAKE_CXX_COMPILE_FEATURES)
     message(FATAL_ERROR "Host compiler must support C++17 to build libomptarget!")
   elseif (NOT CMAKE_SIZEOF_VOID_P EQUAL 8)
     message(FATAL_ERROR "libomptarget on 32-bit systems are not supported!")


diff --git a/openmp/libomptarget/CMakeLists.txt b/openmp/libomptarget/CMakeLists.txt
index 844107b3dade..e8844cb977f7 100644
--- a/openmp/libomptarget/CMakeLists.txt
+++ b/openmp/libomptarget/CMakeLists.txt
@@ -47,6 +47,8 @@ set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} powerpc64-ibm-linux-g
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} powerpc64-ibm-linux-gnu-LTO")
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-pc-linux-gnu")
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-pc-linux-gnu-LTO")
+set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-linux-musl")
+set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} x86_64-linux-musl-LTO")
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda")
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda-LTO")
 set (LIBOMPTARGET_ALL_TARGETS "${LIBOMPTARGET_ALL_TARGETS} nvptx64-nvidia-cuda-JIT-LTO")


diff --git a/openmp/libompd/src/CMakeLists.txt b/openmp/libompd/src/CMakeLists.txt
index 0402a0177201..36fb0d74bd96 100644
--- a/openmp/libompd/src/CMakeLists.txt
+++ b/openmp/libompd/src/CMakeLists.txt
@@ -15,36 +15,39 @@ add_library (ompd SHARED TargetValue.cpp omp-debug.cpp omp-state.cpp omp-icv.cpp
 
 target_link_libraries(ompd omp) # ensure generated import library is created first
 
-set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+STRING( FIND "${CMAKE_CXX_FLAGS}" "-std=" STD_INDEX )
+if("${STD_INDEX}" STREQUAL "-1" )
+  set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+endif()
 
 set(LIBOMPD_LD_STD_FLAGS FALSE CACHE BOOL
   "Use -stdlibc++ instead of -libc++ library for C++ ")
 
 if(${LIBOMPD_LD_STD_FLAGS})
-#  Find and replace/add libstdc++ to compile flags     
-   STRING( FIND "${CMAKE_CXX_FLAGS}" "-stdlib=libc++" OUT )
-   if("${OUT}" STREQUAL "-1" )   
-      set (CMAKE_CXX_FLAGS "-stdlib=libstdc++ ${CMAKE_CXX_FLAGS}")
-   else()
-      STRING( REPLACE "-stdlib=libc++" "-stdlib=libstdc++" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} )
-   endif()         
-
-#  Find and replace/add libstdc++ to loader flags
-   STRING( FIND "${CMAKE_SHARED_LINKER_FLAGS}" "-stdlib=libc++" OUT )
-   if("${OUT}" STREQUAL "-1" )   
-      set (CMAKE_SHARED_LINKER_FLAGS "-stdlib=libstdc++ ${CMAKE_SHARED_LINKER_FLAGS}")         
-   else()
-      STRING( REPLACE "-stdlib=libc++" "-stdlib=libstdc++" CMAKE_SHARED_LINKER_FLAGS ${CMAKE_SHARED_LINKER_FLAGS} )
-   endif()
+  #  Find and replace/add libstdc++ to compile flags
+  STRING( FIND "${CMAKE_CXX_FLAGS}" "-stdlib=libc++" OUT )
+  if("${OUT}" STREQUAL "-1" )
+    set (CMAKE_CXX_FLAGS "-stdlib=libstdc++ ${CMAKE_CXX_FLAGS}")
+  else()
+    STRING( REPLACE "-stdlib=libc++" "-stdlib=libstdc++" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} )
+  endif()
+
+  #  Find and replace/add libstdc++ to loader flags
+  STRING( FIND "${CMAKE_SHARED_LINKER_FLAGS}" "-stdlib=libc++" OUT )
+  if("${OUT}" STREQUAL "-1" )
+    set (CMAKE_SHARED_LINKER_FLAGS "-stdlib=libstdc++ ${CMAKE_SHARED_LINKER_FLAGS}")
+  else()
+    STRING( REPLACE "-stdlib=libc++" "-stdlib=libstdc++" CMAKE_SHARED_LINKER_FLAGS ${CMAKE_SHARED_LINKER_FLAGS} )
+  endif()
 endif()
 
 include_directories (
-        ${CMAKE_CURRENT_SOURCE_DIR}
-        ${LIBOMP_INCLUDE_DIR}
-        ${LIBOMP_SRC_DIR}
-)
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${LIBOMP_INCLUDE_DIR}
+  ${LIBOMP_SRC_DIR}
+  )
 
 INSTALL( TARGETS ompd
-        LIBRARY DESTINATION ${OPENMP_INSTALL_LIBDIR}
-        ARCHIVE DESTINATION ${OPENMP_INSTALL_LIBDIR}
-        RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}" )
+  LIBRARY DESTINATION ${OPENMP_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${OPENMP_INSTALL_LIBDIR}
+  RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}" )


# diff --git a/llvm/lib/Support/Unix/Signals.inc b/llvm/lib/Support/Unix/Signals.inc
# index 05a7335216f4..0589a38025bf 100644
# --- a/llvm/lib/Support/Unix/Signals.inc
# +++ b/llvm/lib/Support/Unix/Signals.inc
# @@ -85,12 +85,12 @@ static void InfoSignalHandler(int Sig); // defined below.
#  using SignalHandlerFunctionType = void (*)();
#  /// The function to call if ctrl-c is pressed.
#  static std::atomic<SignalHandlerFunctionType> InterruptFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
#  static std::atomic<SignalHandlerFunctionType> InfoSignalFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
#  /// The function to call on SIGPIPE (one-time use only).
#  static std::atomic<SignalHandlerFunctionType> OneShotPipeSignalFunction =
# -    ATOMIC_VAR_INIT(nullptr);
# +    (nullptr);
# 
#  namespace {
#  /// Signal-safe removal of files.
# @@ -98,8 +98,8 @@ namespace {
#  /// themselves is signal-safe. Memory is freed when the head is freed, deletion
#  /// is therefore not signal-safe either.
#  class FileToRemoveList {
# -  std::atomic<char *> Filename = ATOMIC_VAR_INIT(nullptr);
# -  std::atomic<FileToRemoveList *> Next = ATOMIC_VAR_INIT(nullptr);
# +  std::atomic<char *> Filename = (nullptr);
# +  std::atomic<FileToRemoveList *> Next = (nullptr);
# 
#    FileToRemoveList() = default;
#    // Not signal-safe.
# @@ -188,7 +188,7 @@ public:
#      Head.exchange(OldHead);
#    }
#  };
# -static std::atomic<FileToRemoveList *> FilesToRemove = ATOMIC_VAR_INIT(nullptr);
# +static std::atomic<FileToRemoveList *> FilesToRemove = (nullptr);
# 
#  /// Clean up the list in a signal-friendly manner.
#  /// Recall that signals can fire during llvm_shutdown. If this occurs we should
# @@ -248,7 +248,7 @@ static const int InfoSigs[] = {SIGUSR1
#  static const size_t NumSigs = std::size(IntSigs) + std::size(KillSigs) +
#                                std::size(InfoSigs) + 1 /* SIGPIPE */;
# 
# -static std::atomic<unsigned> NumRegisteredSignals = ATOMIC_VAR_INIT(0);
# +static std::atomic<unsigned> NumRegisteredSignals = (0);
#  static struct {
#    struct sigaction SA;
#    int SigNo;


# diff --git a/llvm/utils/count/CMakeLists.txt b/llvm/utils/count/CMakeLists.txt
# index 4e0d371334e4..e52a2f229582 100644
# --- a/llvm/utils/count/CMakeLists.txt
# +++ b/llvm/utils/count/CMakeLists.txt
# @@ -1,3 +1,5 @@
#  add_llvm_utility(count
#    count.c
#    )
# +set_property(TARGET count APPEND PROPERTY COMPILE_OPTIONS "-fPIC")
# +add_compile_options (-fPIC)

# diff --git a/llvm/lib/Support/PrettyStackTrace.cpp b/llvm/lib/Support/PrettyStackTrace.cpp
# --- a/llvm/lib/Support/PrettyStackTrace.cpp
# +++ b/llvm/lib/Support/PrettyStackTrace.cpp
# @@ -65,7 +65,7 @@
#  // SIGINFO requests, it's possible that some threads will stop responding to it,
#  // but the program won't crash.
#  static volatile std::atomic<unsigned> GlobalSigInfoGenerationCounter =
# -    ATOMIC_VAR_INIT(1);
# +    (1);
#  static LLVM_THREAD_LOCAL unsigned ThreadLocalSigInfoGenerationCounter = 0;
# 
#  namespace llvm {


diff --git a/llvm/include/llvm/Support/ScopedPrinter.h b/llvm/include/llvm/Support/ScopedPrinter.h
index aaaed3f5ceac..2f6fff6f76e9 100644
--- a/llvm/include/llvm/Support/ScopedPrinter.h
+++ b/llvm/include/llvm/Support/ScopedPrinter.h
@@ -539,7 +539,13 @@ ScopedPrinter::printHex<support::ulittle16_t>(StringRef Label,
   startLine() << Label << ": " << hex(Value) << "\n";
 }
 
-struct DelimitedScope;
+struct DelimitedScope {
+  DelimitedScope(ScopedPrinter &W) : W(&W) {}
+  DelimitedScope() : W(nullptr) {}
+  virtual ~DelimitedScope() = default;
+  virtual void setPrinter(ScopedPrinter &W) = 0;
+  ScopedPrinter *W;
+};
 
 class JSONScopedPrinter : public ScopedPrinter {
 private:
@@ -838,14 +844,6 @@ private:
   }
 };
 
-struct DelimitedScope {
-  DelimitedScope(ScopedPrinter &W) : W(&W) {}
-  DelimitedScope() : W(nullptr) {}
-  virtual ~DelimitedScope() = default;
-  virtual void setPrinter(ScopedPrinter &W) = 0;
-  ScopedPrinter *W;
-};
-
 struct DictScope : DelimitedScope {
   explicit DictScope() = default;
   explicit DictScope(ScopedPrinter &W) : DelimitedScope(W) { W.objectBegin(); }



diff --git a/llvm/lib/TableGen/TGParser.cpp b/llvm/lib/TableGen/TGParser.cpp
index 759e15f4c443..81b7ff9c21f2 100644
--- a/llvm/lib/TableGen/TGParser.cpp
+++ b/llvm/lib/TableGen/TGParser.cpp
@@ -4362,3 +4362,11 @@ LLVM_DUMP_METHOD void MultiClass::dump() const {
     E.dump();
 }
 #endif
+
+
+RecordsEntry::RecordsEntry(std::unique_ptr<Record> Rec) : Rec(std::move(Rec)) {}
+RecordsEntry::RecordsEntry(std::unique_ptr<ForeachLoop> Loop) : Loop(std::move(Loop)) {}
+RecordsEntry::RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion)
+  : Assertion(std::move(Assertion)) {}
+
+
diff --git a/llvm/lib/TableGen/TGParser.h b/llvm/lib/TableGen/TGParser.h
index d42cdad88a84..02294df48e7f 100644
--- a/llvm/lib/TableGen/TGParser.h
+++ b/llvm/lib/TableGen/TGParser.h
@@ -45,10 +45,9 @@ struct RecordsEntry {
   void dump() const;
 
   RecordsEntry() = default;
-  RecordsEntry(std::unique_ptr<Record> Rec) : Rec(std::move(Rec)) {}
-  RecordsEntry(std::unique_ptr<ForeachLoop> Loop) : Loop(std::move(Loop)) {}
-  RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion)
-      : Assertion(std::move(Assertion)) {}
+  RecordsEntry(std::unique_ptr<Record> Rec);
+  RecordsEntry(std::unique_ptr<ForeachLoop> Loop);
+  RecordsEntry(std::unique_ptr<Record::AssertionInfo> Assertion);
 };
 
 /// ForeachLoop - Record the iteration state associated with a for loop.


diff --git a/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp b/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
index 23697fd9e2e2..ce6d93f372e9 100644
--- a/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
+++ b/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp
@@ -759,3 +759,19 @@ void GIMatchTreeVRegDefPartitioner::generatePartitionSelectorCode(
 
   OS << Indent << "if (Partition == -1) return false;\n";
 }
+
+void GIMatchTree::setNumChildren(unsigned Num) { Children.resize(Num); }
+
+void GIMatchTree::setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V) {
+  Partitioner = std::move(V);
+}
+
+GIMatchTreeBuilder::GIMatchTreeBuilder(unsigned NextInstrID) : NextInstrID(NextInstrID) {}
+GIMatchTreeBuilder::GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID)
+    : TreeNode(TreeNode), NextInstrID(NextInstrID) {}
+
+void GIMatchTreeBuilder::addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P) {
+  Partitioners.push_back(std::move(P));
+}
+
+
diff --git a/llvm/utils/TableGen/GlobalISel/GIMatchTree.h b/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
index c65423ddacdb..e3b974fc7ed7 100644
--- a/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
+++ b/llvm/utils/TableGen/GlobalISel/GIMatchTree.h
@@ -137,7 +137,7 @@ class GIMatchTree {
 public:
   void writeDOTGraph(raw_ostream &OS) const;
 
-  void setNumChildren(unsigned Num) { Children.resize(Num); }
+  void setNumChildren(unsigned Num);
   void addPossibleLeaf(const GIMatchTreeLeafInfo &V, bool IsFullyTraversed,
                        bool IsFullyTested) {
     PossibleLeaves.push_back(V);
@@ -148,9 +148,7 @@ public:
     if (PossibleLeaves.size() > Length)
       PossibleLeaves.resize(Length);
   }
-  void setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V) {
-    Partitioner = std::move(V);
-  }
+  void setPartitioner(std::unique_ptr<GIMatchTreePartitioner> &&V);
   GIMatchTreePartitioner *getPartitioner() const { return Partitioner.get(); }
 
   std::vector<GIMatchTree>::iterator children_begin() {
@@ -414,18 +412,15 @@ protected:
   void runStep();
 
 public:
-  GIMatchTreeBuilder(unsigned NextInstrID) : NextInstrID(NextInstrID) {}
-  GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID)
-      : TreeNode(TreeNode), NextInstrID(NextInstrID) {}
+  GIMatchTreeBuilder(unsigned NextInstrID);
+  GIMatchTreeBuilder(GIMatchTree *TreeNode, unsigned NextInstrID);
 
   void addLeaf(StringRef Name, unsigned RootIdx, const GIMatchDag &MatchDag,
                void *Data) {
     Leaves.emplace_back(*this, Name, RootIdx, MatchDag, Data);
   }
   void addLeaf(const GIMatchTreeBuilderLeafInfo &L) { Leaves.push_back(L); }
-  void addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P) {
-    Partitioners.push_back(std::move(P));
-  }
+  void addPartitioner(std::unique_ptr<GIMatchTreePartitioner> P);
   void addPartitionersForInstr(unsigned InstrIdx);
   void addPartitionersForOperand(unsigned InstrID, unsigned OpIdx);
 
diff --git a/llvm/utils/TableGen/GlobalISelMatchTable.cpp b/llvm/utils/TableGen/GlobalISelMatchTable.cpp
index aab772f020a6..c570069a2b60 100644
--- a/llvm/utils/TableGen/GlobalISelMatchTable.cpp
+++ b/llvm/utils/TableGen/GlobalISelMatchTable.cpp
@@ -2015,5 +2015,25 @@ void MakeTempRegisterAction::emitActionOpcodes(MatchTable &Table,
         << MatchTable::LineBreak;
 }
 
+std::unique_ptr<PredicateMatcher> GroupMatcher::popFirstCondition() {
+  assert(!Conditions.empty() &&
+       "Trying to pop a condition from a condition-less group");
+  std::unique_ptr<PredicateMatcher> P = std::move(Conditions.front());
+  Conditions.erase(Conditions.begin());
+  return P;
+}
+
+const PredicateMatcher & GroupMatcher::getFirstCondition() const {
+  assert(!Conditions.empty() &&
+         "Trying to get a condition from a condition-less group");
+  return *Conditions.front();
+}
+
+RuleMatcher::RuleMatcher(ArrayRef<SMLoc> SrcLoc)
+  : NextInsnVarID(0), NextOutputInsnID(0), NextTempRegID(0), SrcLoc(SrcLoc),
+  RuleID(NextRuleID++) {}
+
+void RuleMatcher::insnmatchers_pop_front() { Matchers.erase(Matchers.begin()); }
+
 } // namespace gi
 } // namespace llvm
diff --git a/llvm/utils/TableGen/GlobalISelMatchTable.h b/llvm/utils/TableGen/GlobalISelMatchTable.h
index fcb3392226c1..030a5c763cc1 100644
--- a/llvm/utils/TableGen/GlobalISelMatchTable.h
+++ b/llvm/utils/TableGen/GlobalISelMatchTable.h
@@ -48,48 +48,6 @@ class MatchTable;
 class Matcher;
 class OperandMatcher;
 class MatchAction;
-class PredicateMatcher;
-class InstructionMatcher;
-
-enum {
-  GISF_IgnoreCopies = 0x1,
-};
-
-using GISelFlags = std::uint16_t;
-
-//===- Helper functions ---------------------------------------------------===//
-
-std::string getNameForFeatureBitset(const std::vector<Record *> &FeatureBitset);
-
-/// Takes a sequence of \p Rules and group them based on the predicates
-/// they share. \p MatcherStorage is used as a memory container
-/// for the group that are created as part of this process.
-///
-/// What this optimization does looks like if GroupT = GroupMatcher:
-/// Output without optimization:
-/// \verbatim
-/// # R1
-///  # predicate A
-///  # predicate B
-///  ...
-/// # R2
-///  # predicate A // <-- effectively this is going to be checked twice.
-///                //     Once in R1 and once in R2.
-///  # predicate C
-/// \endverbatim
-/// Output with optimization:
-/// \verbatim
-/// # Group1_2
-///  # predicate A // <-- Check is now shared.
-///  # R1
-///   # predicate B
-///  # R2
-///   # predicate C
-/// \endverbatim
-template <class GroupT>
-std::vector<Matcher *>
-optimizeRules(ArrayRef<Matcher *> Rules,
-              std::vector<std::unique_ptr<Matcher>> &MatcherStorage);
 
 /// A record to be stored in a MatchTable.
 ///
@@ -169,6 +127,135 @@ public:
   unsigned size() const { return NumElements; }
 };
 
+class RuleMatcher;
+
+class PredicateMatcher {
+public:
+  /// This enum is used for RTTI and also defines the priority that is given to
+  /// the predicate when generating the matcher code. Kinds with higher priority
+  /// must be tested first.
+  ///
+  /// The relative priority of OPM_LLT, OPM_RegBank, and OPM_MBB do not matter
+  /// but OPM_Int must have priority over OPM_RegBank since constant integers
+  /// are represented by a virtual register defined by a G_CONSTANT instruction.
+  ///
+  /// Note: The relative priority between IPM_ and OPM_ does not matter, they
+  /// are currently not compared between each other.
+  enum PredicateKind {
+    IPM_Opcode,
+    IPM_NumOperands,
+    IPM_ImmPredicate,
+    IPM_Imm,
+    IPM_AtomicOrderingMMO,
+    IPM_MemoryLLTSize,
+    IPM_MemoryVsLLTSize,
+    IPM_MemoryAddressSpace,
+    IPM_MemoryAlignment,
+    IPM_VectorSplatImm,
+    IPM_NoUse,
+    IPM_GenericPredicate,
+    OPM_SameOperand,
+    OPM_ComplexPattern,
+    OPM_IntrinsicID,
+    OPM_CmpPredicate,
+    OPM_Instruction,
+    OPM_Int,
+    OPM_LiteralInt,
+    OPM_LLT,
+    OPM_PointerToAny,
+    OPM_RegBank,
+    OPM_MBB,
+    OPM_RecordNamedOperand,
+  };
+
+protected:
+  PredicateKind Kind;
+  unsigned InsnVarID;
+  unsigned OpIdx;
+
+public:
+  PredicateMatcher(PredicateKind Kind, unsigned InsnVarID, unsigned OpIdx = ~0)
+      : Kind(Kind), InsnVarID(InsnVarID), OpIdx(OpIdx) {}
+  virtual ~PredicateMatcher();
+
+  unsigned getInsnVarID() const { return InsnVarID; }
+  unsigned getOpIdx() const { return OpIdx; }
+
+  /// Emit MatchTable opcodes that check the predicate for the given operand.
+  virtual void emitPredicateOpcodes(MatchTable &Table,
+                                    RuleMatcher &Rule) const = 0;
+
+  PredicateKind getKind() const { return Kind; }
+
+  bool dependsOnOperands() const {
+    // Custom predicates really depend on the context pattern of the
+    // instruction, not just the individual instruction. This therefore
+    // implicitly depends on all other pattern constraints.
+    return Kind == IPM_GenericPredicate;
+  }
+
+  virtual bool isIdentical(const PredicateMatcher &B) const {
+    return B.getKind() == getKind() && InsnVarID == B.InsnVarID &&
+           OpIdx == B.OpIdx;
+  }
+
+  virtual bool isIdenticalDownToValue(const PredicateMatcher &B) const {
+    return hasValue() && PredicateMatcher::isIdentical(B);
+  }
+
+  virtual MatchTableRecord getValue() const {
+    assert(hasValue() && "Can not get a value of a value-less predicate!");
+    llvm_unreachable("Not implemented yet");
+  }
+  virtual bool hasValue() const { return false; }
+
+  /// Report the maximum number of temporary operands needed by the predicate
+  /// matcher.
+  virtual unsigned countRendererFns() const { return 0; }
+};
+
+class InstructionMatcher;
+
+enum {
+  GISF_IgnoreCopies = 0x1,
+};
+
+using GISelFlags = std::uint16_t;
+
+//===- Helper functions ---------------------------------------------------===//
+
+std::string getNameForFeatureBitset(const std::vector<Record *> &FeatureBitset);
+
+/// Takes a sequence of \p Rules and group them based on the predicates
+/// they share. \p MatcherStorage is used as a memory container
+/// for the group that are created as part of this process.
+///
+/// What this optimization does looks like if GroupT = GroupMatcher:
+/// Output without optimization:
+/// \verbatim
+/// # R1
+///  # predicate A
+///  # predicate B
+///  ...
+/// # R2
+///  # predicate A // <-- effectively this is going to be checked twice.
+///                //     Once in R1 and once in R2.
+///  # predicate C
+/// \endverbatim
+/// Output with optimization:
+/// \verbatim
+/// # Group1_2
+///  # predicate A // <-- Check is now shared.
+///  # R1
+///   # predicate B
+///  # R2
+///   # predicate C
+/// \endverbatim
+template <class GroupT>
+std::vector<Matcher *>
+optimizeRules(ArrayRef<Matcher *> Rules,
+              std::vector<std::unique_ptr<Matcher>> &MatcherStorage);
+
 /// Holds the contents of a generated MatchTable to enable formatting and the
 /// necessary index tracking needed to support GIM_Try.
 class MatchTable {
@@ -335,18 +422,8 @@ public:
   size_t size() const { return Matchers.size(); }
   bool empty() const { return Matchers.empty(); }
 
-  std::unique_ptr<PredicateMatcher> popFirstCondition() override {
-    assert(!Conditions.empty() &&
-           "Trying to pop a condition from a condition-less group");
-    std::unique_ptr<PredicateMatcher> P = std::move(Conditions.front());
-    Conditions.erase(Conditions.begin());
-    return P;
-  }
-  const PredicateMatcher &getFirstCondition() const override {
-    assert(!Conditions.empty() &&
-           "Trying to get a condition from a condition-less group");
-    return *Conditions.front();
-  }
+  std::unique_ptr<PredicateMatcher> popFirstCondition() override;
+  const PredicateMatcher &getFirstCondition() const override;
   bool hasFirstCondition() const override { return !Conditions.empty(); }
 
 private:
@@ -486,9 +563,7 @@ protected:
                              StringRef FlagName, GISelFlags FlagBit);
 
 public:
-  RuleMatcher(ArrayRef<SMLoc> SrcLoc)
-      : NextInsnVarID(0), NextOutputInsnID(0), NextTempRegID(0), SrcLoc(SrcLoc),
-        RuleID(NextRuleID++) {}
+  RuleMatcher(ArrayRef<SMLoc> SrcLoc);
   RuleMatcher(RuleMatcher &&Other) = default;
   RuleMatcher &operator=(RuleMatcher &&Other) = default;
 
@@ -618,7 +693,7 @@ public:
     return make_range(Matchers.begin(), Matchers.end());
   }
   bool insnmatchers_empty() const { return Matchers.empty(); }
-  void insnmatchers_pop_front() { Matchers.erase(Matchers.begin()); }
+  void insnmatchers_pop_front();
 };
 
 template <class PredicateTy> class PredicateListMatcher {
@@ -705,91 +780,6 @@ public:
   }
 };
 
-class PredicateMatcher {
-public:
-  /// This enum is used for RTTI and also defines the priority that is given to
-  /// the predicate when generating the matcher code. Kinds with higher priority
-  /// must be tested first.
-  ///
-  /// The relative priority of OPM_LLT, OPM_RegBank, and OPM_MBB do not matter
-  /// but OPM_Int must have priority over OPM_RegBank since constant integers
-  /// are represented by a virtual register defined by a G_CONSTANT instruction.
-  ///
-  /// Note: The relative priority between IPM_ and OPM_ does not matter, they
-  /// are currently not compared between each other.
-  enum PredicateKind {
-    IPM_Opcode,
-    IPM_NumOperands,
-    IPM_ImmPredicate,
-    IPM_Imm,
-    IPM_AtomicOrderingMMO,
-    IPM_MemoryLLTSize,
-    IPM_MemoryVsLLTSize,
-    IPM_MemoryAddressSpace,
-    IPM_MemoryAlignment,
-    IPM_VectorSplatImm,
-    IPM_NoUse,
-    IPM_GenericPredicate,
-    OPM_SameOperand,
-    OPM_ComplexPattern,
-    OPM_IntrinsicID,
-    OPM_CmpPredicate,
-    OPM_Instruction,
-    OPM_Int,
-    OPM_LiteralInt,
-    OPM_LLT,
-    OPM_PointerToAny,
-    OPM_RegBank,
-    OPM_MBB,
-    OPM_RecordNamedOperand,
-  };
-
-protected:
-  PredicateKind Kind;
-  unsigned InsnVarID;
-  unsigned OpIdx;
-
-public:
-  PredicateMatcher(PredicateKind Kind, unsigned InsnVarID, unsigned OpIdx = ~0)
-      : Kind(Kind), InsnVarID(InsnVarID), OpIdx(OpIdx) {}
-  virtual ~PredicateMatcher();
-
-  unsigned getInsnVarID() const { return InsnVarID; }
-  unsigned getOpIdx() const { return OpIdx; }
-
-  /// Emit MatchTable opcodes that check the predicate for the given operand.
-  virtual void emitPredicateOpcodes(MatchTable &Table,
-                                    RuleMatcher &Rule) const = 0;
-
-  PredicateKind getKind() const { return Kind; }
-
-  bool dependsOnOperands() const {
-    // Custom predicates really depend on the context pattern of the
-    // instruction, not just the individual instruction. This therefore
-    // implicitly depends on all other pattern constraints.
-    return Kind == IPM_GenericPredicate;
-  }
-
-  virtual bool isIdentical(const PredicateMatcher &B) const {
-    return B.getKind() == getKind() && InsnVarID == B.InsnVarID &&
-           OpIdx == B.OpIdx;
-  }
-
-  virtual bool isIdenticalDownToValue(const PredicateMatcher &B) const {
-    return hasValue() && PredicateMatcher::isIdentical(B);
-  }
-
-  virtual MatchTableRecord getValue() const {
-    assert(hasValue() && "Can not get a value of a value-less predicate!");
-    llvm_unreachable("Not implemented yet");
-  }
-  virtual bool hasValue() const { return false; }
-
-  /// Report the maximum number of temporary operands needed by the predicate
-  /// matcher.
-  virtual unsigned countRendererFns() const { return 0; }
-};
-
 /// Generates code to check a predicate of an operand.
 ///
 /// Typical predicates include:


diff --git a/llvm/include/llvm/Analysis/AliasAnalysis.h b/llvm/include/llvm/Analysis/AliasAnalysis.h
index 8da8d516499a..d2f6248893b8 100644
--- a/llvm/include/llvm/Analysis/AliasAnalysis.h
+++ b/llvm/include/llvm/Analysis/AliasAnalysis.h
@@ -303,7 +303,7 @@ class AAResults {
 public:
   // Make these results default constructable and movable. We have to spell
   // these out because MSVC won't synthesize them.
-  AAResults(const TargetLibraryInfo &TLI) : TLI(TLI) {}
+  AAResults(const TargetLibraryInfo &TLI);
   AAResults(AAResults &&Arg);
   ~AAResults();
 
diff --git a/llvm/lib/Analysis/AliasAnalysis.cpp b/llvm/lib/Analysis/AliasAnalysis.cpp
index 7b2f91f5392a..d2660d63e296 100644
--- a/llvm/lib/Analysis/AliasAnalysis.cpp
+++ b/llvm/lib/Analysis/AliasAnalysis.cpp
@@ -73,6 +73,7 @@ static cl::opt<bool> EnableAATrace("aa-trace", cl::Hidden, cl::init(false));
 static const bool EnableAATrace = false;
 #endif
 
+AAResults::AAResults(const TargetLibraryInfo &TLI) : TLI(TLI) {}
 AAResults::AAResults(AAResults &&Arg)
     : TLI(Arg.TLI), AAs(std::move(Arg.AAs)), AADeps(std::move(Arg.AADeps)) {}
 
diff --git a/llvm/lib/LTO/LTO.cpp b/llvm/lib/LTO/LTO.cpp
index 6803d6ab1285..af42543f987a 100644
--- a/llvm/lib/LTO/LTO.cpp
+++ b/llvm/lib/LTO/LTO.cpp
@@ -983,9 +983,11 @@ Error LTO::linkRegularLTO(RegularLTOState::AddedModule Mod,
           if (Error Err = F->materialize())
             return Err;
           OptimizationRemarkEmitter ORE(F, nullptr);
-          ORE.emit(OptimizationRemark(DEBUG_TYPE, "deadfunction", F)
+          OptimizationRemark or_instance(DEBUG_TYPE, "deadfunction", F);
+          or_instance
                    << ore::NV("Function", F)
-                   << " not added to the combined module ");
+                   << " not added to the combined module ";
+          ORE.emit(or_instance);
         }
       }
       continue;
@@ -1500,7 +1502,7 @@ public:
     const GVSummaryMapTy &DefinedGlobals =
         ModuleToDefinedGVSummaries.find(ModulePath)->second;
     BackendThreadPool.async(
-        [=](BitcodeModule BM, ModuleSummaryIndex &CombinedIndex,
+        [=, this](BitcodeModule BM, ModuleSummaryIndex &CombinedIndex,
             const FunctionImporter::ImportMapTy &ImportList,
             const FunctionImporter::ExportSetTy &ExportList,
             const std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>


diff --git a/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h b/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
index ea6ed322e9b1..838f23831488 100644
--- a/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
+++ b/llvm/include/llvm/CodeGen/GlobalISel/MIPatternMatch.h
@@ -368,7 +368,7 @@ template <typename Class> struct bind_ty {
 
 inline bind_ty<Register> m_Reg(Register &R) { return R; }
 inline bind_ty<MachineInstr *> m_MInstr(MachineInstr *&MI) { return MI; }
-inline bind_ty<LLT> m_Type(LLT Ty) { return Ty; }
+inline bind_ty<LLT> m_Type(LLT &Ty) { return Ty; }
 inline bind_ty<CmpInst::Predicate> m_Pred(CmpInst::Predicate &P) { return P; }
 inline operand_type_match m_Pred() { return operand_type_match(); }
 


diff --git a/clang/lib/AST/ParentMapContext.cpp b/clang/lib/AST/ParentMapContext.cpp
index 21cfd5b1de6e..f485369fd000 100644
--- a/clang/lib/AST/ParentMapContext.cpp
+++ b/clang/lib/AST/ParentMapContext.cpp
@@ -19,36 +19,6 @@
 
 using namespace clang;
 
-ParentMapContext::ParentMapContext(ASTContext &Ctx) : ASTCtx(Ctx) {}
-
-ParentMapContext::~ParentMapContext() = default;
-
-void ParentMapContext::clear() { Parents.reset(); }
-
-const Expr *ParentMapContext::traverseIgnored(const Expr *E) const {
-  return traverseIgnored(const_cast<Expr *>(E));
-}
-
-Expr *ParentMapContext::traverseIgnored(Expr *E) const {
-  if (!E)
-    return nullptr;
-
-  switch (Traversal) {
-  case TK_AsIs:
-    return E;
-  case TK_IgnoreUnlessSpelledInSource:
-    return E->IgnoreUnlessSpelledInSource();
-  }
-  llvm_unreachable("Invalid Traversal type!");
-}
-
-DynTypedNode ParentMapContext::traverseIgnored(const DynTypedNode &N) const {
-  if (const auto *E = N.get<Expr>()) {
-    return DynTypedNode::create(*traverseIgnored(E));
-  }
-  return N;
-}
-
 template <typename T, typename... U>
 std::tuple<bool, DynTypedNodeList, const T *, const U *...>
 matchParents(const DynTypedNodeList &NodeList,
@@ -265,6 +235,36 @@ public:
   }
 };
 
+ParentMapContext::ParentMapContext(ASTContext &Ctx) : ASTCtx(Ctx) {}
+
+ParentMapContext::~ParentMapContext() = default;
+
+void ParentMapContext::clear() { Parents.reset(); }
+
+const Expr *ParentMapContext::traverseIgnored(const Expr *E) const {
+  return traverseIgnored(const_cast<Expr *>(E));
+}
+
+Expr *ParentMapContext::traverseIgnored(Expr *E) const {
+  if (!E)
+    return nullptr;
+
+  switch (Traversal) {
+  case TK_AsIs:
+    return E;
+  case TK_IgnoreUnlessSpelledInSource:
+    return E->IgnoreUnlessSpelledInSource();
+  }
+  llvm_unreachable("Invalid Traversal type!");
+}
+
+DynTypedNode ParentMapContext::traverseIgnored(const DynTypedNode &N) const {
+  if (const auto *E = N.get<Expr>()) {
+    return DynTypedNode::create(*traverseIgnored(E));
+  }
+  return N;
+}
+
 template <typename T, typename... U> struct MatchParents {
   static std::tuple<bool, DynTypedNodeList, const T *, const U *...>
   match(const DynTypedNodeList &NodeList,


diff --git a/llvm/include/llvm/DWARFLinker/DWARFLinker.h b/llvm/include/llvm/DWARFLinker/DWARFLinker.h
index 5dce990adf02..eaae593c256d 100644
--- a/llvm/include/llvm/DWARFLinker/DWARFLinker.h
+++ b/llvm/include/llvm/DWARFLinker/DWARFLinker.h
@@ -310,17 +310,11 @@ public:
                              const DWARFDie *DIE)>
       messageHandler;
   DWARFLinker(messageHandler ErrorHandler, messageHandler WarningHandler,
-              std::function<StringRef(StringRef)> StringsTranslator)
-      : DwarfLinkerClientID(DwarfLinkerClient::Dsymutil),
-        StringsTranslator(StringsTranslator), ErrorHandler(ErrorHandler),
-        WarningHandler(WarningHandler) {}
+              std::function<StringRef(StringRef)> StringsTranslator);
 
   static std::unique_ptr<DWARFLinker> createLinker(
       messageHandler ErrorHandler, messageHandler WarningHandler,
-      std::function<StringRef(StringRef)> StringsTranslator = nullptr) {
-    return std::make_unique<DWARFLinker>(ErrorHandler, WarningHandler,
-                                         StringsTranslator);
-  }
+      std::function<StringRef(StringRef)> StringsTranslator = nullptr);
 
   /// Type of output file.
   enum class OutputFileType {
diff --git a/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h b/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
index 834cd96b77b4..325882b6e5df 100644
--- a/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
+++ b/llvm/include/llvm/DebugInfo/PDB/Native/InputFile.h
@@ -54,9 +54,9 @@ class InputFile {
   getOrCreateTypeCollection(TypeCollectionKind Kind);
 
 public:
-  InputFile(PDBFile *Pdb) { PdbOrObj = Pdb; }
-  InputFile(object::COFFObjectFile *Obj) { PdbOrObj = Obj; }
-  InputFile(MemoryBuffer *Buffer) { PdbOrObj = Buffer; }
+  InputFile(PDBFile *Pdb);
+  InputFile(object::COFFObjectFile *Obj);
+  InputFile(MemoryBuffer *Buffer);
   ~InputFile();
   InputFile(InputFile &&Other) = default;
 
diff --git a/llvm/lib/DWARFLinker/DWARFLinker.cpp b/llvm/lib/DWARFLinker/DWARFLinker.cpp
index e6eccb20114a..b0259c1e99c7 100644
--- a/llvm/lib/DWARFLinker/DWARFLinker.cpp
+++ b/llvm/lib/DWARFLinker/DWARFLinker.cpp
@@ -7,6 +7,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/DWARFLinker/DWARFLinker.h"
+#include "llvm/DWARFLinker/DWARFStreamer.h"
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/BitVector.h"
 #include "llvm/ADT/STLExtras.h"
@@ -3082,4 +3083,17 @@ Error DWARFLinker::createEmitter(const Triple &TheTriple,
 
 DwarfEmitter *DWARFLinker::getEmitter() { return TheDwarfEmitter.get(); }
 
+DWARFLinker::DWARFLinker(messageHandler ErrorHandler, messageHandler WarningHandler,
+            std::function<StringRef(StringRef)> StringsTranslator)
+    : DwarfLinkerClientID(DwarfLinkerClient::Dsymutil),
+      StringsTranslator(StringsTranslator), ErrorHandler(ErrorHandler),
+      WarningHandler(WarningHandler) {}
+
+std::unique_ptr<DWARFLinker> DWARFLinker::createLinker(
+    messageHandler ErrorHandler, messageHandler WarningHandler,
+    std::function<StringRef(StringRef)> StringsTranslator) {
+  return std::make_unique<DWARFLinker>(ErrorHandler, WarningHandler,
+                                       StringsTranslator);
+}
+
 } // namespace llvm
diff --git a/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp b/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
index 85c22483fa90..2cc6dbc7cc6d 100644
--- a/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
+++ b/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp
@@ -586,3 +586,8 @@ bool llvm::pdb::shouldDumpSymbolGroup(uint32_t Idx, const SymbolGroup &Group,
   // Otherwise, only dump if this is the same module specified.
   return (Filters.DumpModi == Idx);
 }
+
+InputFile::InputFile(PDBFile *Pdb) { PdbOrObj = Pdb; }
+InputFile::InputFile(object::COFFObjectFile *Obj) { PdbOrObj = Obj; }
+InputFile::InputFile(MemoryBuffer *Buffer) { PdbOrObj = Buffer; }
+


# diff --git a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# index a0a360c0a434..ac8be9dc314c 100644
# --- a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# +++ b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
# @@ -510,14 +510,14 @@ class LVPatterns final {
#    template <typename T, typename U>
#    void resolveGenericPatternMatch(T *Element, const U &Requests) {
#      assert(Element && "Element must not be nullptr");
# -    auto CheckPattern = [=]() -> bool {
# +    auto CheckPattern = [=, this]() -> bool {
#        return (Element->isNamed() &&
#                (matchGenericPattern(Element->getName()) ||
#                 matchGenericPattern(Element->getLinkageName()))) ||
#               (Element->isTyped() &&
#                matchGenericPattern(Element->getTypeName()));
#      };
# -    auto CheckOffset = [=]() -> bool {
# +    auto CheckOffset = [=, this]() -> bool {
#        return matchOffsetPattern(Element->getOffset());
#      };
#      if ((options().getSelectGenericPattern() && CheckPattern()) ||
# @@ -530,12 +530,12 @@ class LVPatterns final {
#    template <typename U>
#    void resolveGenericPatternMatch(LVLine *Line, const U &Requests) {
#      assert(Line && "Line must not be nullptr");
# -    auto CheckPattern = [=]() -> bool {
# +    auto CheckPattern = [=, this]() -> bool {
#        return matchGenericPattern(Line->lineNumberAsStringStripped()) ||
#               matchGenericPattern(Line->getName()) ||
#               matchGenericPattern(Line->getPathname());
#      };
# -    auto CheckOffset = [=]() -> bool {
# +    auto CheckOffset = [=, this]() -> bool {
#        return matchOffsetPattern(Line->getAddress());
#      };
#      if ((options().getSelectGenericPattern() && CheckPattern()) ||


diff --git a/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h b/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
index bd63dd875621..c15bc677ae53 100644
--- a/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
+++ b/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
@@ -75,6 +75,7 @@ namespace llvm {
 
   public:
     ResourcePriorityQueue(SelectionDAGISel *IS);
+    ~ResourcePriorityQueue();
 
     bool isBottomUp() const override { return false; }
 
diff --git a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
index a0a360c0a434..ac8be9dc314c 100644
--- a/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
+++ b/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h
@@ -510,14 +510,14 @@ class LVPatterns final {
   template <typename T, typename U>
   void resolveGenericPatternMatch(T *Element, const U &Requests) {
     assert(Element && "Element must not be nullptr");
-    auto CheckPattern = [=]() -> bool {
+    auto CheckPattern = [=, this]() -> bool {
       return (Element->isNamed() &&
               (matchGenericPattern(Element->getName()) ||
                matchGenericPattern(Element->getLinkageName()))) ||
              (Element->isTyped() &&
               matchGenericPattern(Element->getTypeName()));
     };
-    auto CheckOffset = [=]() -> bool {
+    auto CheckOffset = [=, this]() -> bool {
       return matchOffsetPattern(Element->getOffset());
     };
     if ((options().getSelectGenericPattern() && CheckPattern()) ||
@@ -530,12 +530,12 @@ class LVPatterns final {
   template <typename U>
   void resolveGenericPatternMatch(LVLine *Line, const U &Requests) {
     assert(Line && "Line must not be nullptr");
-    auto CheckPattern = [=]() -> bool {
+    auto CheckPattern = [=, this]() -> bool {
       return matchGenericPattern(Line->lineNumberAsStringStripped()) ||
              matchGenericPattern(Line->getName()) ||
              matchGenericPattern(Line->getPathname());
     };
-    auto CheckOffset = [=]() -> bool {
+    auto CheckOffset = [=, this]() -> bool {
       return matchOffsetPattern(Line->getAddress());
     };
     if ((options().getSelectGenericPattern() && CheckPattern()) ||
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
index bfc7f7689718..acd132caba51 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolFunc.h
@@ -69,8 +69,13 @@ public:
   FORWARD_SYMBOL_METHOD(isPureVirtual)
   FORWARD_SYMBOL_METHOD(getRelativeVirtualAddress)
   FORWARD_SYMBOL_METHOD(getToken)
-  FORWARD_CONCRETE_SYMBOL_ID_METHOD_WITH_NAME(PDBSymbolTypeFunctionSig, getType,
-                                              getSignature)
+
+  decltype(auto) getSignatureId() const {
+    return RawSymbol->getTypeId();
+  }
+
+  std::unique_ptr<PDBSymbolTypeFunctionSig> getSignature() const;
+
   FORWARD_SYMBOL_METHOD(isUnalignedType)
   FORWARD_SYMBOL_METHOD(getUndecoratedName)
   FORWARD_SYMBOL_METHOD(isVirtual)
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
index 59d57e83fc10..97e0cffcf8f2 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolFunc.cpp
@@ -79,6 +79,11 @@ private:
 };
 }
 
+std::unique_ptr<PDBSymbolTypeFunctionSig> PDBSymbolFunc::getSignature() const {
+  uint32_t Id = getSignatureId();
+  return getConcreteSymbolByIdHelper<PDBSymbolTypeFunctionSig>(Id);
+}
+
 std::unique_ptr<IPDBEnumChildren<PDBSymbolData>>
 PDBSymbolFunc::getArguments() const {
   return std::make_unique<FunctionArgEnumerator>(Session, *this);
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
index ee1f736c17a0..09b0c1c5db2a 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeEnum.h
@@ -37,13 +37,15 @@ public:
   FORWARD_SYMBOL_ID_METHOD(getLexicalParent)
   FORWARD_SYMBOL_ID_METHOD(getUnmodifiedType)
   FORWARD_SYMBOL_METHOD(getName)
-  FORWARD_SYMBOL_METHOD(getSrcLineOnTypeDefn)
+  decltype(auto) getSrcLineOnTypeDefn() const;
   FORWARD_SYMBOL_METHOD(isNested)
   FORWARD_SYMBOL_METHOD(hasOverloadedOperator)
   FORWARD_SYMBOL_METHOD(isPacked)
   FORWARD_SYMBOL_METHOD(isScoped)
-  FORWARD_CONCRETE_SYMBOL_ID_METHOD_WITH_NAME(PDBSymbolTypeBuiltin, getType,
-                                              getUnderlyingType)
+
+  decltype(auto) getUnderlyingTypeId() const;
+  std::unique_ptr<PDBSymbolTypeBuiltin> getUnderlyingType() const;
+
   FORWARD_SYMBOL_METHOD(isUnalignedType)
   FORWARD_SYMBOL_METHOD(isVolatileType)
 };
diff --git a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
index a3a49a4b619a..d2bfce6a2fda 100644
--- a/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
+++ b/llvm/include/llvm/DebugInfo/PDB/PDBSymbolTypeUDT.h
@@ -35,7 +35,7 @@ public:
   FORWARD_SYMBOL_METHOD(getLength)
   FORWARD_SYMBOL_ID_METHOD(getLexicalParent)
   FORWARD_SYMBOL_METHOD(getName)
-  FORWARD_SYMBOL_METHOD(getSrcLineOnTypeDefn)
+  decltype(auto) getSrcLineOnTypeDefn() const;
   FORWARD_SYMBOL_METHOD(isNested)
   FORWARD_SYMBOL_METHOD(hasOverloadedOperator)
   FORWARD_SYMBOL_METHOD(isPacked)
diff --git a/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp b/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
index e0e8d503ca92..bbdd6313608f 100644
--- a/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp
@@ -63,6 +63,8 @@ ResourcePriorityQueue::ResourcePriorityQueue(SelectionDAGISel *IS)
   HorizontalVerticalBalance = 0;
 }
 
+ResourcePriorityQueue::~ResourcePriorityQueue() {}
+
 unsigned
 ResourcePriorityQueue::numberRCValPredInSU(SUnit *SU, unsigned RCId) {
   unsigned NumberDeps = 0;
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
index db8ca327da1e..297cf766ed8c 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeEnum.cpp
@@ -16,3 +16,13 @@ using namespace llvm;
 using namespace llvm::pdb;
 
 void PDBSymbolTypeEnum::dump(PDBSymDumper &Dumper) const { Dumper.dump(*this); }
+decltype(auto) PDBSymbolTypeEnum::getSrcLineOnTypeDefn() const { return RawSymbol->getSrcLineOnTypeDefn(); }
+
+decltype(auto) PDBSymbolTypeEnum::getUnderlyingTypeId() const {
+  return RawSymbol->getTypeId();
+}
+
+std::unique_ptr<PDBSymbolTypeBuiltin> PDBSymbolTypeEnum::getUnderlyingType() const {
+  uint32_t Id = getUnderlyingTypeId();
+  return getConcreteSymbolByIdHelper<PDBSymbolTypeBuiltin>(Id);
+}
diff --git a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
index 122111d32027..42683907644f 100644
--- a/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
+++ b/llvm/lib/DebugInfo/PDB/PDBSymbolTypeUDT.cpp
@@ -15,3 +15,4 @@ using namespace llvm;
 using namespace llvm::pdb;
 
 void PDBSymbolTypeUDT::dump(PDBSymDumper &Dumper) const { Dumper.dump(*this); }
+decltype(auto) PDBSymbolTypeUDT::getSrcLineOnTypeDefn() const { return RawSymbol->getSrcLineOnTypeDefn(); }
diff --git a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
index 4c3696f9c342..c9bb1bc92ceb 100644
--- a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
+++ b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
@@ -1152,7 +1152,7 @@ IRBuilder<>::InsertPoint OpenMPIRBuilder::createParallel(
   }
 
   OutlineInfo OI;
-  OI.PostOutlineCB = [=](Function &OutlinedFn) {
+  OI.PostOutlineCB = [=, this](Function &OutlinedFn) {
     // Add some known attributes.
     OutlinedFn.addParamAttr(0, Attribute::NoAlias);
     OutlinedFn.addParamAttr(1, Attribute::NoAlias);
@@ -2209,7 +2209,7 @@ CanonicalLoopInfo *OpenMPIRBuilder::createCanonicalLoop(
   Value *TripCount = Builder.CreateSelect(ZeroCmp, Zero, CountIfLooping,
                                           "omp_" + Name + ".tripcount");
 
-  auto BodyGen = [=](InsertPointTy CodeGenIP, Value *IV) {
+  auto BodyGen = [=, this](InsertPointTy CodeGenIP, Value *IV) {
     Builder.restoreIP(CodeGenIP);
     Value *Span = Builder.CreateMul(IV, Step);
     Value *IndVar = Builder.CreateAdd(Span, Start);
diff --git a/llvm/lib/ObjCopy/ELF/ELFObject.cpp b/llvm/lib/ObjCopy/ELF/ELFObject.cpp
index 697afab2a617..0b4ff9a3d051 100644
--- a/llvm/lib/ObjCopy/ELF/ELFObject.cpp
+++ b/llvm/lib/ObjCopy/ELF/ELFObject.cpp
@@ -34,6 +34,8 @@ using namespace llvm::ELF;
 using namespace llvm::objcopy::elf;
 using namespace llvm::object;
 
+Object::Object() {}
+
 template <class ELFT> void ELFWriter<ELFT>::writePhdr(const Segment &Seg) {
   uint8_t *B = reinterpret_cast<uint8_t *>(Buf->getBufferStart()) +
                Obj.ProgramHdrSegment.Offset + Seg.Index * sizeof(Elf_Phdr);
@@ -1237,6 +1239,8 @@ static bool compareSegmentsByOffset(const Segment *A, const Segment *B) {
   return A->Index < B->Index;
 }
 
+BasicELFBuilder::BasicELFBuilder() : Obj(std::make_unique<Object>()) {}
+
 void BasicELFBuilder::initFileHeader() {
   Obj->Flags = 0x0;
   Obj->Type = ET_REL;
@@ -1278,6 +1282,9 @@ Error BasicELFBuilder::initSections() {
   return Error::success();
 }
 
+BinaryELFBuilder::BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility)
+    : MemBuf(MB), NewSymbolVisibility(NewSymbolVisibility) {}
+
 void BinaryELFBuilder::addData(SymbolTableSection *SymTab) {
   auto Data = ArrayRef<uint8_t>(
       reinterpret_cast<const uint8_t *>(MemBuf->getBufferStart()),
@@ -1315,6 +1322,8 @@ Expected<std::unique_ptr<Object>> BinaryELFBuilder::build() {
   return std::move(Obj);
 }
 
+IHexELFBuilder::IHexELFBuilder(const std::vector<IHexRecord> &Records) : Records(Records) {}
+
 // Adds sections from IHEX data file. Data should have been
 // fully validated by this time.
 void IHexELFBuilder::addDataSections() {
diff --git a/llvm/lib/ObjCopy/ELF/ELFObject.h b/llvm/lib/ObjCopy/ELF/ELFObject.h
index 89a03b3fe0ee..5ff1b3fde545 100644
--- a/llvm/lib/ObjCopy/ELF/ELFObject.h
+++ b/llvm/lib/ObjCopy/ELF/ELFObject.h
@@ -928,7 +928,7 @@ protected:
   Error initSections();
 
 public:
-  BasicELFBuilder() : Obj(std::make_unique<Object>()) {}
+  BasicELFBuilder();
 };
 
 class BinaryELFBuilder : public BasicELFBuilder {
@@ -937,8 +937,7 @@ class BinaryELFBuilder : public BasicELFBuilder {
   void addData(SymbolTableSection *SymTab);
 
 public:
-  BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility)
-      : MemBuf(MB), NewSymbolVisibility(NewSymbolVisibility) {}
+  BinaryELFBuilder(MemoryBuffer *MB, uint8_t NewSymbolVisibility);
 
   Expected<std::unique_ptr<Object>> build();
 };
@@ -949,7 +948,7 @@ class IHexELFBuilder : public BasicELFBuilder {
   void addDataSections();
 
 public:
-  IHexELFBuilder(const std::vector<IHexRecord> &Records) : Records(Records) {}
+  IHexELFBuilder(const std::vector<IHexRecord> &Records);
 
   Expected<std::unique_ptr<Object>> build();
 };
@@ -1038,6 +1037,7 @@ private:
   };
 
 public:
+  Object();
   template <class T>
   using ConstRange = iterator_range<pointee_iterator<
       typename std::vector<std::unique_ptr<T>>::const_iterator>>;
diff --git a/llvm/lib/Remarks/BitstreamRemarkParser.cpp b/llvm/lib/Remarks/BitstreamRemarkParser.cpp
index 6dd032f07e72..15b2ea9fad08 100644
--- a/llvm/lib/Remarks/BitstreamRemarkParser.cpp
+++ b/llvm/lib/Remarks/BitstreamRemarkParser.cpp
@@ -342,6 +342,13 @@ Expected<std::unique_ptr<Remark>> BitstreamRemarkParser::next() {
   return parseRemark();
 }
 
+BitstreamRemarkParser::BitstreamRemarkParser(StringRef Buf)
+    : RemarkParser(Format::Bitstream), ParserHelper(Buf) {}
+
+BitstreamRemarkParser::BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab)
+    : RemarkParser(Format::Bitstream), ParserHelper(Buf),
+      StrTab(std::move(StrTab)) {}
+
 Error BitstreamRemarkParser::parseMeta() {
   // Advance and to the meta block.
   if (Error E = advanceToMetaBlock(ParserHelper))
diff --git a/llvm/lib/Remarks/BitstreamRemarkParser.h b/llvm/lib/Remarks/BitstreamRemarkParser.h
index fc786fc57622..08e189c92246 100644
--- a/llvm/lib/Remarks/BitstreamRemarkParser.h
+++ b/llvm/lib/Remarks/BitstreamRemarkParser.h
@@ -45,13 +45,10 @@ struct BitstreamRemarkParser : public RemarkParser {
 
   /// Create a parser that expects to find a string table embedded in the
   /// stream.
-  explicit BitstreamRemarkParser(StringRef Buf)
-      : RemarkParser(Format::Bitstream), ParserHelper(Buf) {}
+  explicit BitstreamRemarkParser(StringRef Buf);
 
   /// Create a parser that uses a pre-parsed string table.
-  BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab)
-      : RemarkParser(Format::Bitstream), ParserHelper(Buf),
-        StrTab(std::move(StrTab)) {}
+  BitstreamRemarkParser(StringRef Buf, ParsedStringTable StrTab);
 
   Expected<std::unique_ptr<Remark>> next() override;
 
diff --git a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
index 3a9a89d61355..d357828962f9 100644
--- a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
+++ b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
@@ -7535,7 +7535,7 @@ struct AAPrivatizablePtrArgument final : public AAPrivatizablePtrImpl {
     // beginning and initialized with the values passed through arguments. The
     // new alloca replaces the use of the old pointer argument.
     Attributor::ArgumentReplacementInfo::CalleeRepairCBTy FnRepairCB =
-        [=](const Attributor::ArgumentReplacementInfo &ARI,
+        [=, this](const Attributor::ArgumentReplacementInfo &ARI,
             Function &ReplacementFn, Function::arg_iterator ArgIt) {
           BasicBlock &EntryBB = ReplacementFn.getEntryBlock();
           Instruction *IP = &*EntryBB.getFirstInsertionPt();
@@ -7559,7 +7559,7 @@ struct AAPrivatizablePtrArgument final : public AAPrivatizablePtrImpl {
     // of the privatizable type are loaded prior to the call and passed to the
     // new function version.
     Attributor::ArgumentReplacementInfo::ACSRepairCBTy ACSRepairCB =
-        [=](const Attributor::ArgumentReplacementInfo &ARI,
+        [=, this](const Attributor::ArgumentReplacementInfo &ARI,
             AbstractCallSite ACS, SmallVectorImpl<Value *> &NewArgOperands) {
           // When no alignment is specified for the load instruction,
           // natural alignment is assumed.


diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
index d7e40e8ef978..946223f6e34d 100644
--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
@@ -1035,9 +1035,8 @@ void reportVectorizationFailure(const StringRef DebugMsg,
                                 Instruction *I) {
   LLVM_DEBUG(debugVectorizationMessage("Not vectorizing: ", DebugMsg, I));
   LoopVectorizeHints Hints(TheLoop, true /* doesn't matter */, *ORE);
-  ORE->emit(
-      createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I)
-      << "loop not vectorized: " << OREMsg);
+  auto lva = createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I);
+  ORE->emit(lva << "loop not vectorized: " << OREMsg);
 }
 
 void reportVectorizationInfo(const StringRef Msg, const StringRef ORETag,
@@ -1045,9 +1044,8 @@ void reportVectorizationInfo(const StringRef Msg, const StringRef ORETag,
                              Instruction *I) {
   LLVM_DEBUG(debugVectorizationMessage("", Msg, I));
   LoopVectorizeHints Hints(TheLoop, true /* doesn't matter */, *ORE);
-  ORE->emit(
-      createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I)
-      << Msg);
+  auto lva = createLVAnalysis(Hints.vectorizeAnalysisPassName(), ORETag, TheLoop, I);
+  ORE->emit(lva << Msg);
 }
 
 } // end namespace llvm
@@ -3071,9 +3069,10 @@ BasicBlock *InnerLoopVectorizer::emitMemRuntimeChecks(BasicBlock *Bypass) {
            "Cannot emit memory checks when optimizing for size, unless forced "
            "to vectorize.");
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationCodeSize",
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationCodeSize",
                                         OrigLoop->getStartLoc(),
-                                        OrigLoop->getHeader())
+                                        OrigLoop->getHeader());
+      return ora_instance
              << "Code-size may be reduced by not forcing "
                 "vectorization, or by source-code modifications "
                 "eliminating the need for runtime checks "
@@ -4997,9 +4996,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
                         << " is unsafe, clamping to max safe VF="
                         << MaxSafeFixedVF << ".\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is unsafe, clamping to maximum safe vectorization factor "
@@ -5013,9 +5013,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
                         << " is ignored because scalable vectors are not "
                            "available.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is ignored because the target does not support scalable "
@@ -5025,9 +5026,10 @@ FixedScalableVFPair LoopVectorizationCostModel::computeFeasibleMaxVF(
       LLVM_DEBUG(dbgs() << "LV: User VF=" << UserVF
                         << " is unsafe. Ignoring scalable UserVF.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "VectorizationFactor",
+        OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "VectorizationFactor",
                                           TheLoop->getStartLoc(),
-                                          TheLoop->getHeader())
+                                          TheLoop->getHeader());
+        return ora_instance
                << "User-specified vectorization factor "
                << ore::NV("UserVectorizationFactor", UserVF)
                << " is unsafe. Ignoring the hint to let the compiler pick a "
@@ -8336,7 +8338,7 @@ VPWidenIntOrFpInductionRecipe *VPRecipeBuilder::tryToOptimizeInductionTruncate(
   // can be optimized.
   auto isOptimizableIVTruncate =
       [&](Instruction *K) -> std::function<bool(ElementCount)> {
-    return [=](ElementCount VF) -> bool {
+    return [=, this](ElementCount VF) -> bool {
       return CM.isOptimizableIVTruncate(K, VF);
     };
   };
@@ -10026,8 +10028,9 @@ static void checkMixedPrecision(Loop *L, OptimizationRemarkEmitter *ORE) {
     // constant or a function return type and point the user to it.
     if (isa<FPExtInst>(I) && EmittedRemark.insert(I).second)
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(LV_NAME, "VectorMixedPrecision",
-                                          I->getDebugLoc(), L->getHeader())
+        OptimizationRemarkAnalysis ora_instance(LV_NAME, "VectorMixedPrecision",
+                                          I->getDebugLoc(), L->getHeader());
+        return ora_instance
                << "floating point conversion changes vector width. "
                << "Mixed floating point precision requires an up/down "
                << "cast that will negatively impact performance.";
@@ -10284,9 +10287,10 @@ bool LoopVectorizePass::processLoop(Loop *L) {
   if (!LVL.canVectorizeFPMath(AllowOrderedReductions)) {
     ORE->emit([&]() {
       auto *ExactFPMathInst = Requirements.getExactFPInst();
-      return OptimizationRemarkAnalysisFPCommute(DEBUG_TYPE, "CantReorderFPOps",
+      OptimizationRemarkAnalysisFPCommute orafpc(DEBUG_TYPE, "CantReorderFPOps",
                                                  ExactFPMathInst->getDebugLoc(),
-                                                 ExactFPMathInst->getParent())
+                                                 ExactFPMathInst->getParent());
+      return orafpc
              << "loop not vectorized: cannot prove it is safe to reorder "
                 "floating-point operations";
     });
@@ -10333,9 +10337,10 @@ bool LoopVectorizePass::processLoop(Loop *L) {
         !areRuntimeChecksProfitable(Checks, VF, getVScaleForTuning(L, *TTI), L,
                                     *PSE.getSE())) {
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysisAliasing(
+        OptimizationRemarkAnalysisAliasing oraa(
                    DEBUG_TYPE, "CantReorderMemOps", L->getStartLoc(),
-                   L->getHeader())
+                   L->getHeader());
+        return oraa
                << "loop not vectorized: cannot prove it is safe to reorder "
                   "memory operations";
       });
@@ -10396,29 +10401,32 @@ bool LoopVectorizePass::processLoop(Loop *L) {
   if (!VectorizeLoop && !InterleaveLoop) {
     // Do not vectorize or interleaving the loop.
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(VAPassName, VecDiagMsg.first,
-                                      L->getStartLoc(), L->getHeader())
+      OptimizationRemarkMissed orm_instance(VAPassName, VecDiagMsg.first,
+                                      L->getStartLoc(), L->getHeader());
+      return orm_instance
              << VecDiagMsg.second;
     });
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(LV_NAME, IntDiagMsg.first,
-                                      L->getStartLoc(), L->getHeader())
-             << IntDiagMsg.second;
+      OptimizationRemarkMissed orm_instance(LV_NAME, IntDiagMsg.first,
+                                      L->getStartLoc(), L->getHeader());
+      return orm_instance << IntDiagMsg.second;
     });
     return false;
   } else if (!VectorizeLoop && InterleaveLoop) {
     LLVM_DEBUG(dbgs() << "LV: Interleave Count is " << IC << '\n');
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(VAPassName, VecDiagMsg.first,
-                                        L->getStartLoc(), L->getHeader())
+      OptimizationRemarkAnalysis ora_instance(VAPassName, VecDiagMsg.first,
+                                        L->getStartLoc(), L->getHeader());
+      return ora_instance
              << VecDiagMsg.second;
     });
   } else if (VectorizeLoop && !InterleaveLoop) {
     LLVM_DEBUG(dbgs() << "LV: Found a vectorizable loop (" << VF.Width
                       << ") in " << DebugLocStr << '\n');
     ORE->emit([&]() {
-      return OptimizationRemarkAnalysis(LV_NAME, IntDiagMsg.first,
-                                        L->getStartLoc(), L->getHeader())
+      OptimizationRemarkAnalysis ora_instance(LV_NAME, IntDiagMsg.first,
+                                        L->getStartLoc(), L->getHeader());
+      return ora_instance
              << IntDiagMsg.second;
     });
   } else if (VectorizeLoop && InterleaveLoop) {
@@ -10442,8 +10450,9 @@ bool LoopVectorizePass::processLoop(Loop *L) {
       LVP.executePlan(VF.Width, IC, BestPlan, Unroller, DT, false);
 
       ORE->emit([&]() {
-        return OptimizationRemark(LV_NAME, "Interleaved", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark or_instance(LV_NAME, "Interleaved", L->getStartLoc(),
+                                  L->getHeader());
+        return or_instance
                << "interleaved loop (interleaved count: "
                << NV("InterleaveCount", IC) << ")";
       });
@@ -10554,8 +10563,9 @@ bool LoopVectorizePass::processLoop(Loop *L) {
       }
       // Report the vectorization decision.
       ORE->emit([&]() {
-        return OptimizationRemark(LV_NAME, "Vectorized", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark or_instance(LV_NAME, "Vectorized", L->getStartLoc(),
+                                  L->getHeader());
+        return or_instance
                << "vectorized loop (vectorization width: "
                << NV("VectorizationFactor", VF.Width)
                << ", interleaved count: " << NV("InterleaveCount", IC) << ")";


diff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
index 821a3fa22a85..62c6ccc27f4b 100644
--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
@@ -7258,7 +7258,7 @@ public:
     if (CommonMask.empty())
       return Cost;
     int Limit = CommonMask.size() * 2;
-    if (all_of(CommonMask, [=](int Idx) { return Idx < Limit; }) &&
+    if (all_of(CommonMask, [=, this](int Idx) { return Idx < Limit; }) &&
         ShuffleVectorInst::isIdentityMask(CommonMask))
       return Cost;
     return Cost +
@@ -7445,7 +7445,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       E->isAltShuffle() ? (unsigned)Instruction::ShuffleVector : E->getOpcode();
   const unsigned Sz = VL.size();
   auto GetCostDiff =
-      [=](function_ref<InstructionCost(unsigned)> ScalarEltCost,
+      [=, this](function_ref<InstructionCost(unsigned)> ScalarEltCost,
           function_ref<InstructionCost(InstructionCost)> VectorCost) {
         // Calculate the cost of this instruction.
         InstructionCost ScalarCost = 0;
@@ -7466,7 +7466,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       };
   // Calculate cost difference from vectorizing set of GEPs.
   // Negative value means vectorizing is profitable.
-  auto GetGEPCostDiff = [=](ArrayRef<Value *> Ptrs, Value *BasePtr) {
+  auto GetGEPCostDiff = [=, this](ArrayRef<Value *> Ptrs, Value *BasePtr) {
     InstructionCost ScalarCost = 0;
     InstructionCost VecCost = 0;
     // Here we differentiate two cases: (1) when Ptrs represent a regular
@@ -7571,7 +7571,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   }
   case Instruction::ExtractValue:
   case Instruction::ExtractElement: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *I = cast<Instruction>(VL[Idx]);
       VectorType *SrcVecTy;
       if (ShuffleOrOp == Instruction::ExtractElement) {
@@ -7729,13 +7729,13 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   case Instruction::Trunc:
   case Instruction::FPTrunc:
   case Instruction::BitCast: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       return TTI->getCastInstrCost(E->getOpcode(), ScalarTy,
                                    VI->getOperand(0)->getType(),
                                    TTI::getCastContextHint(VI), CostKind, VI);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       Type *SrcTy = VL0->getOperand(0)->getType();
       auto *SrcVecTy = FixedVectorType::get(SrcTy, VL.size());
       InstructionCost VecCost = CommonCost;
@@ -7821,7 +7821,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   case Instruction::And:
   case Instruction::Or:
   case Instruction::Xor: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       unsigned OpIdx = isa<UnaryOperator>(VI) ? 0 : 1;
       TTI::OperandValueInfo Op1Info = TTI::getOperandInfo(VI->getOperand(0));
@@ -7831,7 +7831,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       return TTI->getArithmeticInstrCost(ShuffleOrOp, ScalarTy, CostKind,
                                          Op1Info, Op2Info, Operands, VI);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       unsigned OpIdx = isa<UnaryOperator>(VL0) ? 0 : 1;
       TTI::OperandValueInfo Op1Info = getOperandInfo(VL, 0);
       TTI::OperandValueInfo Op2Info = getOperandInfo(VL, OpIdx);
@@ -7845,14 +7845,14 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
     return CommonCost + GetGEPCostDiff(VL, VL0);
   }
   case Instruction::Load: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<LoadInst>(VL[Idx]);
       return TTI->getMemoryOpCost(Instruction::Load, ScalarTy, VI->getAlign(),
                                   VI->getPointerAddressSpace(), CostKind,
                                   TTI::OperandValueInfo(), VI);
     };
     auto *LI0 = cast<LoadInst>(VL0);
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       InstructionCost VecLdCost;
       if (E->State == TreeEntry::Vectorize) {
         VecLdCost = TTI->getMemoryOpCost(
@@ -7885,7 +7885,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
   }
   case Instruction::Store: {
     bool IsReorder = !E->ReorderIndices.empty();
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<StoreInst>(VL[Idx]);
       TTI::OperandValueInfo OpInfo = getOperandInfo(VI, 0);
       return TTI->getMemoryOpCost(Instruction::Store, ScalarTy, VI->getAlign(),
@@ -7894,7 +7894,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
     };
     auto *BaseSI =
         cast<StoreInst>(IsReorder ? VL[E->ReorderIndices.front()] : VL0);
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       // We know that we can merge the stores. Calculate the cost.
       TTI::OperandValueInfo OpInfo = getOperandInfo(VL, 0);
       return TTI->getMemoryOpCost(Instruction::Store, VecTy, BaseSI->getAlign(),
@@ -7912,7 +7912,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
            GetGEPCostDiff(PointerOps, BaseSI->getPointerOperand());
   }
   case Instruction::Call: {
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *CI = cast<CallInst>(VL[Idx]);
       Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);
       if (ID != Intrinsic::not_intrinsic) {
@@ -7923,7 +7923,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
                                    CI->getFunctionType()->getReturnType(),
                                    CI->getFunctionType()->params(), CostKind);
     };
-    auto GetVectorCost = [=](InstructionCost CommonCost) {
+    auto GetVectorCost = [=, this](InstructionCost CommonCost) {
       auto *CI = cast<CallInst>(VL0);
       auto VecCallCosts = getVectorCallCosts(CI, VecTy, TTI, TLI);
       return std::min(VecCallCosts.first, VecCallCosts.second) + CommonCost;
@@ -7940,7 +7940,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
            "Invalid Shuffle Vector Operand");
     // Try to find the previous shuffle node with the same operands and same
     // main/alternate ops.
-    auto TryFindNodeWithEqualOperands = [=]() {
+    auto TryFindNodeWithEqualOperands = [=, this]() {
       for (const std::unique_ptr<TreeEntry> &TE : VectorizableTree) {
         if (TE.get() == E)
           break;
@@ -7954,7 +7954,7 @@ BoUpSLP::getEntryCost(const TreeEntry *E, ArrayRef<Value *> VectorizedVals,
       }
       return false;
     };
-    auto GetScalarCost = [=](unsigned Idx) {
+    auto GetScalarCost = [=, this](unsigned Idx) {
       auto *VI = cast<Instruction>(VL[Idx]);
       assert(E->isOpcodeOrAlt(VI) && "Unexpected main/alternate opcode");
       (void)E;
@@ -8835,7 +8835,7 @@ BoUpSLP::isGatherShuffledEntry(const TreeEntry *TE, ArrayRef<Value *> VL,
       return TE1->Idx < TE2->Idx;
     });
     // Try to find the perfect match in another gather node at first.
-    auto *It = find_if(FirstEntries, [=](const TreeEntry *EntryPtr) {
+    auto *It = find_if(FirstEntries, [=, this](const TreeEntry *EntryPtr) {
       return EntryPtr->isSame(VL) || EntryPtr->isSame(TE->Scalars);
     });
     if (It != FirstEntries.end() && (*It)->getVectorFactor() == VL.size()) {
@@ -8921,7 +8921,7 @@ BoUpSLP::isGatherShuffledEntry(const TreeEntry *TE, ArrayRef<Value *> VL,
   // We suppose it is better to ignore instruction, which do not form splats,
   // are not vectorized/not extractelements (these instructions will be handled
   // by extractelements processing) or may form vector node in future.
-  auto MightBeIgnored = [=](Value *V) {
+  auto MightBeIgnored = [=, this](Value *V) {
     auto *I = dyn_cast<Instruction>(V);
     SmallVector<Value *> IgnoredVals;
     if (UserIgnoreList)
@@ -9082,7 +9082,7 @@ Instruction &BoUpSLP::getLastInstructionInBundle(const TreeEntry *E) {
   // constant indeces).
   auto *Front = E->getMainOp();
   auto *BB = Front->getParent();
-  assert(llvm::all_of(E->Scalars, [=](Value *V) -> bool {
+  assert(llvm::all_of(E->Scalars, [=, this](Value *V) -> bool {
     if (E->getOpcode() == Instruction::GetElementPtr &&
         !isa<GetElementPtrInst>(V))
       return true;
@@ -9775,8 +9775,8 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Args &...Params) {
     if (UserTE->getNumOperands() != 2)
       return false;
     auto *It =
-        find_if(VectorizableTree, [=](const std::unique_ptr<TreeEntry> &TE) {
-          return find_if(TE->UserTreeIndices, [=](const EdgeInfo &EI) {
+        find_if(VectorizableTree, [=, this](const std::unique_ptr<TreeEntry> &TE) {
+          return find_if(TE->UserTreeIndices, [=, this](const EdgeInfo &EI) {
                    return EI.UserTE == UserTE && EI.EdgeIdx != EdgeIdx;
                  }) != TE->UserTreeIndices.end();
         });
@@ -10067,7 +10067,7 @@ ResTy BoUpSLP::processBuildVector(const TreeEntry *E, Args &...Params) {
       Value *BV = ShuffleBuilder.gather(GatheredScalars);
       ShuffleBuilder.add(BV, BVMask);
     }
-    if (all_of(NonConstants, [=](Value *V) {
+    if (all_of(NonConstants, [=, this](Value *V) {
           return isa<PoisonValue>(V) ||
                  (IsSingleShuffle && ((IsIdentityShuffle &&
                   IsNonPoisoned) || IsUsedInExpr) && isa<UndefValue>(V));
@@ -12326,9 +12326,9 @@ bool SLPVectorizerPass::vectorizeStoreChain(ArrayRef<Value *> Chain, BoUpSLP &R,
     LLVM_DEBUG(dbgs() << "SLP: Decided to vectorize cost = " << Cost << "\n");
 
     using namespace ore;
-
-    R.getORE()->emit(OptimizationRemark(SV_NAME, "StoresVectorized",
-                                        cast<StoreInst>(Chain[0]))
+    OptimizationRemark or_instance(SV_NAME, "StoresVectorized",
+                                        cast<StoreInst>(Chain[0]));
+    R.getORE()->emit(or_instance
                      << "Stores SLP vectorized with cost " << NV("Cost", Cost)
                      << " and with tree size "
                      << NV("TreeSize", R.getTreeSize()));
@@ -12544,7 +12544,8 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
         std::string type_str;
         llvm::raw_string_ostream rso(type_str);
         Ty->print(rso);
-        return OptimizationRemarkMissed(SV_NAME, "UnsupportedType", I0)
+        OptimizationRemarkMissed orm_instance(SV_NAME, "UnsupportedType", I0);
+        return orm_instance
                << "Cannot SLP vectorize list: type "
                << rso.str() + " is unsupported by vectorizer";
       });
@@ -12558,7 +12559,8 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
   MaxVF = std::min(R.getMaximumVF(Sz, S.getOpcode()), MaxVF);
   if (MaxVF < 2) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "SmallVF", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "SmallVF", I0);
+      return orm_instance
              << "Cannot SLP vectorize list: vectorization factor "
              << "less than 2 is not supported";
     });
@@ -12620,8 +12622,9 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
                         << " for VF=" << ActualVF << "\n");
       if (Cost < -SLPCostThreshold) {
         LLVM_DEBUG(dbgs() << "SLP: Vectorizing list at cost:" << Cost << ".\n");
-        R.getORE()->emit(OptimizationRemark(SV_NAME, "VectorizedList",
-                                                    cast<Instruction>(Ops[0]))
+        OptimizationRemark or_instance(SV_NAME, "VectorizedList",
+                                                    cast<Instruction>(Ops[0]));
+        R.getORE()->emit(or_instance
                                  << "SLP vectorized with cost " << ore::NV("Cost", Cost)
                                  << " and with tree size "
                                  << ore::NV("TreeSize", R.getTreeSize()));
@@ -12637,14 +12640,16 @@ bool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,
 
   if (!Changed && CandidateFound) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "NotBeneficial", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "NotBeneficial", I0);
+      return orm_instance
              << "List vectorization was possible but not beneficial with cost "
              << ore::NV("Cost", MinCost) << " >= "
              << ore::NV("Treshold", -SLPCostThreshold);
     });
   } else if (!Changed) {
     R.getORE()->emit([&]() {
-      return OptimizationRemarkMissed(SV_NAME, "NotPossible", I0)
+      OptimizationRemarkMissed orm_instance(SV_NAME, "NotPossible", I0);
+      return orm_instance
              << "Cannot SLP vectorize list: vectorization was impossible"
              << " with available vectorization factors";
     });
@@ -13609,9 +13614,10 @@ public:
           return nullptr;
         if (Cost >= -SLPCostThreshold) {
           V.getORE()->emit([&]() {
-            return OptimizationRemarkMissed(
+            OptimizationRemarkMissed orm_instance(
                        SV_NAME, "HorSLPNotBeneficial",
-                       ReducedValsToOps.find(VL[0])->second.front())
+                       ReducedValsToOps.find(VL[0])->second.front());
+            return orm_instance
                    << "Vectorizing horizontal reduction is possible "
                    << "but not beneficial with cost " << ore::NV("Cost", Cost)
                    << " and threshold "
@@ -13625,9 +13631,10 @@ public:
         LLVM_DEBUG(dbgs() << "SLP: Vectorizing horizontal reduction at cost:"
                           << Cost << ". (HorRdx)\n");
         V.getORE()->emit([&]() {
-          return OptimizationRemark(
+          OptimizationRemark or_instance(
                      SV_NAME, "VectorizedHorizontalReduction",
-                     ReducedValsToOps.find(VL[0])->second.front())
+                     ReducedValsToOps.find(VL[0])->second.front());
+          return or_instance
                  << "Vectorized horizontal reduction with cost "
                  << ore::NV("Cost", Cost) << " and with tree size "
                  << ore::NV("TreeSize", V.getTreeSize());


diff --git a/llvm/lib/CodeGen/StackProtector.cpp b/llvm/lib/CodeGen/StackProtector.cpp
index 387b653f8815..70c527969a8b 100644
--- a/llvm/lib/CodeGen/StackProtector.cpp
+++ b/llvm/lib/CodeGen/StackProtector.cpp
@@ -310,7 +310,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
     if (!Layout)
       return true;
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "StackProtectorRequested", F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorRequested", F);
+      return or_instance
              << "Stack protection applied to function "
              << ore::NV("Function", F)
              << " due to a function attribute or command-line switch";
@@ -327,8 +328,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
       if (const AllocaInst *AI = dyn_cast<AllocaInst>(&I)) {
         if (AI->isArrayAllocation()) {
           auto RemarkBuilder = [&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorAllocaOrArray",
-                                      &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorAllocaOrArray", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to a call to alloca or use of a variable length "
@@ -374,7 +375,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
               AI, IsLarge ? MachineFrameInfo::SSPLK_LargeArray
                           : MachineFrameInfo::SSPLK_SmallArray));
           ORE.emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorBuffer", &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorBuffer", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to a stack allocated buffer or struct containing a "
@@ -393,8 +395,8 @@ bool StackProtector::requiresStackProtector(Function *F, SSPLayoutMap *Layout) {
             return true;
           Layout->insert(std::make_pair(AI, MachineFrameInfo::SSPLK_AddrOf));
           ORE.emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "StackProtectorAddressTaken",
-                                      &I)
+            OptimizationRemark or_instance(DEBUG_TYPE, "StackProtectorAddressTaken", &I);
+            return or_instance
                    << "Stack protection applied to function "
                    << ore::NV("Function", F)
                    << " due to the address of a local variable being taken";


diff --git a/llvm/lib/CodeGen/ShrinkWrap.cpp b/llvm/lib/CodeGen/ShrinkWrap.cpp
index 4b1d3637a746..052d41be2075 100644
--- a/llvm/lib/CodeGen/ShrinkWrap.cpp
+++ b/llvm/lib/CodeGen/ShrinkWrap.cpp
@@ -804,7 +804,8 @@ static bool giveUpWithRemarks(MachineOptimizationRemarkEmitter *ORE,
                               const DiagnosticLocation &Loc,
                               const MachineBasicBlock *MBB) {
   ORE->emit([&]() {
-    return MachineOptimizationRemarkMissed(DEBUG_TYPE, RemarkName, Loc, MBB)
+    MachineOptimizationRemarkMissed morm_instance(DEBUG_TYPE, RemarkName, Loc, MBB);
+    return morm_instance
            << RemarkMessage;
   });
 

diff --git a/llvm/lib/CodeGen/PrologEpilogInserter.cpp b/llvm/lib/CodeGen/PrologEpilogInserter.cpp
index e323aaaeefaf..ef4aab48bf15 100644
--- a/llvm/lib/CodeGen/PrologEpilogInserter.cpp
+++ b/llvm/lib/CodeGen/PrologEpilogInserter.cpp
@@ -326,9 +326,10 @@ bool PEI::runOnMachineFunction(MachineFunction &MF) {
   }
 
   ORE->emit([&]() {
-    return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "StackSize",
+    MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "StackSize",
                                              MF.getFunction().getSubprogram(),
-                                             &MF.front())
+                                             &MF.front());
+    return mora_instance
            << ore::NV("NumStackBytes", StackSize) << " stack bytes in function";
   });
 


diff --git a/llvm/lib/CodeGen/MachinePipeliner.cpp b/llvm/lib/CodeGen/MachinePipeliner.cpp
index c7e7497dab36..63aaa04c5d98 100644
--- a/llvm/lib/CodeGen/MachinePipeliner.cpp
+++ b/llvm/lib/CodeGen/MachinePipeliner.cpp
@@ -264,9 +264,9 @@ bool MachinePipeliner::scheduleLoop(MachineLoop &L) {
   if (!canPipelineLoop(L)) {
     LLVM_DEBUG(dbgs() << "\n!!! Can not pipeline loop.\n");
     ORE->emit([&]() {
-      return MachineOptimizationRemarkMissed(DEBUG_TYPE, "canPipelineLoop",
-                                             L.getStartLoc(), L.getHeader())
-             << "Failed to pipeline loop";
+      MachineOptimizationRemarkMissed morm_instance(DEBUG_TYPE, "canPipelineLoop",
+                                             L.getStartLoc(), L.getHeader());
+      return morm_instance << "Failed to pipeline loop";
     });
 
     LI.LoopPipelinerInfo.reset();
@@ -335,9 +335,9 @@ void MachinePipeliner::setPragmaPipelineOptions(MachineLoop &L) {
 bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
   if (L.getNumBlocks() != 1) {
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "Not a single basic block: "
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "Not a single basic block: "
              << ore::NV("NumBlocks", L.getNumBlocks());
     });
     return false;
@@ -345,9 +345,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
 
   if (disabledByPragma) {
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "Disabled by Pragma.";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "Disabled by Pragma.";
     });
     return false;
   }
@@ -361,9 +361,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Unable to analyzeBranch, can NOT pipeline Loop\n");
     NumFailBranch++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "The branch can't be understood";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "The branch can't be understood";
     });
     return false;
   }
@@ -375,9 +375,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Unable to analyzeLoop, can NOT pipeline Loop\n");
     NumFailLoop++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "The loop structure is not supported";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "The loop structure is not supported";
     });
     return false;
   }
@@ -386,9 +386,9 @@ bool MachinePipeliner::canPipelineLoop(MachineLoop &L) {
     LLVM_DEBUG(dbgs() << "Preheader not found, can NOT pipeline Loop\n");
     NumFailPreheader++;
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(DEBUG_TYPE, "canPipelineLoop",
-                                               L.getStartLoc(), L.getHeader())
-             << "No loop preheader found";
+      MachineOptimizationRemarkAnalysis mora_instance(DEBUG_TYPE, "canPipelineLoop",
+                                               L.getStartLoc(), L.getHeader());
+      return mora_instance << "No loop preheader found";
     });
     return false;
   }
@@ -524,9 +524,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "Invalid Minimal Initiation Interval: 0\n");
     NumFailZeroMII++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Invalid Minimal Initiation Interval: 0";
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Invalid Minimal Initiation Interval: 0";
     });
     return;
   }
@@ -537,9 +537,9 @@ void SwingSchedulerDAG::schedule() {
                       << ", we don't pipeline large loops\n");
     NumFailLargeMaxMII++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Minimal Initiation Interval too large: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Minimal Initiation Interval too large: "
              << ore::NV("MII", (int)MII) << " > "
              << ore::NV("SwpMaxMii", SwpMaxMii) << "."
              << "Refer to -pipeliner-max-mii.";
@@ -587,9 +587,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "No schedule found, return\n");
     NumFailNoSchedule++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Unable to find schedule";
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Unable to find schedule";
     });
     return;
   }
@@ -600,8 +600,9 @@ void SwingSchedulerDAG::schedule() {
     LLVM_DEBUG(dbgs() << "No overlapped iterations, skip.\n");
     NumFailZeroStage++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance
              << "No need to pipeline - no overlapped iterations in schedule.";
     });
     return;
@@ -612,9 +613,9 @@ void SwingSchedulerDAG::schedule() {
                       << " : too many stages, abort\n");
     NumFailLargeMaxStage++;
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Too many stages in schedule: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Too many stages in schedule: "
              << ore::NV("numStages", (int)numStages) << " > "
              << ore::NV("SwpMaxStages", SwpMaxStages)
              << ". Refer to -pipeliner-max-stages.";
@@ -623,9 +624,9 @@ void SwingSchedulerDAG::schedule() {
   }
 
   Pass.ORE->emit([&]() {
-    return MachineOptimizationRemark(DEBUG_TYPE, "schedule", Loop.getStartLoc(),
-                                     Loop.getHeader())
-           << "Pipelined succesfully!";
+    MachineOptimizationRemark mor_instance(DEBUG_TYPE, "schedule", Loop.getStartLoc(),
+                                     Loop.getHeader());
+    return mor_instance << "Pipelined succesfully!";
   });
 
   // Generate the schedule as a ModuloSchedule.
@@ -2059,9 +2060,9 @@ bool SwingSchedulerDAG::schedulePipeline(SMSchedule &Schedule) {
   if (scheduleFound) {
     Schedule.finalizeSchedule(this);
     Pass.ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(
-                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader())
-             << "Schedule found with Initiation Interval: "
+      MachineOptimizationRemarkAnalysis mora_instance(
+                 DEBUG_TYPE, "schedule", Loop.getStartLoc(), Loop.getHeader());
+      return mora_instance << "Schedule found with Initiation Interval: "
              << ore::NV("II", Schedule.getInitiationInterval())
              << ", MaxStageCount: "
              << ore::NV("MaxStageCount", Schedule.getMaxStageCount());


diff --git a/llvm/include/llvm/CodeGen/BasicTTIImpl.h b/llvm/include/llvm/CodeGen/BasicTTIImpl.h
index 383fdd1f4d79..3af245731700 100644
--- a/llvm/include/llvm/CodeGen/BasicTTIImpl.h
+++ b/llvm/include/llvm/CodeGen/BasicTTIImpl.h
@@ -590,8 +590,9 @@ public:
 
           if (ORE) {
             ORE->emit([&]() {
-              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),
-                                        L->getHeader())
+              OptimizationRemark or_instance("TTI", "DontUnroll", L->getStartLoc(),
+                                        L->getHeader());
+              return or_instance
                      << "advising against unrolling the loop because it "
                         "contains a "
                      << ore::NV("Call", &I);


diff --git a/llvm/lib/CodeGen/HardwareLoops.cpp b/llvm/lib/CodeGen/HardwareLoops.cpp
index e7b14d700a44..4d82bdcbee44 100644
--- a/llvm/lib/CodeGen/HardwareLoops.cpp
+++ b/llvm/lib/CodeGen/HardwareLoops.cpp
@@ -112,7 +112,8 @@ namespace {
   void reportHWLoopFailure(const StringRef Msg, const StringRef ORETag,
       OptimizationRemarkEmitter *ORE, Loop *TheLoop, Instruction *I = nullptr) {
     LLVM_DEBUG(debugHWLoopFailure(Msg, I));
-    ORE->emit(createHWLoopAnalysis(ORETag, TheLoop, I) << Msg);
+    auto hwla_instance = createHWLoopAnalysis(ORETag, TheLoop, I);
+    ORE->emit(hwla_instance << Msg);
   }
 
   using TTI = TargetTransformInfo;
diff --git a/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp b/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
index d0ad6e45b4d3..6e6e361cdd7d 100644
--- a/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
+++ b/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp
@@ -1243,8 +1243,8 @@ bool InterleavedLoadCombineImpl::combine(std::list<VectorInfo> &InterleavedLoad,
 
   NumInterleavedLoadCombine++;
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Combined Interleaved Load", LI)
-           << "Load interleaved combined with factor "
+    OptimizationRemark or_instance(DEBUG_TYPE, "Combined Interleaved Load", LI);
+    return or_instance << "Load interleaved combined with factor "
            << ore::NV("Factor", Factor);
   });
 

diff --git a/llvm/lib/CodeGen/AtomicExpandPass.cpp b/llvm/lib/CodeGen/AtomicExpandPass.cpp
index 80a0bb957cfc..dcf5b9584cf9 100644
--- a/llvm/lib/CodeGen/AtomicExpandPass.cpp
+++ b/llvm/lib/CodeGen/AtomicExpandPass.cpp
@@ -605,7 +605,8 @@ bool AtomicExpand::tryExpandAtomicRMW(AtomicRMWInst *AI) {
                           : SSNs[AI->getSyncScopeID()];
       OptimizationRemarkEmitter ORE(AI->getFunction());
       ORE.emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "Passed", AI)
+        OptimizationRemark or_instance(DEBUG_TYPE, "Passed", AI);
+        return or_instance
                << "A compare and swap loop was generated for an atomic "
                << AI->getOperationName(AI->getOperation()) << " operation at "
                << MemScope << " memory scope";


diff --git a/llvm/lib/Analysis/MLInlineAdvisor.cpp b/llvm/lib/Analysis/MLInlineAdvisor.cpp
index 0660a9993b6d..ad7e3a465039 100644
--- a/llvm/lib/Analysis/MLInlineAdvisor.cpp
+++ b/llvm/lib/Analysis/MLInlineAdvisor.cpp
@@ -345,7 +345,8 @@ std::unique_ptr<InlineAdvice> MLInlineAdvisor::getAdviceImpl(CallBase &CB) {
   // we just return the base InlineAdvice, which acts as a noop.
   if (ForceStop) {
     ORE.emit([&] {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ForceStop", &CB)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ForceStop", &CB);
+      return orm_instance
              << "Won't attempt inlining because module size grew too much.";
     });
     return std::make_unique<InlineAdvice>(this, CB, ORE, Mandatory);


diff --git a/llvm/lib/Analysis/InlineAdvisor.cpp b/llvm/lib/Analysis/InlineAdvisor.cpp
index e2480d51d372..55aee48ffeee 100644
--- a/llvm/lib/Analysis/InlineAdvisor.cpp
+++ b/llvm/lib/Analysis/InlineAdvisor.cpp
@@ -89,8 +89,9 @@ private:
   void recordUnsuccessfulInliningImpl(const InlineResult &Result) override {
     if (IsInliningRecommended)
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(Advisor->getAnnotatedInlinePassName(),
-                                        "NotInlined", DLoc, Block)
+        OptimizationRemarkMissed orm_instance(Advisor->getAnnotatedInlinePassName(),
+                                        "NotInlined", DLoc, Block);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' is not AlwaysInline into '"
                << NV("Caller", Caller)
                << "': " << NV("Reason", Result.getFailureReason());
@@ -109,8 +110,9 @@ void DefaultInlineAdvice::recordUnsuccessfulInliningImpl(
   llvm::setInlineRemark(*OriginalCB, std::string(Result.getFailureReason()) +
                                          "; " + inlineCostStr(*OIC));
   ORE.emit([&]() {
-    return OptimizationRemarkMissed(Advisor->getAnnotatedInlinePassName(),
-                                    "NotInlined", DLoc, Block)
+    OptimizationRemarkMissed orm_instance(Advisor->getAnnotatedInlinePassName(),
+                                    "NotInlined", DLoc, Block);
+    return orm_instance
            << "'" << NV("Callee", Callee) << "' is not inlined into '"
            << NV("Caller", Caller)
            << "': " << NV("Reason", Result.getFailureReason());
@@ -394,14 +396,16 @@ llvm::shouldInline(CallBase &CB,
                       << ", Call: " << CB << "\n");
     if (IC.isNever()) {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline", Call)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline", Call);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' not inlined into '"
                << NV("Caller", Caller)
                << "' because it should never be inlined " << IC;
       });
     } else {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "TooCostly", Call)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "TooCostly", Call);
+        return orm_instance
                << "'" << NV("Callee", Callee) << "' not inlined into '"
                << NV("Caller", Caller) << "' because too costly to inline "
                << IC;
@@ -418,8 +422,9 @@ llvm::shouldInline(CallBase &CB,
                       << " Cost = " << IC.getCost()
                       << ", outer Cost = " << TotalSecondaryCost << '\n');
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IncreaseCostInOtherContexts",
-                                      Call)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "IncreaseCostInOtherContexts",
+                                      Call);
+      return orm_instance
              << "Not inlining. Cost of inlining '" << NV("Callee", Callee)
              << "' increases the cost of inlining '" << NV("Caller", Caller)
              << "' in other contexts";


diff --git a/llvm/lib/Analysis/InlineCost.cpp b/llvm/lib/Analysis/InlineCost.cpp
index 9ff277f5334e..18b7909983bf 100644
--- a/llvm/lib/Analysis/InlineCost.cpp
+++ b/llvm/lib/Analysis/InlineCost.cpp
@@ -2511,8 +2511,9 @@ CallAnalyzer::analyzeBlock(BasicBlock *BB,
     if (!IR.isSuccess()) {
       if (ORE)
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline",
-                                          &CandidateCall)
+          OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline",
+                                          &CandidateCall);
+          return orm_instance
                  << NV("Callee", &F) << " has uninlinable pattern ("
                  << NV("InlineResult", IR.getFailureReason())
                  << ") and cost is not fully computed";
@@ -2528,8 +2529,9 @@ CallAnalyzer::analyzeBlock(BasicBlock *BB,
           InlineResult::failure("recursive and allocates too much stack space");
       if (ORE)
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline",
-                                          &CandidateCall)
+          OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline",
+                                          &CandidateCall);
+          return orm_instance
                  << NV("Callee", &F) << " is "
                  << NV("InlineResult", IR.getFailureReason())
                  << ". Cost is not fully computed";


diff --git a/llvm/lib/Transforms/Coroutines/CoroElide.cpp b/llvm/lib/Transforms/Coroutines/CoroElide.cpp
index d78ab1c1ea28..f2ab0a9ae336 100644
--- a/llvm/lib/Transforms/Coroutines/CoroElide.cpp
+++ b/llvm/lib/Transforms/Coroutines/CoroElide.cpp
@@ -347,9 +347,10 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
   bool ShouldElide = shouldElide(CoroId->getFunction(), DT);
   if (!ShouldElide)
     ORE.emit([&]() {
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "CoroElide", CoroId);
       if (auto FrameSizeAndAlign =
               getFrameLayout(cast<Function>(ResumeAddrConstant)))
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -357,7 +358,7 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
                << ore::NV("frame_size", FrameSizeAndAlign->first) << ", align="
                << ore::NV("align", FrameSizeAndAlign->second.value()) << ")";
       else
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -384,7 +385,8 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
             << CoroId->getFunction()->getName() << "\n";
 #endif
       ORE.emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "CoroElide", CoroId)
+        OptimizationRemark or_instance(DEBUG_TYPE, "CoroElide", CoroId);
+        return or_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())
@@ -394,7 +396,8 @@ bool Lowerer::processCoroId(CoroIdInst *CoroId, AAResults &AA,
       });
     } else {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CoroElide", CoroId)
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "CoroElide", CoroId);
+        return orm_instance
                << "'" << ore::NV("callee", CoroId->getCoroutine()->getName())
                << "' not elided in '"
                << ore::NV("caller", CoroId->getFunction()->getName())


diff --git a/llvm/lib/Transforms/Coroutines/CoroSplit.cpp b/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
index 39e909bf3316..589685dad85b 100644
--- a/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
+++ b/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
@@ -2152,7 +2152,8 @@ PreservedAnalyses CoroSplitPass::run(LazyCallGraph::SCC &C,
     updateCallGraphAfterCoroutineSplit(*N, Shape, Clones, C, CG, AM, UR, FAM);
 
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "CoroSplit", &F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "CoroSplit", &F);
+      return or_instance
              << "Split '" << ore::NV("function", F.getName())
              << "' (frame_size=" << ore::NV("frame_size", Shape.FrameSize)
              << ", align=" << ore::NV("align", Shape.FrameAlign.value()) << ")";
diff --git a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
index d33258642365..ab0df88113de 100644
--- a/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
+++ b/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp
@@ -422,7 +422,8 @@ struct VirtualCallSite {
     BasicBlock *Block = CB.getParent();
 
     using namespace ore;
-    OREGetter(F).emit(OptimizationRemark(DEBUG_TYPE, OptName, DLoc, Block)
+    OptimizationRemark or_instance(DEBUG_TYPE, OptName, DLoc, Block);
+    OREGetter(F).emit(or_instance
                       << NV("Optimization", OptName)
                       << ": devirtualized a call to "
                       << NV("FunctionName", TargetName));
@@ -2360,7 +2361,8 @@ bool DevirtModule::run() {
       }
 
       using namespace ore;
-      OREGetter(F).emit(OptimizationRemark(DEBUG_TYPE, "Devirtualized", F)
+      OptimizationRemark or_instance(DEBUG_TYPE, "Devirtualized", F);
+      OREGetter(F).emit(or_instance
                         << "devirtualized "
                         << NV("FunctionName", DT.first));
     }


diff --git a/llvm/lib/Transforms/IPO/ModuleInliner.cpp b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
index 5e91ab80d750..83c6eff887e1 100644
--- a/llvm/lib/Transforms/IPO/ModuleInliner.cpp
+++ b/llvm/lib/Transforms/IPO/ModuleInliner.cpp
@@ -153,7 +153,8 @@ PreservedAnalyses ModuleInlinerPass::run(Module &M,
             using namespace ore;
             setInlineRemark(*CB, "unavailable definition");
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "NoDefinition", &I)
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NoDefinition", &I);
+              return orm_instance
                      << NV("Callee", Callee) << " will not be inlined into "
                      << NV("Caller", CB->getCaller())
                      << " because its definition is unavailable"
diff --git a/llvm/lib/Transforms/IPO/PartialInlining.cpp b/llvm/lib/Transforms/IPO/PartialInlining.cpp
index b88ba2dec24b..689226f9098a 100644
--- a/llvm/lib/Transforms/IPO/PartialInlining.cpp
+++ b/llvm/lib/Transforms/IPO/PartialInlining.cpp
@@ -374,9 +374,9 @@ PartialInlinerImpl::computeOutliningColdRegionsInfo(
         if (!is_contained(BlockList, Succ)) {
           if (ExitBlock) {
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "MultiExitRegion",
-                                              &Succ->front())
-                     << "Region dominated by "
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "MultiExitRegion",
+                                              &Succ->front());
+              return orm_instance << "Region dominated by "
                      << ore::NV("Block", BlockList.front()->getName())
                      << " has more than one region exit edge.";
             });
@@ -476,9 +476,9 @@ PartialInlinerImpl::computeOutliningColdRegionsInfo(
 
       if (!SkipCostAnalysis && OutlineRegionCost < MinOutlineRegionCost) {
         ORE.emit([&]() {
-          return OptimizationRemarkAnalysis(DEBUG_TYPE, "TooCostly",
-                                            &SI->front())
-                 << ore::NV("Callee", &F)
+          OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "TooCostly",
+                                            &SI->front());
+          return ora_instance << ore::NV("Callee", &F)
                  << " inline cost-savings smaller than "
                  << ore::NV("Cost", MinOutlineRegionCost);
         });
@@ -737,8 +737,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (IC.isAlways()) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "AlwaysInline", &CB)
-             << NV("Callee", Cloner.OrigFunc)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "AlwaysInline", &CB);
+      return ora_instance << NV("Callee", Cloner.OrigFunc)
              << " should always be fully inlined, not partially";
     });
     return false;
@@ -746,7 +746,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (IC.isNever()) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "NeverInline", &CB)
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NeverInline", &CB);
+      return orm_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller)
              << " because it should never be inlined (cost=never)";
@@ -756,7 +757,8 @@ bool PartialInlinerImpl::shouldPartialInline(
 
   if (!IC) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "TooCostly", &CB)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "TooCostly", &CB);
+      return ora_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller) << " because too costly to inline (cost="
              << NV("Cost", IC.getCost()) << ", threshold="
@@ -773,8 +775,9 @@ bool PartialInlinerImpl::shouldPartialInline(
   // Weighted saving is smaller than weighted cost, return false
   if (NormWeightedSavings < WeightedOutliningRcost) {
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "OutliningCallcostTooHigh",
-                                        &CB)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "OutliningCallcostTooHigh",
+                                        &CB);
+      return ora_instance
              << NV("Callee", Cloner.OrigFunc) << " not partially inlined into "
              << NV("Caller", Caller) << " runtime overhead (overhead="
              << NV("Overhead", (unsigned)WeightedOutliningRcost.getFrequency())
@@ -788,7 +791,8 @@ bool PartialInlinerImpl::shouldPartialInline(
   }
 
   ORE.emit([&]() {
-    return OptimizationRemarkAnalysis(DEBUG_TYPE, "CanBePartiallyInlined", &CB)
+    OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "CanBePartiallyInlined", &CB);
+    return ora_instance
            << NV("Callee", Cloner.OrigFunc) << " can be partially inlined into "
            << NV("Caller", Caller) << " with cost=" << NV("Cost", IC.getCost())
            << " (threshold="
@@ -1144,8 +1148,9 @@ bool PartialInlinerImpl::FunctionCloner::doMultiRegionFunctionOutlining() {
       }
     } else
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                        &RegionInfo.Region.front()->front())
+        OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                        &RegionInfo.Region.front()->front());
+        return orm_instance
                << "Failed to extract region at block "
                << ore::NV("Block", RegionInfo.Region.front());
       });
@@ -1204,8 +1209,9 @@ PartialInlinerImpl::FunctionCloner::doSingleRegionFunctionOutlining() {
     OutlinedFunctions.push_back(std::make_pair(OutlinedFunc, OutliningCallBB));
   } else
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                      &ToExtract.front()->front())
+      OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                      &ToExtract.front()->front());
+      return orm_instance
              << "Failed to extract region at block "
              << ore::NV("Block", ToExtract.front());
     });
@@ -1336,8 +1342,9 @@ bool PartialInlinerImpl::tryPartialInline(FunctionCloner &Cloner) {
     BasicBlock *Block;
     std::tie(DLoc, Block) = getOneDebugLoc(*Cloner.ClonedFunc);
     OrigFuncORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "OutlineRegionTooSmall",
-                                        DLoc, Block)
+      OptimizationRemarkAnalysis ora_instance(DEBUG_TYPE, "OutlineRegionTooSmall",
+                                        DLoc, Block);
+      return ora_instance
              << ore::NV("Function", Cloner.OrigFunc)
              << " not partially inlined into callers (Original Size = "
              << ore::NV("OutlinedRegionOriginalSize", Cloner.OutlinedRegionCost)
@@ -1415,7 +1422,8 @@ bool PartialInlinerImpl::tryPartialInline(FunctionCloner &Cloner) {
           CalleeEntryCountV, CalleeEntryCount->getType()));
     OptimizationRemarkEmitter OrigFuncORE(Cloner.OrigFunc);
     OrigFuncORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "PartiallyInlined", Cloner.OrigFunc)
+      OptimizationRemark or_instance(DEBUG_TYPE, "PartiallyInlined", Cloner.OrigFunc);
+      return or_instance
              << "Partially inlined into at least one caller";
     });
   }


diff --git a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
index f835fb26fcb8..1ce7da7d7c64 100644
--- a/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
+++ b/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
@@ -2249,8 +2249,9 @@ void ModuleCallsiteContextGraph::updateAllocationCall(
   auto A = llvm::Attribute::get(Call.call()->getFunction()->getContext(),
                                 "memprof", AllocTypeString);
   cast<CallBase>(Call.call())->addFnAttr(A);
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofAttribute", Call.call());
   OREGetter(Call.call()->getFunction())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofAttribute", Call.call())
+      .emit(or_instance
             << ore::NV("AllocationCall", Call.call()) << " in clone "
             << ore::NV("Caller", Call.call()->getFunction())
             << " marked with memprof allocation attribute "
@@ -2269,8 +2270,9 @@ void ModuleCallsiteContextGraph::updateCall(CallInfo &CallerCall,
                                             FuncInfo CalleeFunc) {
   if (CalleeFunc.cloneNo() > 0)
     cast<CallBase>(CallerCall.call())->setCalledFunction(CalleeFunc.func());
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofCall", CallerCall.call());
   OREGetter(CallerCall.call()->getFunction())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofCall", CallerCall.call())
+      .emit(or_instance
             << ore::NV("Call", CallerCall.call()) << " in clone "
             << ore::NV("Caller", CallerCall.call()->getFunction())
             << " assigned to call function clone "
@@ -2302,8 +2304,9 @@ ModuleCallsiteContextGraph::cloneFunctionForCallsite(
     assert(Inst.cloneNo() == 0);
     CallMap[Inst] = {cast<Instruction>(VMap[Inst.call()]), CloneNo};
   }
+  OptimizationRemark or_instance(DEBUG_TYPE, "MemprofClone", Func.func());
   OREGetter(Func.func())
-      .emit(OptimizationRemark(DEBUG_TYPE, "MemprofClone", Func.func())
+      .emit(or_instance
             << "created clone " << ore::NV("NewFunction", NewFunc));
   return {NewFunc, CloneNo};
 }
@@ -2835,7 +2838,8 @@ static SmallVector<std::unique_ptr<ValueToValueMapTy>, 4> createFunctionClones(
       PrevF->eraseFromParent();
     } else
       NewF->setName(Name);
-    ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofClone", &F)
+    OptimizationRemark or_instance(DEBUG_TYPE, "MemprofClone", &F);
+    ORE.emit(or_instance
              << "created clone " << ore::NV("NewFunction", NewF));
 
     // Now handle aliases to this function, and clone those as well.
@@ -3089,7 +3093,8 @@ bool MemProfContextDisambiguation::applyImport(Module &M) {
               // entry).
               CBClone = cast<CallBase>((*VMaps[J - 1])[CB]);
             CBClone->addFnAttr(A);
-            ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofAttribute", CBClone)
+            OptimizationRemark or_instance(DEBUG_TYPE, "MemprofAttribute", CBClone);
+            ORE.emit(or_instance
                      << ore::NV("AllocationCall", CBClone) << " in clone "
                      << ore::NV("Caller", CBClone->getFunction())
                      << " marked with memprof allocation attribute "
@@ -3138,7 +3143,8 @@ bool MemProfContextDisambiguation::applyImport(Module &M) {
             else
               CBClone = cast<CallBase>((*VMaps[J - 1])[CB]);
             CBClone->setCalledFunction(NewF);
-            ORE.emit(OptimizationRemark(DEBUG_TYPE, "MemprofCall", CBClone)
+            OptimizationRemark or_instance(DEBUG_TYPE, "MemprofCall", CBClone);
+            ORE.emit(or_instance
                      << ore::NV("Call", CBClone) << " in clone "
                      << ore::NV("Caller", CBClone->getFunction())
                      << " assigned to call function clone "


diff --git a/llvm/include/llvm/Transforms/IPO/Attributor.h b/llvm/include/llvm/Transforms/IPO/Attributor.h
index 1da00acdf034..0181425a9e1b 100644
--- a/llvm/include/llvm/Transforms/IPO/Attributor.h
+++ b/llvm/include/llvm/Transforms/IPO/Attributor.h
@@ -2114,15 +2114,15 @@ public:
 
     Function *F = I->getFunction();
     auto &ORE = Configuration.OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, I));
+        return rcb;
       });
   }
 
@@ -2134,15 +2134,15 @@ public:
       return;
 
     auto &ORE = Configuration.OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(Configuration.PassName, RemarkName, F));
+        return rcb;
       });
   }
 
diff --git a/llvm/lib/Transforms/IPO/OpenMPOpt.cpp b/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
index 588f3901e3cb..c47245a35b14 100644
--- a/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
+++ b/llvm/lib/Transforms/IPO/OpenMPOpt.cpp
@@ -1857,15 +1857,15 @@ private:
                   RemarkCallBack &&RemarkCB) const {
     Function *F = I->getParent()->getParent();
     auto &ORE = OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit(
-          [&]() { return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, I)); });
+          [&]() { return rcb; });
   }
 
   /// Emit a remark on a function.
@@ -1873,15 +1873,15 @@ private:
   void emitRemark(Function *F, StringRef RemarkName,
                   RemarkCallBack &&RemarkCB) const {
     auto &ORE = OREGetter(F);
-
+    auto rcb = RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F));
     if (RemarkName.startswith("OMP"))
       ORE.emit([&]() {
-        return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F))
+        return rcb
                << " [" << RemarkName << "]";
       });
     else
       ORE.emit(
-          [&]() { return RemarkCB(RemarkKind(DEBUG_TYPE, RemarkName, F)); });
+          [&]() { return rcb; });
   }
 
   /// The underlying module.


diff --git a/llvm/lib/Transforms/IPO/SampleProfile.cpp b/llvm/lib/Transforms/IPO/SampleProfile.cpp
index a53baecd4776..4e41eb84502e 100644
--- a/llvm/lib/Transforms/IPO/SampleProfile.cpp
+++ b/llvm/lib/Transforms/IPO/SampleProfile.cpp
@@ -1057,9 +1057,10 @@ void SampleProfileLoader::emitOptimizationRemarksForInlineCandidates(
   for (auto *I : Candidates) {
     Function *CalledFunction = I->getCalledFunction();
     if (CalledFunction) {
-      ORE->emit(OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(),
+      OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(),
                                            "InlineAttempt", I->getDebugLoc(),
-                                           I->getParent())
+                                           I->getParent());
+      ORE->emit(ora_instance
                 << "previous inlining reattempted for "
                 << (Hot ? "hotness: '" : "size: '")
                 << ore::NV("Callee", CalledFunction) << "' into '"
@@ -1284,8 +1285,9 @@ bool SampleProfileLoader::tryInlineCandidate(
 
   InlineCost Cost = shouldInlineCandidate(Candidate);
   if (Cost.isNever()) {
-    ORE->emit(OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(),
-                                         "InlineFail", DLoc, BB)
+    OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(),
+                                         "InlineFail", DLoc, BB);
+    ORE->emit(ora_instance
               << "incompatible inlining");
     return false;
   }
@@ -1588,9 +1590,9 @@ void SampleProfileLoader::promoteMergeNotInlinedContextSamples(
     if (!Callee || Callee->isDeclaration())
       continue;
 
-    ORE->emit(
-        OptimizationRemarkAnalysis(getAnnotatedRemarkPassName(), "NotInline",
-                                   I->getDebugLoc(), I->getParent())
+    OptimizationRemarkAnalysis ora_instance(getAnnotatedRemarkPassName(), "NotInline",
+                                   I->getDebugLoc(), I->getParent());
+    ORE->emit(ora_instance
         << "previous inlining not repeated: '" << ore::NV("Callee", Callee)
         << "' into '" << ore::NV("Caller", &F) << "'");
 
@@ -1794,7 +1796,8 @@ void SampleProfileLoader::generateMDProfMetadata(Function &F) {
       LLVM_DEBUG(dbgs() << "SUCCESS. Found non-zero weights.\n");
       TI->setMetadata(LLVMContext::MD_prof, MDB.createBranchWeights(Weights));
       ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "PopularDest", MaxDestInst)
+        OptimizationRemark or_instance(DEBUG_TYPE, "PopularDest", MaxDestInst);
+        return or_instance
                << "most popular destination for conditional branches at "
                << ore::NV("CondBranchesLoc", BranchLoc);
       });


diff --git a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
index 599ace9ca79f..02da25fbf700 100644
--- a/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
+++ b/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
@@ -358,8 +358,9 @@ Function *HotColdSplitting::extractColdRegion(
 
     LLVM_DEBUG(llvm::dbgs() << "Outlined Region: " << *OutF);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "HotColdSplit",
-                                &*Region[0]->begin())
+      OptimizationRemark or_instance(DEBUG_TYPE, "HotColdSplit",
+                                &*Region[0]->begin());
+      return or_instance
              << ore::NV("Original", OrigF) << " split cold code into "
              << ore::NV("Split", OutF);
     });
@@ -367,8 +368,9 @@ Function *HotColdSplitting::extractColdRegion(
   }
 
   ORE.emit([&]() {
-    return OptimizationRemarkMissed(DEBUG_TYPE, "ExtractFailed",
-                                    &*Region[0]->begin())
+    OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "ExtractFailed",
+                                    &*Region[0]->begin());
+    return orm_instance
            << "Failed to extract region at block "
            << ore::NV("Block", Region.front());
   });
diff --git a/llvm/lib/Transforms/IPO/Inliner.cpp b/llvm/lib/Transforms/IPO/Inliner.cpp
index 3e00aebce372..bb757477241c 100644
--- a/llvm/lib/Transforms/IPO/Inliner.cpp
+++ b/llvm/lib/Transforms/IPO/Inliner.cpp
@@ -264,7 +264,8 @@ PreservedAnalyses InlinerPass::run(LazyCallGraph::SCC &InitialC,
             using namespace ore;
             setInlineRemark(*CB, "unavailable definition");
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "NoDefinition", &I)
+              OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NoDefinition", &I);
+              return orm_instance
                      << NV("Callee", Callee) << " will not be inlined into "
                      << NV("Caller", CB->getCaller())
                      << " because its definition is unavailable"


diff --git a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
index cc375f9badcd..4d35a291919e 100644
--- a/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
+++ b/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
@@ -70,8 +70,9 @@ bool AlwaysInlineImpl(
                                           &GetAAR(F), InsertLifetime);
         if (!Res.isSuccess()) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE, "NotInlined", DLoc,
-                                            Block)
+            OptimizationRemarkMissed orm_instance(DEBUG_TYPE, "NotInlined", DLoc,
+                                            Block);
+            return orm_instance
                    << "'" << ore::NV("Callee", &F) << "' is not inlined into '"
                    << ore::NV("Caller", Caller)
                    << "': " << ore::NV("Reason", Res.getFailureReason());


diff --git a/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp b/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
index e53019768e88..76263066e537 100644
--- a/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
+++ b/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
@@ -25,10 +25,10 @@ static void warnAboutLeftoverTransformations(Loop *L,
                                              OptimizationRemarkEmitter *ORE) {
   if (hasUnrollTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover unroll transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedUnrolling",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure fru(DEBUG_TYPE,
+                                      "FailedRequestedUnrolling",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(fru
         << "loop not unrolled: the optimizer was unable to perform the "
            "requested transformation; the transformation might be disabled or "
            "specified as part of an unsupported transformation ordering");
@@ -36,10 +36,10 @@ static void warnAboutLeftoverTransformations(Loop *L,
 
   if (hasUnrollAndJamTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover unroll-and-jam transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedUnrollAndJamming",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure fruaj(DEBUG_TYPE,
+                                      "FailedRequestedUnrollAndJamming",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(fruaj
         << "loop not unroll-and-jammed: the optimizer was unable to perform "
            "the requested transformation; the transformation might be disabled "
            "or specified as part of an unsupported transformation ordering");
@@ -52,30 +52,31 @@ static void warnAboutLeftoverTransformations(Loop *L,
     std::optional<int> InterleaveCount =
         getOptionalIntLoopAttribute(L, "llvm.loop.interleave.count");
 
-    if (!VectorizeWidth || VectorizeWidth->isVector())
-      ORE->emit(
-          DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                            "FailedRequestedVectorization",
-                                            L->getStartLoc(), L->getHeader())
+    if (!VectorizeWidth || VectorizeWidth->isVector()) {
+      DiagnosticInfoOptimizationFailure frv(DEBUG_TYPE,
+                                        "FailedRequestedVectorization",
+                                        L->getStartLoc(), L->getHeader());
+      ORE->emit(frv
           << "loop not vectorized: the optimizer was unable to perform the "
              "requested transformation; the transformation might be disabled "
              "or specified as part of an unsupported transformation ordering");
-    else if (InterleaveCount.value_or(0) != 1)
-      ORE->emit(
-          DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                            "FailedRequestedInterleaving",
-                                            L->getStartLoc(), L->getHeader())
+    } else if (InterleaveCount.value_or(0) != 1) {
+      DiagnosticInfoOptimizationFailure fri(DEBUG_TYPE,
+                                        "FailedRequestedInterleaving",
+                                        L->getStartLoc(), L->getHeader());
+      ORE->emit(fri
           << "loop not interleaved: the optimizer was unable to perform the "
              "requested transformation; the transformation might be disabled "
              "or specified as part of an unsupported transformation ordering");
+    }
   }
 
   if (hasDistributeTransformation(L) == TM_ForcedByUser) {
     LLVM_DEBUG(dbgs() << "Leftover distribute transformation\n");
-    ORE->emit(
-        DiagnosticInfoOptimizationFailure(DEBUG_TYPE,
-                                          "FailedRequestedDistribution",
-                                          L->getStartLoc(), L->getHeader())
+    DiagnosticInfoOptimizationFailure frd(DEBUG_TYPE,
+                                      "FailedRequestedDistribution",
+                                      L->getStartLoc(), L->getHeader());
+    ORE->emit(frd
         << "loop not distributed: the optimizer was unable to perform the "
            "requested transformation; the transformation might be disabled or "
            "specified as part of an unsupported transformation ordering");


diff --git a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
index 4f1350e4ebb9..3eeb2e249f6e 100644
--- a/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
+++ b/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
@@ -271,7 +271,8 @@ static bool markTails(Function &F, OptimizationRemarkEmitter *ORE) {
         if (SafeToTail) {
           using namespace ore;
           ORE->emit([&]() {
-            return OptimizationRemark(DEBUG_TYPE, "tailcall-readnone", CI)
+            OptimizationRemark or_instance(DEBUG_TYPE, "tailcall-readnone", CI);
+            return or_instance
                    << "marked as tail call candidate (readnone)";
           });
           CI->setTailCall();
@@ -654,7 +655,8 @@ bool TailRecursionEliminator::eliminateCall(CallInst *CI) {
 
   using namespace ore;
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "tailcall-recursion", CI)
+    OptimizationRemark or_instance(DEBUG_TYPE, "tailcall-recursion", CI);
+    return or_instance
            << "transforming tail recursion into loop";
   });
 
diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
index f923f0be6621..718e87866d39 100644
--- a/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
+++ b/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp
@@ -194,9 +194,10 @@ bool LoopVectorizeHints::allowVectorization(
     // vectorize.disable to be used without disabling the pass and errors
     // to differentiate between disabled vectorization and a width of 1.
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(vectorizeAnalysisPassName(),
+      OptimizationRemarkAnalysis ora(vectorizeAnalysisPassName(),
                                         "AllDisabled", L->getStartLoc(),
-                                        L->getHeader())
+                                        L->getHeader());
+      return ora
              << "loop not vectorized: vectorization and interleaving are "
                 "explicitly disabled, or the loop has already been "
                 "vectorized";
@@ -211,12 +212,13 @@ void LoopVectorizeHints::emitRemarkWithHints() const {
   using namespace ore;
 
   ORE.emit([&]() {
-    if (Force.Value == LoopVectorizeHints::FK_Disabled)
-      return OptimizationRemarkMissed(LV_NAME, "MissedExplicitlyDisabled",
+    if (Force.Value == LoopVectorizeHints::FK_Disabled) {
+      OptimizationRemarkMissed orm(LV_NAME, "MissedExplicitlyDisabled",
                                       TheLoop->getStartLoc(),
-                                      TheLoop->getHeader())
+                                      TheLoop->getHeader());
+      return orm
              << "loop not vectorized: vectorization is explicitly disabled";
-    else {
+    } else {
       OptimizationRemarkMissed R(LV_NAME, "MissedDetails",
                                  TheLoop->getStartLoc(), TheLoop->getHeader());
       R << "loop not vectorized";


diff --git a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
index 335b489d3cb2..0da16d74b1ff 100644
--- a/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
@@ -999,9 +999,10 @@ bool llvm::computeUnrollCount(
     if ((PragmaFullUnroll || PragmaEnableUnroll) && TripCount &&
         UP.Count != TripCount)
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE,
+        OptimizationRemarkMissed fuadtl(DEBUG_TYPE,
                                         "FullUnrollAsDirectedTooLarge",
-                                        L->getStartLoc(), L->getHeader())
+                                        L->getStartLoc(), L->getHeader());
+        return fuadtl
                << "Unable to fully unroll loop as directed by unroll pragma "
                   "because "
                   "unrolled size is too large.";
@@ -1011,9 +1012,10 @@ bool llvm::computeUnrollCount(
       if (UP.Count == 0) {
         if (PragmaEnableUnroll)
           ORE->emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
+            OptimizationRemarkMissed uadtl(DEBUG_TYPE,
                                             "UnrollAsDirectedTooLarge",
-                                            L->getStartLoc(), L->getHeader())
+                                            L->getStartLoc(), L->getHeader());
+            return uadtl
                    << "Unable to unroll loop as directed by unroll(enable) "
                       "pragma "
                       "because unrolled size is too large.";
@@ -1026,9 +1028,10 @@ bool llvm::computeUnrollCount(
          "All cases when TripCount is constant should be covered here.");
   if (PragmaFullUnroll)
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(
+      OptimizationRemarkMissed cfuadrtc(
                  DEBUG_TYPE, "CantFullUnrollAsDirectedRuntimeTripCount",
-                 L->getStartLoc(), L->getHeader())
+                 L->getStartLoc(), L->getHeader());
+      return cfuadrtc
              << "Unable to fully unroll loop as directed by unroll(full) "
                 "pragma "
                 "because loop has a runtime trip count.";
@@ -1092,9 +1095,10 @@ bool llvm::computeUnrollCount(
 
     if (unrollCountPragmaValue(L) > 0 && !UP.AllowRemainder)
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE,
+        OptimizationRemarkMissed ducfd(DEBUG_TYPE,
                                         "DifferentUnrollCountFromDirected",
-                                        L->getStartLoc(), L->getHeader())
+                                        L->getStartLoc(), L->getHeader());
+        return ducfd
                << "Unable to unroll loop the number of times directed by "
                   "unroll_count pragma because remainder loop is restricted "
                   "(that could architecture specific or because the loop "
@@ -1287,8 +1291,9 @@ tryToUnrollLoop(Loop *L, DominatorTree &DT, LoopInfo *LI, ScalarEvolution &SE,
     LLVM_DEBUG(dbgs() << "PEELING loop %" << L->getHeader()->getName()
                       << " with iteration count " << PP.PeelCount << "!\n");
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Peeled", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark p(DEBUG_TYPE, "Peeled", L->getStartLoc(),
+                                L->getHeader());
+      return p
              << " peeled loop by " << ore::NV("PeelCount", PP.PeelCount)
              << " iterations";
     });
diff --git a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
index 13e06c79d0d7..7aa37913a676 100644
--- a/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
@@ -365,7 +365,8 @@ bool LoopVersioningLICM::legalLoopInstructions() {
       // If instruction is unsafe just return false.
       if (!instructionSafeForVersioning(&Inst)) {
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopInst", &Inst)
+          OptimizationRemarkMissed ili(DEBUG_TYPE, "IllegalLoopInst", &Inst);
+          return ili
                  << " Unsafe Loop Instruction";
         });
         return false;
@@ -384,9 +385,10 @@ bool LoopVersioningLICM::legalLoopInstructions() {
     LLVM_DEBUG(
         dbgs() << "    LAA: Runtime checks are more than threshold !!\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "RuntimeCheck",
+      OptimizationRemarkMissed rc(DEBUG_TYPE, "RuntimeCheck",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return rc
              << "Number of runtime checks "
              << NV("RuntimeChecks", LAI->getNumRuntimePointerChecks())
              << " exceeds threshold "
@@ -416,9 +418,10 @@ bool LoopVersioningLICM::legalLoopInstructions() {
     LLVM_DEBUG(dbgs() << "    Invariant loads & store threshold: "
                       << InvariantThreshold << "%\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InvariantThreshold",
+      OptimizationRemarkMissed it(DEBUG_TYPE, "InvariantThreshold",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return it
              << "Invariant load & store "
              << NV("LoadAndStoreCounter",
                    ((InvariantCounter * 100) / LoadAndStoreCounter))
@@ -459,9 +462,10 @@ bool LoopVersioningLICM::isLegalForVersioning() {
     LLVM_DEBUG(
         dbgs() << "    Loop structure not suitable for LoopVersioningLICM\n\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopStruct",
+      OptimizationRemarkMissed ils(DEBUG_TYPE, "IllegalLoopStruct",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return ils
              << " Unsafe Loop structure";
     });
     return false;
@@ -479,9 +483,10 @@ bool LoopVersioningLICM::isLegalForVersioning() {
         dbgs()
         << "    Loop memory access not suitable for LoopVersioningLICM\n\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "IllegalLoopMemoryAccess",
+      OptimizationRemarkMissed ilma(DEBUG_TYPE, "IllegalLoopMemoryAccess",
                                       CurLoop->getStartLoc(),
-                                      CurLoop->getHeader())
+                                      CurLoop->getHeader());
+      return ilma
              << " Unsafe Loop memory access";
     });
     return false;
@@ -489,8 +494,9 @@ bool LoopVersioningLICM::isLegalForVersioning() {
   // Loop versioning is feasible, return true.
   LLVM_DEBUG(dbgs() << "    Loop Versioning found to be beneficial\n\n");
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "IsLegalForVersioning",
-                              CurLoop->getStartLoc(), CurLoop->getHeader())
+    OptimizationRemark ilfv(DEBUG_TYPE, "IsLegalForVersioning",
+                              CurLoop->getStartLoc(), CurLoop->getHeader());
+    return ilfv
            << " Versioned loop for LICM."
            << " Number of runtime checks we had to insert "
            << NV("RuntimeChecks", LAI->getNumRuntimePointerChecks());


diff --git a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
index 7c2770979a90..5b21f03f069d 100644
--- a/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp
@@ -417,7 +417,8 @@ bool LoopDataPrefetch::runOnLoop(Loop *L) {
                << *P.MemI->getOperand(isa<LoadInst>(P.MemI) ? 0 : 1)
                << ", SCEV: " << *P.LSCEVAddRec << "\n");
     ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "Prefetched", P.MemI)
+        OptimizationRemark p(DEBUG_TYPE, "Prefetched", P.MemI);
+        return p
           << "prefetched memory access";
       });
 
diff --git a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
index 91286ebcea33..ab41bbb9a2ed 100644
--- a/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopInterchange.cpp
@@ -520,9 +520,10 @@ struct LoopInterchange {
     }
 
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Interchanged",
+      OptimizationRemark i(DEBUG_TYPE, "Interchanged",
                                 InnerLoop->getStartLoc(),
-                                InnerLoop->getHeader())
+                                InnerLoop->getHeader());
+      return i
              << "Loop interchanged with enclosing loop.";
     });
 
@@ -780,9 +781,10 @@ bool LoopInterchangeLegality::currentLimitations() {
         dbgs() << "Loops where the latch is not the exiting block are not"
                << " supported currently.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "ExitingNotLatch",
+      OptimizationRemarkMissed enl(DEBUG_TYPE, "ExitingNotLatch",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return enl
              << "Loops where the latch is not the exiting block cannot be"
                 " interchange currently.";
     });
@@ -795,9 +797,10 @@ bool LoopInterchangeLegality::currentLimitations() {
         dbgs() << "Only outer loops with induction or reduction PHI nodes "
                << "are supported currently.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedPHIOuter",
+      OptimizationRemarkMissed uphio(DEBUG_TYPE, "UnsupportedPHIOuter",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return uphio
              << "Only outer loops with induction or reduction PHI nodes can be"
                 " interchanged currently.";
     });
@@ -817,9 +820,10 @@ bool LoopInterchangeLegality::currentLimitations() {
           dbgs() << "Only inner loops with induction or reduction PHI nodes "
                 << "are supported currently.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedPHIInner",
+        OptimizationRemarkMissed uphii(DEBUG_TYPE, "UnsupportedPHIInner",
                                         CurLevelLoop->getStartLoc(),
-                                        CurLevelLoop->getHeader())
+                                        CurLevelLoop->getHeader());
+        return uphii
               << "Only inner loops with induction or reduction PHI nodes can be"
                   " interchange currently.";
       });
@@ -831,9 +835,10 @@ bool LoopInterchangeLegality::currentLimitations() {
   if (!isLoopStructureUnderstood()) {
     LLVM_DEBUG(dbgs() << "Loop structure not understood by pass\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedStructureInner",
+      OptimizationRemarkMissed usi(DEBUG_TYPE, "UnsupportedStructureInner",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return usi
              << "Inner loop structure not understood currently.";
     });
     return true;
@@ -948,9 +953,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
                       << " and OuterLoopId = " << OuterLoopId
                       << " due to dependence\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "Dependence",
+      OptimizationRemarkMissed d(DEBUG_TYPE, "Dependence",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return d
              << "Cannot interchange loops due to dependences.";
     });
     return false;
@@ -966,9 +972,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
             dbgs() << "Loops with call instructions cannot be interchanged "
                    << "safely.");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "CallInst",
+          OptimizationRemarkMissed ci(DEBUG_TYPE, "CallInst",
                                           CI->getDebugLoc(),
-                                          CI->getParent())
+                                          CI->getParent());
+          return ci
                  << "Cannot interchange loops due to call instruction.";
         });
 
@@ -983,9 +990,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!areInnerLoopLatchPHIsSupported(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in inner loop latch.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedInnerLatchPHI",
+      OptimizationRemarkMissed uilphi(DEBUG_TYPE, "UnsupportedInnerLatchPHI",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return uilphi
              << "Cannot interchange loops because unsupported PHI nodes found "
                 "in inner loop latch.";
     });
@@ -1003,9 +1011,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!tightlyNested(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Loops not tightly nested\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "NotTightlyNested",
+      OptimizationRemarkMissed ntn(DEBUG_TYPE, "NotTightlyNested",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return ntn
              << "Cannot interchange loops because they are not tightly "
                 "nested.";
     });
@@ -1016,9 +1025,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
                                      OuterInnerReductions)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in inner loop exit.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedExitPHI",
+      OptimizationRemarkMissed uephii(DEBUG_TYPE, "UnsupportedExitPHI",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return uephii
              << "Found unsupported PHI node in loop exit.";
     });
     return false;
@@ -1027,9 +1037,10 @@ bool LoopInterchangeLegality::canInterchangeLoops(unsigned InnerLoopId,
   if (!areOuterLoopExitPHIsSupported(OuterLoop, InnerLoop)) {
     LLVM_DEBUG(dbgs() << "Found unsupported PHI nodes in outer loop exit.\n");
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "UnsupportedExitPHI",
+      OptimizationRemarkMissed uephio(DEBUG_TYPE, "UnsupportedExitPHI",
                                       OuterLoop->getStartLoc(),
-                                      OuterLoop->getHeader())
+                                      OuterLoop->getHeader());
+      return uephio
              << "Found unsupported PHI node in loop exit.";
     });
     return false;
@@ -1173,18 +1184,20 @@ bool LoopInterchangeProfitability::isProfitable(
   }
   if (!shouldInterchange.has_value()) {
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InterchangeNotProfitable",
+      OptimizationRemarkMissed inp(DEBUG_TYPE, "InterchangeNotProfitable",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return inp
              << "Insufficient information to calculate the cost of loop for "
                 "interchange.";
     });
     return false;
   } else if (!shouldInterchange.value()) {
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "InterchangeNotProfitable",
+      OptimizationRemarkMissed inp(DEBUG_TYPE, "InterchangeNotProfitable",
                                       InnerLoop->getStartLoc(),
-                                      InnerLoop->getHeader())
+                                      InnerLoop->getHeader());
+      return inp
              << "Interchanging loops is not considered to improve cache "
                 "locality nor vectorization.";
     });


diff --git a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
index c041e3621a16..ea269dd9be4d 100644
--- a/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDeletion.cpp
@@ -464,8 +464,9 @@ static LoopDeletionResult deleteLoopIfDead(Loop *L, DominatorTree &DT,
                 PoisonValue::get(P.getType()));
     }
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "NeverExecutes", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark ne(DEBUG_TYPE, "NeverExecutes", L->getStartLoc(),
+                                L->getHeader());
+      return ne
              << "Loop deleted because it never executes";
     });
     deleteDeadLoop(L, &DT, &SE, &LI, MSSA);
@@ -504,8 +505,9 @@ static LoopDeletionResult deleteLoopIfDead(Loop *L, DominatorTree &DT,
 
   LLVM_DEBUG(dbgs() << "Loop is invariant, delete it!\n");
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Invariant", L->getStartLoc(),
-                              L->getHeader())
+    OptimizationRemark i(DEBUG_TYPE, "Invariant", L->getStartLoc(),
+                              L->getHeader());
+    return i
            << "Loop deleted because it is invariant";
   });
   deleteDeadLoop(L, &DT, &SE, &LI, MSSA);
diff --git a/llvm/lib/Transforms/Scalar/LoopDistribute.cpp b/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
index 27196e46ca56..41c671b382e2 100644
--- a/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopDistribute.cpp
@@ -841,8 +841,9 @@ public:
     ++NumLoopsDistributed;
     // Report the success.
     ORE->emit([&]() {
-      return OptimizationRemark(LDIST_NAME, "Distribute", L->getStartLoc(),
-                                L->getHeader())
+      OptimizationRemark d(LDIST_NAME, "Distribute", L->getStartLoc(),
+                                L->getHeader());
+      return d
              << "distributed loop";
     });
     return true;
@@ -857,8 +858,9 @@ public:
 
     // With Rpass-missed report that distribution failed.
     ORE->emit([&]() {
-      return OptimizationRemarkMissed(LDIST_NAME, "NotDistributed",
-                                      L->getStartLoc(), L->getHeader())
+      OptimizationRemarkMissed nd(LDIST_NAME, "NotDistributed",
+                                      L->getStartLoc(), L->getHeader());
+      return nd
              << "loop not distributed: use -Rpass-analysis=loop-distribute for "
                 "more "
                 "info";
@@ -866,9 +868,10 @@ public:
 
     // With Rpass-analysis report why.  This is on by default if distribution
     // was requested explicitly.
-    ORE->emit(OptimizationRemarkAnalysis(
+    OptimizationRemarkAnalysis ora_instance(
                   Forced ? OptimizationRemarkAnalysis::AlwaysPrint : LDIST_NAME,
-                  RemarkName, L->getStartLoc(), L->getHeader())
+                  RemarkName, L->getStartLoc(), L->getHeader());
+    ORE->emit(ora_instance
               << "loop not distributed: " << Message);
 
     // Also issue a warning if distribution was requested explicitly but it


diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index f8fab03f151d..f33c88ae74b9 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -1190,8 +1190,9 @@ bool llvm::canSinkOrHoistInst(Instruction &I, AAResults *AA, DominatorTree *DT,
     // whose address is not necessarily loop-invariant.
     if (ORE && Invalidated && CurLoop->isLoopInvariant(LI->getPointerOperand()))
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(
-                   DEBUG_TYPE, "LoadWithLoopInvariantAddressInvalidated", LI)
+        OptimizationRemarkMissed lwliai(
+                   DEBUG_TYPE, "LoadWithLoopInvariantAddressInvalidated", LI);
+        return lwliai
                << "failed to move load with loop-invariant address "
                   "because the loop may invalidate its value";
       });
@@ -1674,7 +1675,8 @@ static bool sink(Instruction &I, LoopInfo *LI, DominatorTree *DT,
     return Changed;
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "InstSunk", &I)
+    OptimizationRemark is(DEBUG_TYPE, "InstSunk", &I);
+    return is
            << "sinking " << ore::NV("Inst", &I);
   });
   if (isa<LoadInst>(I))
@@ -1731,7 +1733,8 @@ static void hoist(Instruction &I, const DominatorTree *DT, const Loop *CurLoop,
   LLVM_DEBUG(dbgs() << "LICM hoisting to " << Dest->getNameOrAsOperand() << ": "
                     << I << "\n");
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "Hoisted", &I) << "hoisting "
+    OptimizationRemark h(DEBUG_TYPE, "Hoisted", &I);
+    return h << "hoisting "
                                                          << ore::NV("Inst", &I);
   });
 
@@ -1785,8 +1788,9 @@ static bool isSafeToExecuteUnconditionally(
     auto *LI = dyn_cast<LoadInst>(&Inst);
     if (LI && CurLoop->isLoopInvariant(LI->getPointerOperand()))
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(
-                   DEBUG_TYPE, "LoadWithLoopInvariantAddressCondExecuted", LI)
+        OptimizationRemarkMissed lwliace(
+                   DEBUG_TYPE, "LoadWithLoopInvariantAddressCondExecuted", LI);
+        return lwliace
                << "failed to hoist load with loop-invariant address "
                   "because load is conditionally executed";
       });
@@ -2215,8 +2219,9 @@ bool llvm::promoteLoopAccessesToScalars(
   }
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "PromoteLoopAccessesToScalar",
-                              LoopUses[0])
+    OptimizationRemark plats(DEBUG_TYPE, "PromoteLoopAccessesToScalar",
+                              LoopUses[0]);
+    return plats
            << "Moving accesses to memory location out of the loop";
   });
 
diff --git a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
index 8572a442e784..286d4d8ccda3 100644
--- a/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp
@@ -803,7 +803,8 @@ bool LoopIdiomRecognize::processLoopMemCpy(MemCpyInst *MCI,
 
   if (SizeInBytes != StoreStrideValue && SizeInBytes != -StoreStrideValue) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "SizeStrideUnequal", MCI)
+      OptimizationRemarkMissed ssu(DEBUG_TYPE, "SizeStrideUnequal", MCI);
+      return ssu
              << ore::NV("Inst", "memcpy") << " in "
              << ore::NV("Function", MCI->getFunction())
              << " function will not be hoisted: "
@@ -1314,8 +1315,9 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
     if (mayLoopAccessLocation(StoreBasePtr, ModRefInfo::ModRef, CurLoop,
                               BECount, StoreSizeSCEV, *AA, IgnoredInsts)) {
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "LoopMayAccessStore",
-                                        TheStore)
+        OptimizationRemarkMissed lmas(DEBUG_TYPE, "LoopMayAccessStore",
+                                        TheStore);
+        return lmas
                << ore::NV("Inst", InstRemark) << " in "
                << ore::NV("Function", TheStore->getFunction())
                << " function will not be hoisted: "
@@ -1347,7 +1349,8 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
   if (mayLoopAccessLocation(LoadBasePtr, ModRefInfo::Mod, CurLoop, BECount,
                             StoreSizeSCEV, *AA, IgnoredInsts)) {
     ORE.emit([&]() {
-      return OptimizationRemarkMissed(DEBUG_TYPE, "LoopMayAccessLoad", TheLoad)
+      OptimizationRemarkMissed lmal(DEBUG_TYPE, "LoopMayAccessLoad", TheLoad);
+      return lmal
              << ore::NV("Inst", InstRemark) << " in "
              << ore::NV("Function", TheStore->getFunction())
              << " function will not be hoisted: "
@@ -1435,8 +1438,9 @@ bool LoopIdiomRecognize::processLoopStoreOfLoopLoad(
                     << "\n");
 
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "ProcessLoopStoreOfLoopLoad",
-                              NewCall->getDebugLoc(), Preheader)
+    OptimizationRemark plsoll(DEBUG_TYPE, "ProcessLoopStoreOfLoopLoad",
+                              NewCall->getDebugLoc(), Preheader);
+    return plsoll
            << "Formed a call to "
            << ore::NV("NewFunction", NewCall->getCalledFunction())
            << "() intrinsic from " << ore::NV("Inst", InstRemark)


diff --git a/llvm/lib/Transforms/Scalar/GVN.cpp b/llvm/lib/Transforms/Scalar/GVN.cpp
index 03e8a2507b45..880cde5a68d2 100644
--- a/llvm/lib/Transforms/Scalar/GVN.cpp
+++ b/llvm/lib/Transforms/Scalar/GVN.cpp
@@ -1491,7 +1491,8 @@ void GVNPass::eliminatePartiallyRedundantLoad(
     MD->invalidateCachedPointerInfo(V);
   markInstructionForDeletion(Load);
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "LoadPRE", Load)
+    OptimizationRemark lpre(DEBUG_TYPE, "LoadPRE", Load);
+    return lpre
            << "load eliminated by PRE";
   });
 }
@@ -1834,7 +1835,8 @@ static void reportLoadElim(LoadInst *Load, Value *AvailableValue,
   using namespace ore;
 
   ORE->emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE, "LoadElim", Load)
+    OptimizationRemark le(DEBUG_TYPE, "LoadElim", Load);
+    return le
            << "load of type " << NV("Type", Load->getType()) << " eliminated"
            << setExtraArgs() << " in favor of "
            << NV("InfavorOfValue", AvailableValue);


diff --git a/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp b/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
index b182f46cc515..47f6bb3da426 100644
--- a/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
+++ b/llvm/lib/Transforms/Scalar/AnnotationRemarks.cpp
@@ -67,11 +67,13 @@ static void runImpl(Function &F, const TargetLibraryInfo &TLI) {
     }
   }
 
-  for (const auto &KV : Mapping)
-    ORE.emit(OptimizationRemarkAnalysis(REMARK_PASS, "AnnotationSummary",
-                                        F.getSubprogram(), &F.front())
+  for (const auto &KV : Mapping) {
+    OptimizationRemarkAnalysis as(REMARK_PASS, "AnnotationSummary",
+                                        F.getSubprogram(), &F.front());
+    ORE.emit(as
              << "Annotated " << NV("count", KV.second) << " instructions with "
              << NV("type", KV.first));
+  }
 
   // For each debug location, look for all the instructions with annotations and
   // generate more detailed remarks to be displayed at that location.
diff --git a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
index f2efe60bdf88..752cd2c6387a 100644
--- a/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
+++ b/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp
@@ -378,7 +378,8 @@ struct MainSwitch {
       Instr = SI;
     } else {
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "SwitchNotPredictable", SI)
+        OptimizationRemarkMissed sp(DEBUG_TYPE, "SwitchNotPredictable", SI);
+        return sp
                << "Switch instruction is not predictable.";
       });
     }
@@ -503,8 +504,9 @@ struct AllSwitchPaths {
 
     if (StateDef.empty()) {
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "SwitchNotPredictable",
-                                        Switch)
+        OptimizationRemarkMissed snp(DEBUG_TYPE, "SwitchNotPredictable",
+                                        Switch);
+        return snp
                << "Switch instruction is not predictable.";
       });
       return;
@@ -551,8 +553,9 @@ private:
     // Stop exploring paths after visiting MaxPathLength blocks
     if (PathDepth > MaxPathLength) {
       ORE->emit([&]() {
-        return OptimizationRemarkAnalysis(DEBUG_TYPE, "MaxPathLengthReached",
-                                          Switch)
+        OptimizationRemarkAnalysis mplr(DEBUG_TYPE, "MaxPathLengthReached",
+                                          Switch);
+        return mplr
                << "Exploration stopped after visiting MaxPathLength="
                << ore::NV("MaxPathLength", MaxPathLength) << " blocks.";
       });
@@ -766,8 +769,9 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "non-duplicatable instructions.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "NonDuplicatableInst",
-                                          Switch)
+          OptimizationRemarkMissed ndi(DEBUG_TYPE, "NonDuplicatableInst",
+                                          Switch);
+          return ndi
                  << "Contains non-duplicatable instructions.";
         });
         return false;
@@ -777,7 +781,8 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "convergent instructions.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "ConvergentInst", Switch)
+          OptimizationRemarkMissed c(DEBUG_TYPE, "ConvergentInst", Switch);
+          return c
                  << "Contains convergent instructions.";
         });
         return false;
@@ -787,7 +792,8 @@ private:
         LLVM_DEBUG(dbgs() << "DFA Jump Threading: Not jump threading, contains "
                           << "instructions with invalid cost.\n");
         ORE->emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE, "ConvergentInst", Switch)
+          OptimizationRemarkMissed ci(DEBUG_TYPE, "ConvergentInst", Switch);
+          return ci
                  << "Contains instructions with invalid cost.";
         });
         return false;
@@ -824,7 +830,8 @@ private:
       LLVM_DEBUG(dbgs() << "Not jump threading, duplication cost exceeds the "
                         << "cost threshold.\n");
       ORE->emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "NotProfitable", Switch)
+        OptimizationRemarkMissed np(DEBUG_TYPE, "NotProfitable", Switch);
+        return np
                << "Duplication cost exceeds the cost threshold (cost="
                << ore::NV("Cost", DuplicationCost)
                << ", threshold=" << ore::NV("Threshold", CostThreshold) << ").";
@@ -833,7 +840,8 @@ private:
     }
 
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "JumpThreaded", Switch)
+      OptimizationRemark jt(DEBUG_TYPE, "JumpThreaded", Switch);
+      return jt
              << "Switch statement jump-threaded.";
     });
 


diff --git a/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp b/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
index 5c9799235017..dc53bfff2583 100644
--- a/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
+++ b/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
@@ -181,7 +181,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPInvokeOnly && isa<CallInst>(CB)) {
       LLVM_DEBUG(dbgs() << " Not promote: User options.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UserOptions", &CB)
+        OptimizationRemarkMissed uo(DEBUG_TYPE, "UserOptions", &CB);
+        return uo
                << " Not promote: User options";
       });
       break;
@@ -189,7 +190,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPCallOnly && isa<InvokeInst>(CB)) {
       LLVM_DEBUG(dbgs() << " Not promote: User option.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UserOptions", &CB)
+        OptimizationRemarkMissed uo(DEBUG_TYPE, "UserOptions", &CB);
+        return uo
                << " Not promote: User options";
       });
       break;
@@ -197,7 +199,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (ICPCutOff != 0 && NumOfPGOICallPromotion >= ICPCutOff) {
       LLVM_DEBUG(dbgs() << " Not promote: Cutoff reached.\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "CutOffReached", &CB)
+        OptimizationRemarkMissed cor(DEBUG_TYPE, "CutOffReached", &CB);
+        return cor
                << " Not promote: Cutoff reached";
       });
       break;
@@ -214,7 +217,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
     if (TargetFunction == nullptr || TargetFunction->isDeclaration()) {
       LLVM_DEBUG(dbgs() << " Not promote: Cannot find the target\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnableToFindTarget", &CB)
+        OptimizationRemarkMissed utft(DEBUG_TYPE, "UnableToFindTarget", &CB);
+        return utft
                << "Cannot promote indirect call: target with md5sum "
                << ore::NV("target md5sum", Target) << " not found";
       });
@@ -226,7 +230,8 @@ IndirectCallPromoter::getPromotionCandidatesForCallSite(
       using namespace ore;
 
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "UnableToPromote", &CB)
+        OptimizationRemarkMissed utp(DEBUG_TYPE, "UnableToPromote", &CB);
+        return utp
                << "Cannot promote indirect call to "
                << NV("TargetFunction", TargetFunction) << " with count of "
                << NV("Count", Count) << ": " << Reason;
@@ -266,7 +271,8 @@ CallBase &llvm::pgo::promoteIndirectCall(CallBase &CB, Function *DirectCallee,
 
   if (ORE)
     ORE->emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Promoted", &CB)
+      OptimizationRemark p(DEBUG_TYPE, "Promoted", &CB);
+      return p
              << "Promote indirect call to " << NV("DirectCallee", DirectCallee)
              << " with count " << NV("Count", Count) << " out of "
              << NV("TotalCount", TotalCount);
diff --git a/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp b/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
index 2906fe190984..9203ad6c4ee2 100644
--- a/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
+++ b/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
@@ -446,7 +446,8 @@ bool MemOPSizeOpt::perform(MemOp MO) {
 
   ORE.emit([&]() {
     using namespace ore;
-    return OptimizationRemark(DEBUG_TYPE, "memopt-opt", MO.I)
+    OptimizationRemark mo(DEBUG_TYPE, "memopt-opt", MO.I);
+    return mo
            << "optimized " << NV("Memop", MO.getName(TLI)) << " with count "
            << NV("Count", SumForOpt) << " out of " << NV("Total", TotalCount)
            << " for " << NV("Versions", Version) << " versions";


diff --git a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
index 3c8f25d73c62..f7dc5e6a62d7 100644
--- a/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
+++ b/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
@@ -1956,8 +1956,9 @@ static void verifyFuncBFI(PGOUseFunc &Func, LoopInfo &LI,
   }
   if (BBMisMatchNum)
     ORE.emit([&]() {
-      return OptimizationRemarkAnalysis(DEBUG_TYPE, "bfi-verify",
-                                        F.getSubprogram(), &F.getEntryBlock())
+      OptimizationRemarkAnalysis bv(DEBUG_TYPE, "bfi-verify",
+                                        F.getSubprogram(), &F.getEntryBlock());
+      return bv
              << "In Func " << ore::NV("Function", F.getName())
              << ": Num_of_BB=" << ore::NV("Count", BBNum)
              << ", Num_of_non_zerovalue_BB=" << ore::NV("Count", NonZeroBBNum)
@@ -2238,7 +2239,8 @@ void llvm::setProfMetadata(Module *M, Instruction *TI,
     Function *F = TI->getParent()->getParent();
     OptimizationRemarkEmitter ORE(F);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "pgo-instrumentation", TI)
+      OptimizationRemark pi(DEBUG_TYPE, "pgo-instrumentation", TI);
+      return pi
              << BrCondStr << " is true with probability : " << BranchProbStr;
     });
   }


diff --git a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
index 3e3be536defc..d4fd64b50226 100644
--- a/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
+++ b/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
@@ -778,7 +778,8 @@ CHRScope * CHR::findScope(Region *R) {
         ++Stats.NumBranches;
         if (!RI.HasBranch) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE, "BranchNotBiased", BI)
+            OptimizationRemarkMissed bnb(DEBUG_TYPE, "BranchNotBiased", BI);
+            return bnb
                 << "Branch not biased";
           });
         }
@@ -824,7 +825,8 @@ CHRScope * CHR::findScope(Region *R) {
             RI.Selects.push_back(SI);
           else
             ORE.emit([&]() {
-              return OptimizationRemarkMissed(DEBUG_TYPE, "SelectNotBiased", SI)
+              OptimizationRemarkMissed snb(DEBUG_TYPE, "SelectNotBiased", SI);
+              return snb
                   << "Select not biased";
             });
       };
@@ -900,8 +902,9 @@ void CHR::checkScopeHoistable(CHRScope *Scope) {
       if (!IsHoistable) {
         CHR_DEBUG(dbgs() << "Dropping select " << *SI << "\n");
         ORE.emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE,
-                                          "DropUnhoistableSelect", SI)
+          OptimizationRemarkMissed dus(DEBUG_TYPE,
+                                          "DropUnhoistableSelect", SI);
+          return dus
               << "Dropped unhoistable select";
         });
         it = Selects.erase(it);
@@ -930,8 +933,9 @@ void CHR::checkScopeHoistable(CHRScope *Scope) {
             });
         for (SelectInst *SI : Selects) {
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
-                                            "DropSelectUnhoistableBranch", SI)
+            OptimizationRemarkMissed dsub(DEBUG_TYPE,
+                                            "DropSelectUnhoistableBranch", SI);
+            return dsub
                 << "Dropped select due to unhoistable branch";
           });
         }
@@ -1166,9 +1170,10 @@ SmallVector<CHRScope *, 8> CHR::splitScope(
           PrevConditionValues = ConditionValues;
           PrevInsertPoint = InsertPoint;
           ORE.emit([&]() {
-            return OptimizationRemarkMissed(DEBUG_TYPE,
+            OptimizationRemarkMissed ssfo(DEBUG_TYPE,
                                             "SplitScopeFromOuter",
-                                            RI.R->getEntry()->getTerminator())
+                                            RI.R->getEntry()->getTerminator());
+            return ssfo
                 << "Split scope from outer due to unhoistable branch/select "
                 << "and/or lack of common condition values";
           });
@@ -1202,9 +1207,10 @@ SmallVector<CHRScope *, 8> CHR::splitScope(
         PrevInsertPoint = InsertPoint;
         PrevSplitFromOuter = true;
         ORE.emit([&]() {
-          return OptimizationRemarkMissed(DEBUG_TYPE,
+          OptimizationRemarkMissed ssfp(DEBUG_TYPE,
                                           "SplitScopeFromPrev",
-                                          RI.R->getEntry()->getTerminator())
+                                          RI.R->getEntry()->getTerminator());
+          return ssfp
               << "Split scope from previous due to unhoistable branch/select "
               << "and/or lack of common condition values";
         });
@@ -1330,10 +1336,11 @@ void CHR::filterScopes(SmallVectorImpl<CHRScope *> &Input,
                 << " true-selects " << Scope->TrueBiasedSelects.size()
                 << " false-selects " << Scope->FalseBiasedSelects.size() << "\n");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(
+        OptimizationRemarkMissed dswobos(
             DEBUG_TYPE,
             "DropScopeWithOneBranchOrSelect",
-            Scope->RegInfos[0].R->getEntry()->getTerminator())
+            Scope->RegInfos[0].R->getEntry()->getTerminator());
+        return dswobos
             << "Drop scope with < "
             << ore::NV("CHRMergeThreshold", CHRMergeThreshold)
             << " biased branch(es) or select(s)";
@@ -1685,8 +1692,9 @@ void CHR::transformScopes(CHRScope *Scope, DenseSet<PHINode *> &TrivialPHIs) {
       CHR_DEBUG(dbgs() << "Reached the dup threshold of " << Duplication
                        << " for this region");
       ORE.emit([&]() {
-        return OptimizationRemarkMissed(DEBUG_TYPE, "DupThresholdReached",
-                                        R->getEntry()->getTerminator())
+        OptimizationRemarkMissed dtr(DEBUG_TYPE, "DupThresholdReached",
+                                        R->getEntry()->getTerminator());
+        return dtr
                << "Reached the duplication threshold for the region";
       });
       return;
@@ -1859,10 +1867,11 @@ void CHR::fixupBranchesAndSelects(CHRScope *Scope,
   Stats.NumBranchesDelta += NumCHRedBranches - 1;
   Stats.WeightedNumBranchesDelta += (NumCHRedBranches - 1) * ProfileCount;
   ORE.emit([&]() {
-    return OptimizationRemark(DEBUG_TYPE,
+    OptimizationRemark chr(DEBUG_TYPE,
                               "CHR",
                               // Refer to the hot (original) path
-                              MergedBR->getSuccessor(0)->getTerminator())
+                              MergedBR->getSuccessor(0)->getTerminator());
+    return chr
         << "Merged " << ore::NV("NumCHRedBranches", NumCHRedBranches)
         << " branches or selects";
   });
@@ -2052,7 +2061,8 @@ bool CHR::run() {
   if (Changed) {
     CHR_DEBUG(dumpIR(F, "after", &Stats));
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Stats", &F)
+      OptimizationRemark s(DEBUG_TYPE, "Stats", &F);
+      return s
           << ore::NV("Function", &F) << " "
           << "Reduced the number of branches in hot paths by "
           << ore::NV("NumBranchesDelta", Stats.NumBranchesDelta)


diff --git a/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp b/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
index 5b0951252c07..b26f61cf95ad 100644
--- a/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
+++ b/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
@@ -1011,7 +1011,8 @@ Value *LibCallSimplifier::optimizeStringLength(CallInst *CI, IRBuilderBase &B,
     uint64_t LenFalse = GetStringLength(SI->getFalseValue(), CharSize);
     if (LenTrue && LenFalse) {
       ORE.emit([&]() {
-        return OptimizationRemark("instcombine", "simplify-libcalls", CI)
+        OptimizationRemark ic("instcombine", "simplify-libcalls", CI);
+        return ic
                << "folded strlen(select) to select of constants";
       });
       return B.CreateSelect(SI->getCondition(),


diff --git a/llvm/lib/Transforms/Utils/MisExpect.cpp b/llvm/lib/Transforms/Utils/MisExpect.cpp
index 6f5a25a26821..400a372ef4d1 100644
--- a/llvm/lib/Transforms/Utils/MisExpect.cpp
+++ b/llvm/lib/Transforms/Utils/MisExpect.cpp
@@ -112,7 +112,8 @@ void emitMisexpectDiagnostic(Instruction *I, LLVMContext &Ctx,
   if (isMisExpectDiagEnabled(Ctx))
     Ctx.diagnose(DiagnosticInfoMisExpect(Cond, Msg));
   OptimizationRemarkEmitter ORE(I->getParent()->getParent());
-  ORE.emit(OptimizationRemark(DEBUG_TYPE, "misexpect", Cond) << RemStr.str());
+  OptimizationRemark me(DEBUG_TYPE, "misexpect", Cond);
+  ORE.emit(me << RemStr.str());
 }
 
 } // namespace


diff --git a/llvm/lib/Transforms/Utils/LoopUnroll.cpp b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
index 511dd61308f9..c722831cb06e 100644
--- a/llvm/lib/Transforms/Utils/LoopUnroll.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnroll.cpp
@@ -461,8 +461,9 @@ LoopUnrollResult llvm::UnrollLoop(Loop *L, UnrollLoopOptions ULO, LoopInfo *LI,
                       << " with trip count " << ULO.Count << "!\n");
     if (ORE)
       ORE->emit([&]() {
-        return OptimizationRemark(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
-                                  L->getHeader())
+        OptimizationRemark fu(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
+                                  L->getHeader());
+        return fu
                << "completely unrolled loop with "
                << NV("UnrollCount", ULO.Count) << " iterations";
       });
diff --git a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
index 31b8cd34eb24..342e5908648e 100644
--- a/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
@@ -264,8 +264,9 @@ llvm::UnrollAndJamLoop(Loop *L, unsigned Count, unsigned TripCount,
     LLVM_DEBUG(dbgs() << "COMPLETELY UNROLL AND JAMMING loop %"
                       << Header->getName() << " with trip count " << TripCount
                       << "!\n");
-    ORE->emit(OptimizationRemark(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
-                                 L->getHeader())
+    OptimizationRemark fu(DEBUG_TYPE, "FullyUnrolled", L->getStartLoc(),
+                                 L->getHeader());
+    ORE->emit(fu
               << "completely unroll and jammed loop with "
               << NV("UnrollCount", TripCount) << " iterations");
   } else {
@@ -281,12 +282,13 @@ llvm::UnrollAndJamLoop(Loop *L, unsigned Count, unsigned TripCount,
     if (TripMultiple != 1) {
       LLVM_DEBUG(dbgs() << " with " << TripMultiple << " trips per branch");
       ORE->emit([&]() {
-        return DiagBuilder() << " with " << NV("TripMultiple", TripMultiple)
+        auto dlg = DiagBuilder();
+        return dlg << " with " << NV("TripMultiple", TripMultiple)
                              << " trips per branch";
       });
     } else {
       LLVM_DEBUG(dbgs() << " with run-time trip count");
-      ORE->emit([&]() { return DiagBuilder() << " with run-time trip count"; });
+      ORE->emit([&]() { auto dlg = DiagBuilder(); return dlg << " with run-time trip count"; });
     }
     LLVM_DEBUG(dbgs() << "!\n");
   }


diff --git a/polly/lib/Transform/ManualOptimizer.cpp b/polly/lib/Transform/ManualOptimizer.cpp
index 264491b7577b..e9b20a2ac30e 100644
--- a/polly/lib/Transform/ManualOptimizer.cpp
+++ b/polly/lib/Transform/ManualOptimizer.cpp
@@ -167,8 +167,8 @@ private:
       LLVM_DEBUG(dbgs() << "Still accepting transformation due to "
                            "-polly-pragma-ignore-depcheck\n");
       if (ORE) {
-        ORE->emit(
-            OptimizationRemark(DEBUG_TYPE, RemarkName, TransformLoc, CodeRegion)
+        OptimizationRemark ppid(DEBUG_TYPE, RemarkName, TransformLoc, CodeRegion);
+        ORE->emit(ppid
             << (Twine("Could not verify dependencies for ") +
                 TransformationName +
                 "; still applying because of -polly-pragma-ignore-depcheck")
@@ -180,8 +180,9 @@ private:
     LLVM_DEBUG(dbgs() << "Rolling back transformation\n");
 
     if (ORE) {
-      ORE->emit(DiagnosticInfoOptimizationFailure(DEBUG_TYPE, RemarkName,
-                                                  TransformLoc, CodeRegion)
+      DiagnosticInfoOptimizationFailure diof(DEBUG_TYPE, RemarkName,
+                                                  TransformLoc, CodeRegion);
+      ORE->emit(diof
                 << (Twine("not applying ") + TransformationName +
                     ": cannot ensure semantic equivalence due to possible "
                     "dependency violations")


diff --git a/polly/lib/Transform/MaximalStaticExpansion.cpp b/polly/lib/Transform/MaximalStaticExpansion.cpp
index e32a69d47f69..5aefb6e3bf32 100644
--- a/polly/lib/Transform/MaximalStaticExpansion.cpp
+++ b/polly/lib/Transform/MaximalStaticExpansion.cpp
@@ -80,8 +80,8 @@ class MaximalStaticExpansionImpl {
 
   /// Emit remark
   void emitRemark(StringRef Msg, Instruction *Inst) {
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ExpansionRejection", Inst)
-             << Msg);
+    OptimizationRemarkAnalysis er(DEBUG_TYPE, "ExpansionRejection", Inst);
+    ORE.emit(er << Msg);
   }
 
   /// Filter the dependences to have only one related to current memory access.


diff --git a/polly/lib/Analysis/ScopBuilder.cpp b/polly/lib/Analysis/ScopBuilder.cpp
index 0e3de8b5b6c5..3d09e4f1c330 100644
--- a/polly/lib/Analysis/ScopBuilder.cpp
+++ b/polly/lib/Analysis/ScopBuilder.cpp
@@ -1377,9 +1377,8 @@ void ScopBuilder::addUserAssumptions(
     ParameterSetTy DetectedParams;
     auto &R = scop->getRegion();
     if (!isAffineConstraint(Val, &R, L, SE, DetectedParams)) {
-      ORE.emit(
-          OptimizationRemarkAnalysis(DEBUG_TYPE, "IgnoreUserAssumption", CI)
-          << "Non-affine user assumption ignored.");
+      OptimizationRemarkAnalysis iua(DEBUG_TYPE, "IgnoreUserAssumption", CI);
+      ORE.emit(iua << "Non-affine user assumption ignored.");
       continue;
     }
 
@@ -1429,8 +1428,8 @@ void ScopBuilder::addUserAssumptions(
             isl_set_project_out(AssumptionCtx, isl_dim_param, u--, 1);
       }
     }
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "UserAssumption", CI)
-             << "Use user assumption: "
+    OptimizationRemarkAnalysis ua(DEBUG_TYPE, "UserAssumption", CI);
+    ORE.emit(ua << "Use user assumption: "
              << stringFromIslObj(AssumptionCtx, "null"));
     isl::set newContext =
         scop->getContext().intersect(isl::manage(AssumptionCtx));
@@ -3291,8 +3290,9 @@ bool ScopBuilder::buildAliasGroup(
     return true;
 
   for (MemoryAccess *Access : AliasGroup) {
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "PossibleAlias",
-                                        Access->getAccessInstruction())
+    OptimizationRemarkAnalysis pa(DEBUG_TYPE, "PossibleAlias",
+                                        Access->getAccessInstruction());
+    ORE.emit(pa
              << "Possibly aliasing pointer, use restrict keyword.");
     const ScopArrayInfo *Array = Access->getScopArrayInfo();
     if (HasWriteAccess.count(Array)) {
@@ -3615,8 +3615,8 @@ ScopBuilder::ScopBuilder(Region *R, AssumptionCache &AC, AAResults &AA,
   getDebugLocations(P, Beg, End);
 
   std::string Msg = "SCoP begins here.";
-  ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEntry", Beg, P.first)
-           << Msg);
+  OptimizationRemarkAnalysis se(DEBUG_TYPE, "ScopEntry", Beg, P.first);
+  ORE.emit(se << Msg);
 
   buildScop(*R, AC);
 
@@ -3635,10 +3635,11 @@ ScopBuilder::ScopBuilder(Region *R, AssumptionCache &AC, AAResults &AA,
       ++RichScopFound;
   }
 
-  if (R->isTopLevelRegion())
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEnd", End, P.first)
-             << Msg);
-  else
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "ScopEnd", End, P.second)
-             << Msg);
+  if (R->isTopLevelRegion()) {
+    OptimizationRemarkAnalysis setlr(DEBUG_TYPE, "ScopEnd", End, P.first);
+    ORE.emit(setlr << Msg);
+  } else {
+    OptimizationRemarkAnalysis sentlr(DEBUG_TYPE, "ScopEnd", End, P.second);
+    ORE.emit(sentlr << Msg);
+  }
 }
diff --git a/polly/lib/Analysis/ScopDetectionDiagnostic.cpp b/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
index 0bac2cfd1555..327fb6bcc1ba 100644
--- a/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
+++ b/polly/lib/Analysis/ScopDetectionDiagnostic.cpp
@@ -137,31 +137,31 @@ void emitRejectionRemarks(const BBPair &P, const RejectLog &Log,
   DebugLoc Begin, End;
   getDebugLocations(P, Begin, End);
 
-  ORE.emit(
-      OptimizationRemarkMissed(DEBUG_TYPE, "RejectionErrors", Begin, P.first)
+  OptimizationRemarkMissed re(DEBUG_TYPE, "RejectionErrors", Begin, P.first);
+  ORE.emit(re
       << "The following errors keep this region from being a Scop.");
 
   for (RejectReasonPtr RR : Log) {
 
-    if (const DebugLoc &Loc = RR->getDebugLoc())
-      ORE.emit(OptimizationRemarkMissed(DEBUG_TYPE, RR->getRemarkName(), Loc,
-                                        RR->getRemarkBB())
-               << RR->getEndUserMessage());
-    else
-      ORE.emit(OptimizationRemarkMissed(DEBUG_TYPE, RR->getRemarkName(), Begin,
-                                        RR->getRemarkBB())
-               << RR->getEndUserMessage());
+    if (const DebugLoc &Loc = RR->getDebugLoc()) {
+      OptimizationRemarkMissed dl(DEBUG_TYPE, RR->getRemarkName(), Loc,
+                                        RR->getRemarkBB());
+      ORE.emit(dl << RR->getEndUserMessage());
+    } else {
+      OptimizationRemarkMissed ndl(DEBUG_TYPE, RR->getRemarkName(), Begin,
+                                        RR->getRemarkBB());
+      ORE.emit(ndl << RR->getEndUserMessage());
+    }
   }
 
   /* Check to see if Region is a top level region, getExit = NULL*/
-  if (P.second)
-    ORE.emit(
-        OptimizationRemarkMissed(DEBUG_TYPE, "InvalidScopEnd", End, P.second)
-        << "Invalid Scop candidate ends here.");
-  else
-    ORE.emit(
-        OptimizationRemarkMissed(DEBUG_TYPE, "InvalidScopEnd", End, P.first)
-        << "Invalid Scop candidate ends here.");
+  if (P.second) {
+    OptimizationRemarkMissed is(DEBUG_TYPE, "InvalidScopEnd", End, P.second);
+    ORE.emit(is << "Invalid Scop candidate ends here.");
+  } else {
+    OptimizationRemarkMissed ise(DEBUG_TYPE, "InvalidScopEnd", End, P.first);
+    ORE.emit(ise << "Invalid Scop candidate ends here.");
+  }
 }
 
 //===----------------------------------------------------------------------===//


diff --git a/polly/lib/Analysis/ScopInfo.cpp b/polly/lib/Analysis/ScopInfo.cpp
index ffa61bb7787f..04ced7e48165 100644
--- a/polly/lib/Analysis/ScopInfo.cpp
+++ b/polly/lib/Analysis/ScopInfo.cpp
@@ -1994,13 +1994,14 @@ bool Scop::trackAssumption(AssumptionKind Kind, isl::set Set, DebugLoc Loc,
 
   auto Suffix = Sign == AS_ASSUMPTION ? " assumption:\t" : " restriction:\t";
   std::string Msg = toString(Kind) + Suffix + stringFromIslObj(Set);
-  if (BB)
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "AssumpRestrict", Loc, BB)
-             << Msg);
-  else
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, "AssumpRestrict", Loc,
-                                        R.getEntry())
-             << Msg);
+  if (BB) {
+    OptimizationRemarkAnalysis arbb(DEBUG_TYPE, "AssumpRestrict", Loc, BB);
+    ORE.emit(arbb << Msg);
+  } else {
+    OptimizationRemarkAnalysis ar(DEBUG_TYPE, "AssumpRestrict", Loc,
+                                        R.getEntry());
+    ORE.emit(ar << Msg);
+  }
   return true;
 }
 


diff --git a/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp b/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
index 7cd8e53e6521..eabc643fe831 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp
@@ -1273,9 +1273,10 @@ void AMDGPUAsmPrinter::emitResourceUsageRemarks(
       LabelStr = Indent + LabelStr;
 
     ORE->emit([&]() {
-      return MachineOptimizationRemarkAnalysis(Name, RemarkName,
+      MachineOptimizationRemarkAnalysis mora(Name, RemarkName,
                                                MF.getFunction().getSubprogram(),
-                                               &MF.front())
+                                               &MF.front());
+      return mora
              << LabelStr << ore::NV(RemarkName, Argument);
     });
   };


diff --git a/llvm/lib/Target/AMDGPU/SIISelLowering.cpp b/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
index 3148f49ff0d5..d89f56e843d3 100644
--- a/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
+++ b/llvm/lib/Target/AMDGPU/SIISelLowering.cpp
@@ -14048,9 +14048,9 @@ SITargetLowering::shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {
     auto MemScope = SSNs[RMW->getSyncScopeID()].empty()
                         ? "system"
                         : SSNs[RMW->getSyncScopeID()];
+    OptimizationRemark p(DEBUG_TYPE, "Passed", RMW);
     ORE.emit([&]() {
-      return OptimizationRemark(DEBUG_TYPE, "Passed", RMW)
-             << "Hardware instruction generated for atomic "
+      return p << "Hardware instruction generated for atomic "
              << RMW->getOperationName(RMW->getOperation())
              << " operation at memory scope " << MemScope
              << " due to an unsafe request.";


diff --git a/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp b/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
index 580352fb8cf4..a5d6ef47a5eb 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPURemoveIncompatibleFunctions.cpp
@@ -115,7 +115,8 @@ void reportFunctionRemoved(Function &F, unsigned Feature) {
     // debug info is not present, users get "<unknown>:0:0" as the debug
     // loc. If we didn't print the function name there would be no way to
     // tell which function got removed.
-    return OptimizationRemark(DEBUG_TYPE, "AMDGPUIncompatibleFnRemoved", &F)
+    OptimizationRemark amdgpuifr(DEBUG_TYPE, "AMDGPUIncompatibleFnRemoved", &F);
+    return amdgpuifr
            << "removing function '" << F.getName() << "': +"
            << getFeatureName(Feature)
            << " is not supported on the current target";


diff --git a/llvm/lib/Transforms/Scalar/LoopFuse.cpp b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
index d35b562be0aa..5a051cc90d94 100644
--- a/llvm/lib/Transforms/Scalar/LoopFuse.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopFuse.cpp
@@ -373,8 +373,9 @@ private:
     assert(L && Preheader && "Fusion candidate not initialized properly!");
 #if LLVM_ENABLE_STATS
     ++Stat;
-    ORE.emit(OptimizationRemarkAnalysis(DEBUG_TYPE, Stat.getName(),
-                                        L->getStartLoc(), Preheader)
+    OptimizationRemarkAnalysis ora(DEBUG_TYPE, Stat.getName(),
+                                        L->getStartLoc(), Preheader);
+    ORE.emit(ora
              << "[" << Preheader->getParent()->getName() << "]: "
              << "Loop is not a candidate for fusion: " << Stat.getDesc());
 #endif
@@ -1785,8 +1786,9 @@ private:
     using namespace ore;
 #if LLVM_ENABLE_STATS
     ++Stat;
-    ORE.emit(RemarkKind(DEBUG_TYPE, Stat.getName(), FC0.L->getStartLoc(),
-                        FC0.Preheader)
+    RemarkKind rk(DEBUG_TYPE, Stat.getName(), FC0.L->getStartLoc(),
+                        FC0.Preheader);
+    ORE.emit(rk
              << "[" << FC0.Preheader->getParent()->getName()
              << "]: " << NV("Cand1", StringRef(FC0.Preheader->getName()))
              << " and " << NV("Cand2", StringRef(FC1.Preheader->getName()))


diff --git a/lld/MachO/InputFiles.cpp b/lld/MachO/InputFiles.cpp
index c89f6f4722dc..f1fc12d98e17 100644
--- a/lld/MachO/InputFiles.cpp
+++ b/lld/MachO/InputFiles.cpp
@@ -2218,6 +2218,8 @@ BitcodeFile::BitcodeFile(MemoryBufferRef mb, StringRef archiveName,
     parse();
 }
 
+BitcodeFile::~BitcodeFile() {}
+
 void BitcodeFile::parse() {
   // Convert LTO Symbols to LLD Symbols in order to perform resolution. The
   // "winning" symbol will then be marked as Prevailing at LTO compilation
diff --git a/lld/MachO/InputFiles.h b/lld/MachO/InputFiles.h
index 66d46e46fa73..21e865e8af63 100644
--- a/lld/MachO/InputFiles.h
+++ b/lld/MachO/InputFiles.h
@@ -302,6 +302,7 @@ public:
   explicit BitcodeFile(MemoryBufferRef mb, StringRef archiveName,
                        uint64_t offsetInArchive, bool lazy = false,
                        bool forceHidden = false);
+  ~BitcodeFile();
   static bool classof(const InputFile *f) { return f->kind() == BitcodeKind; }
   void parse();
 


diff --git a/llvm/lib/Support/BalancedPartitioning.cpp b/llvm/lib/Support/BalancedPartitioning.cpp
index 113e9484f528..ceab4a8970e0 100644
--- a/llvm/lib/Support/BalancedPartitioning.cpp
+++ b/llvm/lib/Support/BalancedPartitioning.cpp
@@ -31,7 +31,7 @@ void BalancedPartitioning::BPThreadPool::async(Func &&F) {
 #if LLVM_ENABLE_THREADS
   // This new thread could spawn more threads, so mark it as active
   ++NumActiveThreads;
-  TheThreadPool.async([=]() {
+  TheThreadPool.async([=, this]() {
     // Run the task
     F();
 
@@ -93,7 +93,7 @@ void BalancedPartitioning::run(std::vector<BPFunctionNode> &Nodes) const {
     Nodes[I].InputOrderIndex = I;
 
   auto NodesRange = llvm::make_range(Nodes.begin(), Nodes.end());
-  auto BisectTask = [=, &TP]() {
+  auto BisectTask = [=, this, &TP]() {
     bisect(NodesRange, /*RecDepth=*/0, /*RootBucket=*/1, /*Offset=*/0, TP);
   };
   if (TP) {
@@ -147,10 +147,10 @@ void BalancedPartitioning::bisect(const FunctionNodeRange Nodes,
   auto LeftNodes = llvm::make_range(Nodes.begin(), NodesMid);
   auto RightNodes = llvm::make_range(NodesMid, Nodes.end());
 
-  auto LeftRecTask = [=, &TP]() {
+  auto LeftRecTask = [=, this, &TP]() {
     bisect(LeftNodes, RecDepth + 1, LeftBucket, Offset, TP);
   };
-  auto RightRecTask = [=, &TP]() {
+  auto RightRecTask = [=, this, &TP]() {
     bisect(RightNodes, RecDepth + 1, RightBucket, MidOffset, TP);
   };
 


diff --git a/clang/lib/Sema/SemaPseudoObject.cpp b/clang/lib/Sema/SemaPseudoObject.cpp
index 408f71044fa3..cf6f02825764 100644
--- a/clang/lib/Sema/SemaPseudoObject.cpp
+++ b/clang/lib/Sema/SemaPseudoObject.cpp
@@ -709,7 +709,7 @@ Expr *ObjCPropertyOpBuilder::rebuildAndCaptureObject(Expr *syntacticBase) {
   // form to use the OVE as its base.
   if (RefExpr->isObjectReceiver()) {
     InstanceReceiver = capture(RefExpr->getBase());
-    syntacticBase = Rebuilder(S, [=](Expr *, unsigned) -> Expr * {
+    syntacticBase = Rebuilder(S, [=, this](Expr *, unsigned) -> Expr * {
                       return InstanceReceiver;
                     }).rebuild(syntacticBase);
   }
@@ -1030,7 +1030,7 @@ Expr *ObjCSubscriptOpBuilder::rebuildAndCaptureObject(Expr *syntacticBase) {
   InstanceKey = capture(RefExpr->getKeyExpr());
 
   syntacticBase =
-      Rebuilder(S, [=](Expr *, unsigned Idx) -> Expr * {
+      Rebuilder(S, [=, this](Expr *, unsigned Idx) -> Expr * {
         switch (Idx) {
         case 0:
           return InstanceBase;
@@ -1452,7 +1452,7 @@ MSPropertyOpBuilder::getBaseMSProperty(MSPropertySubscriptExpr *E) {
 Expr *MSPropertyOpBuilder::rebuildAndCaptureObject(Expr *syntacticBase) {
   InstanceBase = capture(RefExpr->getBaseExpr());
   llvm::for_each(CallArgs, [this](Expr *&Arg) { Arg = capture(Arg); });
-  syntacticBase = Rebuilder(S, [=](Expr *, unsigned Idx) -> Expr * {
+  syntacticBase = Rebuilder(S, [=, this](Expr *, unsigned Idx) -> Expr * {
                     switch (Idx) {
                     case 0:
                       return InstanceBase;


diff --git a/clang/lib/CodeGen/CGBuiltin.cpp b/clang/lib/CodeGen/CGBuiltin.cpp
index 30f5f4e7061c..8238779113ca 100644
--- a/clang/lib/CodeGen/CGBuiltin.cpp
+++ b/clang/lib/CodeGen/CGBuiltin.cpp
@@ -5046,7 +5046,7 @@ RValue CodeGenFunction::EmitBuiltinExpr(const GlobalDecl GD, unsigned BuiltinID,
 
     // Create a temporary array to hold the sizes of local pointer arguments
     // for the block. \p First is the position of the first size argument.
-    auto CreateArrayForSizeVar = [=](unsigned First)
+    auto CreateArrayForSizeVar = [=, this](unsigned First)
         -> std::tuple<llvm::Value *, llvm::Value *, llvm::Value *> {
       llvm::APInt ArraySize(32, NumArgs - First);
       QualType SizeArrayTy = getContext().getConstantArrayType(



diff --git a/lld/ELF/OutputSections.cpp b/lld/ELF/OutputSections.cpp
index 0b9b76e5b832..7b96051d9eaf 100644
--- a/lld/ELF/OutputSections.cpp
+++ b/lld/ELF/OutputSections.cpp
@@ -487,7 +487,7 @@ void OutputSection::writeTo(uint8_t *buf, parallel::TaskGroup &tg) {
   if (nonZeroFiller)
     fill(buf, sections.empty() ? size : sections[0]->outSecOff, filler);
 
-  auto fn = [=](size_t begin, size_t end) {
+  auto fn = [=, this](size_t begin, size_t end) {
     size_t numSections = sections.size();
     for (size_t i = begin; i != end; ++i) {
       InputSection *isec = sections[i];



diff --git a/clang/include/clang/AST/ASTNodeTraverser.h b/clang/include/clang/AST/ASTNodeTraverser.h
index d649ef6816ca..a2425baf7463 100644
--- a/clang/include/clang/AST/ASTNodeTraverser.h
+++ b/clang/include/clang/AST/ASTNodeTraverser.h
@@ -89,7 +89,7 @@ public:
     if (Traversal == TK_IgnoreUnlessSpelledInSource && D->isImplicit())
       return;
 
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(D);
       if (!D)
         return;
@@ -121,7 +121,7 @@ public:
   }
 
   void Visit(const Stmt *Node, StringRef Label = {}) {
-    getNodeDelegate().AddChild(Label, [=] {
+    getNodeDelegate().AddChild(Label, [=, this] {
       const Stmt *S = Node;
 
       if (auto *E = dyn_cast_or_null<Expr>(S)) {
@@ -162,14 +162,14 @@ public:
     if (!SQT.Quals.hasQualifiers())
       return Visit(SQT.Ty);
 
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(T);
       Visit(T.split().Ty);
     });
   }
 
   void Visit(const Type *T) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(T);
       if (!T)
         return;
@@ -183,7 +183,7 @@ public:
   }
 
   void Visit(const Attr *A) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(A);
       ConstAttrVisitor<Derived>::Visit(A);
     });
@@ -192,7 +192,7 @@ public:
   void Visit(const CXXCtorInitializer *Init) {
     if (Traversal == TK_IgnoreUnlessSpelledInSource && !Init->isWritten())
       return;
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(Init);
       Visit(Init->getInit());
     });
@@ -200,14 +200,14 @@ public:
 
   void Visit(const TemplateArgument &A, SourceRange R = {},
              const Decl *From = nullptr, const char *Label = nullptr) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(A, R, From, Label);
       ConstTemplateArgumentVisitor<Derived>::Visit(A);
     });
   }
 
   void Visit(const BlockDecl::Capture &C) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(C);
       if (C.hasCopyExpr())
         Visit(C.getCopyExpr());
@@ -215,7 +215,7 @@ public:
   }
 
   void Visit(const OMPClause *C) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(C);
       for (const auto *S : C->children())
         Visit(S);
@@ -223,7 +223,7 @@ public:
   }
 
   void Visit(const GenericSelectionExpr::ConstAssociation &A) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(A);
       if (const TypeSourceInfo *TSI = A.getTypeSourceInfo())
         Visit(TSI->getType());
@@ -232,7 +232,7 @@ public:
   }
 
   void Visit(const concepts::Requirement *R) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(R);
       if (!R)
         return;
@@ -254,11 +254,11 @@ public:
   }
 
   void Visit(const APValue &Value, QualType Ty) {
-    getNodeDelegate().AddChild([=] { getNodeDelegate().Visit(Value, Ty); });
+    getNodeDelegate().AddChild([=, this] { getNodeDelegate().Visit(Value, Ty); });
   }
 
   void Visit(const comments::Comment *C, const comments::FullComment *FC) {
-    getNodeDelegate().AddChild([=] {
+    getNodeDelegate().AddChild([=, this] {
       getNodeDelegate().Visit(C, FC);
       if (!C) {
         return;


diff --git a/clang/include/clang/AST/JSONNodeDumper.h b/clang/include/clang/AST/JSONNodeDumper.h
index 5e2756f2a203..b8776a9ab095 100644
--- a/clang/include/clang/AST/JSONNodeDumper.h
+++ b/clang/include/clang/AST/JSONNodeDumper.h
@@ -69,7 +69,7 @@ public:
     // is invoked in a deferred manner.
     std::string LabelStr(!Label.empty() ? Label : "inner");
     bool WasFirstChild = FirstChild;
-    auto DumpWithIndent = [=](bool IsLastChild) {
+    auto DumpWithIndent = [=, this](bool IsLastChild) {
       if (WasFirstChild) {
         JOS.attributeBegin(LabelStr);
         JOS.arrayBegin();
@@ -389,7 +389,7 @@ class JSONDumper : public ASTNodeTraverser<JSONDumper, JSONNodeDumper> {
       case TSK_Undeclared:
       case TSK_ImplicitInstantiation:
         if (DumpRefOnly)
-          NodeDumper.AddChild([=] { NodeDumper.writeBareDeclRef(Redecl); });
+          NodeDumper.AddChild([=, this] { NodeDumper.writeBareDeclRef(Redecl); });
         else
           Visit(Redecl);
         DumpedAny = true;
@@ -401,7 +401,7 @@ class JSONDumper : public ASTNodeTraverser<JSONDumper, JSONNodeDumper> {
 
     // Ensure we dump at least one decl for each specialization.
     if (!DumpedAny)
-      NodeDumper.AddChild([=] { NodeDumper.writeBareDeclRef(SD); });
+      NodeDumper.AddChild([=, this] { NodeDumper.writeBareDeclRef(SD); });
   }
 
   template <typename TemplateDecl>


diff --git a/clang/lib/AST/ASTDumper.cpp b/clang/lib/AST/ASTDumper.cpp
index 9900efb5a48d..3a143e6b832c 100644
--- a/clang/lib/AST/ASTDumper.cpp
+++ b/clang/lib/AST/ASTDumper.cpp
@@ -24,7 +24,7 @@ using namespace clang;
 using namespace clang::comments;
 
 void ASTDumper::dumpInvalidDeclContext(const DeclContext *DC) {
-  NodeDumper.AddChild([=] {
+  NodeDumper.AddChild([=, this] {
     if (!DC) {
       ColorScope Color(OS, ShowColors, NullColor);
       OS << "<<<NULL>>>";
@@ -51,7 +51,7 @@ void ASTDumper::dumpInvalidDeclContext(const DeclContext *DC) {
 }
 
 void ASTDumper::dumpLookups(const DeclContext *DC, bool DumpDecls) {
-  NodeDumper.AddChild([=] {
+  NodeDumper.AddChild([=, this] {
     OS << "StoredDeclsMap ";
     NodeDumper.dumpBareDeclRef(cast<Decl>(DC));
 
@@ -70,7 +70,7 @@ void ASTDumper::dumpLookups(const DeclContext *DC, bool DumpDecls) {
       DeclarationName Name = I.getLookupName();
       DeclContextLookupResult R = *I;
 
-      NodeDumper.AddChild([=] {
+      NodeDumper.AddChild([=, this] {
         OS << "DeclarationName ";
         {
           ColorScope Color(OS, ShowColors, DeclNameColor);
@@ -79,7 +79,7 @@ void ASTDumper::dumpLookups(const DeclContext *DC, bool DumpDecls) {
 
         for (DeclContextLookupResult::iterator RI = R.begin(), RE = R.end();
              RI != RE; ++RI) {
-          NodeDumper.AddChild([=] {
+          NodeDumper.AddChild([=, this] {
             NodeDumper.dumpBareDeclRef(*RI);
 
             if (!(*RI)->isUnconditionallyVisible())
@@ -101,7 +101,7 @@ void ASTDumper::dumpLookups(const DeclContext *DC, bool DumpDecls) {
     }
 
     if (HasUndeserializedLookups) {
-      NodeDumper.AddChild([=] {
+      NodeDumper.AddChild([=, this] {
         ColorScope Color(OS, ShowColors, UndeserializedColor);
         OS << "<undeserialized lookups>";
       });


diff --git a/llvm/cmake/modules/CrossCompile.cmake b/llvm/cmake/modules/CrossCompile.cmake
index 6af47b51d4c6..aa62d8a9a514 100644
--- a/llvm/cmake/modules/CrossCompile.cmake
+++ b/llvm/cmake/modules/CrossCompile.cmake
@@ -4,14 +4,24 @@ include(LLVMExternalProjectUtils)
 
 function(llvm_create_cross_target project_name target_name toolchain buildtype)
 
+  message(WARNING "Current function scope \${CMAKE_BINARY_DIR} = ${CMAKE_BINARY_DIR}")
+
   if(NOT DEFINED ${project_name}_${target_name}_BUILD)
-    set(${project_name}_${target_name}_BUILD
-      "${CMAKE_CURRENT_BINARY_DIR}/${target_name}")
+
+    if(CMAKE_BINARY_DIR MATCHES ".*/${target_name}$")
+      set(${project_name}_${target_name}_BUILD
+        "${CMAKE_BINARY_DIR}")
+    else()
+      set(${project_name}_${target_name}_BUILD
+        "${CMAKE_BINARY_DIR}/${target_name}")
+    endif()
     set(${project_name}_${target_name}_BUILD
       ${${project_name}_${target_name}_BUILD} PARENT_SCOPE)
-    message(STATUS "Setting native build dir to " ${${project_name}_${target_name}_BUILD})
+    message(STATUS "Initializing native build dir to \"${${project_name}_${target_name}_BUILD}\"")
   endif(NOT DEFINED ${project_name}_${target_name}_BUILD)
 
+  message(WARNING "Got native build dir \"${${project_name}_${target_name}_BUILD}\"")
+
   if (EXISTS ${LLVM_MAIN_SRC_DIR}/cmake/platforms/${toolchain}.cmake)
     set(CROSS_TOOLCHAIN_FLAGS_INIT
       -DCMAKE_TOOLCHAIN_FILE=\"${LLVM_MAIN_SRC_DIR}/cmake/platforms/${toolchain}.cmake\")


# diff --git a/llvm/tools/llvm-config/CMakeLists.txt b/llvm/tools/llvm-config/CMakeLists.txt
# index 35b8b215605d..5b3b84613092 100644
# --- a/llvm/tools/llvm-config/CMakeLists.txt
# +++ b/llvm/tools/llvm-config/CMakeLists.txt
# @@ -92,6 +92,21 @@ endif()
#  add_file_dependencies(${CMAKE_CURRENT_SOURCE_DIR}/llvm-config.cpp ${BUILDVARIABLES_OBJPATH})
#  
#  if(CMAKE_CROSSCOMPILING)
# +  if (((NOT DEFINED LLVM_NATIVE_TOOL_DIR) OR LLVM_NATIVE_TOOL_DIR STREQUAL "") AND (NOT $ENV{LLVM_NATIVE_TOOL_DIR} STREQUAL ""))
# +    set(LLVM_NATIVE_TOOL_DIR "$ENV{LLVM_NATIVE_TOOL_DIR}" CACHE INTERNAL "")
# +  endif()
# +
# +  if ((NOT DEFINED LLVM_NATIVE_TOOL_DIR) OR LLVM_NATIVE_TOOL_DIR STREQUAL "")
# +    message(WARNING "\${LLVM_NATIVE_TOOL_DIR}    = ${LLVM_NATIVE_TOOL_DIR}")
# +    if(NOT $ENV{LLVM_NATIVE_TOOL_DIR} STREQUAL "")
# +      message(WARNING "\$ENV{LLVM_NATIVE_TOOL_DIR} = $ENV{LLVM_NATIVE_TOOL_DIR}")
# +      set(LLVM_NATIVE_TOOL_DIR "$ENV{LLVM_NATIVE_TOOL_DIR}" CACHE INTERNAL "")
# +    endif()
# +  endif()
# +  message(WARNING "\$ENV{LLVM_NATIVE_TOOL_DIR} = $ENV{LLVM_NATIVE_TOOL_DIR}")
# +  message(WARNING "\${LLVM_NATIVE_TOOL_DIR}    = ${LLVM_NATIVE_TOOL_DIR}")
# +  message(WARNING "\${LLVM_CONFIG_PATH}        = ${LLVM_CONFIG_PATH}")
# +
#    if (LLVM_NATIVE_TOOL_DIR AND NOT LLVM_CONFIG_PATH)
#      if (EXISTS "${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}")
#        set(LLVM_CONFIG_PATH "${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}")


diff --git a/llvm/tools/llvm-config/CMakeLists.txt b/llvm/tools/llvm-config/CMakeLists.txt
index 35b8b215605d..dd5a4b39544c 100644
--- a/llvm/tools/llvm-config/CMakeLists.txt
+++ b/llvm/tools/llvm-config/CMakeLists.txt
@@ -57,6 +57,7 @@ string(REGEX MATCH "-std=[^ ]+" LLVM_C_STD_FLAG ${CMAKE_C_FLAGS})
 # Use configure_file to create BuildVariables.inc.
 set(LLVM_SRC_ROOT ${LLVM_MAIN_SRC_DIR})
 set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR})
+message(WARNING "\${LLVM_OBJ_ROOT}        = ${LLVM_OBJ_ROOT}")
 set(LLVM_CPPFLAGS "${LLVM_DEFINITIONS}")
 set(LLVM_CFLAGS "${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}")
 # The language standard potentially affects the ABI/API of LLVM, so we want
@@ -92,6 +93,21 @@ endif()
 add_file_dependencies(${CMAKE_CURRENT_SOURCE_DIR}/llvm-config.cpp ${BUILDVARIABLES_OBJPATH})
 
 if(CMAKE_CROSSCOMPILING)
+  if (((NOT DEFINED LLVM_NATIVE_TOOL_DIR) OR LLVM_NATIVE_TOOL_DIR STREQUAL "") AND (NOT $ENV{LLVM_NATIVE_TOOL_DIR} STREQUAL ""))
+    set(LLVM_NATIVE_TOOL_DIR "$ENV{LLVM_NATIVE_TOOL_DIR}" CACHE INTERNAL "")
+  endif()
+
+  if ((NOT DEFINED LLVM_NATIVE_TOOL_DIR) OR LLVM_NATIVE_TOOL_DIR STREQUAL "")
+    message(WARNING "\${LLVM_NATIVE_TOOL_DIR}    = ${LLVM_NATIVE_TOOL_DIR}")
+    if(NOT $ENV{LLVM_NATIVE_TOOL_DIR} STREQUAL "")
+      message(WARNING "\$ENV{LLVM_NATIVE_TOOL_DIR} = $ENV{LLVM_NATIVE_TOOL_DIR}")
+      set(LLVM_NATIVE_TOOL_DIR "$ENV{LLVM_NATIVE_TOOL_DIR}" CACHE INTERNAL "")
+    endif()
+  endif()
+  message(WARNING "\$ENV{LLVM_NATIVE_TOOL_DIR} = $ENV{LLVM_NATIVE_TOOL_DIR}")
+  message(WARNING "\${LLVM_NATIVE_TOOL_DIR}    = ${LLVM_NATIVE_TOOL_DIR}")
+  message(WARNING "\${LLVM_CONFIG_PATH}        = ${LLVM_CONFIG_PATH}")
+
   if (LLVM_NATIVE_TOOL_DIR AND NOT LLVM_CONFIG_PATH)
     if (EXISTS "${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}")
       set(LLVM_CONFIG_PATH "${LLVM_NATIVE_TOOL_DIR}/llvm-config${LLVM_HOST_EXECUTABLE_SUFFIX}")
@@ -99,10 +115,14 @@ if(CMAKE_CROSSCOMPILING)
   endif()
 
   if (NOT LLVM_CONFIG_PATH)
-    build_native_tool(llvm-config LLVM_CONFIG_PATH)
-    set(LLVM_CONFIG_PATH "${LLVM_CONFIG_PATH}" CACHE STRING "")
+    build_native_tool(llvm-config LLVM_CONFIG_NATIVE_PATH)
+    set(LLVM_CONFIG_PATH "${LLVM_CONFIG_NATIVE_PATH}" CACHE STRING "")
+    message(WARNING "NATIVE \${LLVM_CONFIG_PATH} = ${LLVM_CONFIG_PATH}")
 
-    add_custom_target(NativeLLVMConfig DEPENDS ${LLVM_CONFIG_PATH})
-    add_dependencies(llvm-config NativeLLVMConfig)
+    # add_custom_target(NativeLLVMConfig DEPENDS ${LLVM_CONFIG_NATIVE_PATH})
+    # add_dependencies(llvm-config NativeLLVMConfig)
   endif()
 endif()
+foreach(path ${CMAKE_REQUIRED_INCLUDES})
+  message(WARNING "CMAKE_REQUIRED_INCLUDES : ${path}")
+endforeach()


diff --git a/llvm/tools/llvm-config/llvm-config.cpp b/llvm/tools/llvm-config/llvm-config.cpp
index e86eb2b44b10..47f2b09d891a 100644
--- a/llvm/tools/llvm-config/llvm-config.cpp
+++ b/llvm/tools/llvm-config/llvm-config.cpp
@@ -305,18 +305,33 @@ int main(int argc, char **argv) {
   sys::fs::make_absolute(CurrentPath);
   CurrentExecPrefix =
       sys::path::parent_path(sys::path::parent_path(CurrentPath)).str();
+  std::string LLVM_OBJ_ROOT_IMPL(LLVM_OBJ_ROOT);
+  //Get the current path form the env variable $PATH
+  const char* llvm_obj_root_env = getenv("LLVM_OBJ_ROOT");
+  //If variable exists print to stdout
+  if (llvm_obj_root_env != NULL){
+#if !defined(NDEBUG)
+    outs() << "LLVM_OBJ_ROOT" << " = " << llvm_obj_root_env << std::endl;
+#endif
+    LLVM_OBJ_ROOT_IMPL = llvm_obj_root_env;
+  }
+  else{
+#if !defined(NDEBUG)
+    outs() << "LLVM_OBJ_ROOT" << " not found!" << std::endl;
+#endif
+  }
 
   // Check to see if we are inside a development tree by comparing to possible
   // locations (prefix style or CMake style).
-  if (sys::fs::equivalent(CurrentExecPrefix, LLVM_OBJ_ROOT)) {
+  if (sys::fs::equivalent(CurrentExecPrefix, LLVM_OBJ_ROOT_IMPL)) {
     IsInDevelopmentTree = true;
     DevelopmentTreeLayout = CMakeStyle;
-    ActiveObjRoot = LLVM_OBJ_ROOT;
+    ActiveObjRoot = LLVM_OBJ_ROOT_IMPL;
   } else if (sys::fs::equivalent(sys::path::parent_path(CurrentExecPrefix),
-                                 LLVM_OBJ_ROOT)) {
+                                 LLVM_OBJ_ROOT_IMPL)) {
     IsInDevelopmentTree = true;
     DevelopmentTreeLayout = CMakeBuildModeStyle;
-    ActiveObjRoot = LLVM_OBJ_ROOT;
+    ActiveObjRoot = LLVM_OBJ_ROOT_IMPL;
   } else {
     IsInDevelopmentTree = false;
     DevelopmentTreeLayout = CMakeStyle; // Initialized to avoid warnings.


# diff --git a/llvm/include/llvm/Target/TargetSelectionDAG.td b/llvm/include/llvm/Target/TargetSelectionDAG.td
# index c9024c8fa826..1b59d6ae819d 100644
# --- a/llvm/include/llvm/Target/TargetSelectionDAG.td
# +++ b/llvm/include/llvm/Target/TargetSelectionDAG.td
# @@ -919,7 +919,7 @@ class OutPatFrag<dag ops, dag frag>
#  
#  // PatLeaf's are pattern fragments that have no operands.  This is just a helper
#  // to define immediates and other common things concisely.
# -class PatLeaf<dag frag, code pred = [{}], SDNodeXForm xform = NOOP_SDNodeXForm>
# +class PatLeaf<dag ops, dag frag, code pred = [{}], SDNodeXForm xform = NOOP_SDNodeXForm>
#   : PatFrag<(ops), frag, pred, xform>;
#  
#  
# @@ -936,7 +936,7 @@ class PatLeaf<dag frag, code pred = [{}], SDNodeXForm xform = NOOP_SDNodeXForm>
#  // If FastIsel should ignore all instructions that have an operand of this type,
#  // the FastIselShouldIgnore flag can be set.  This is an optimization to reduce
#  // the code size of the generated fast instruction selector.
# -class ImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
# +class ImmLeaf<dag ops, ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
#                SDNode ImmNode = imm>
#    : PatFrag<(ops), (vt ImmNode), [{}], xform> {
#    let ImmediateCode = pred;
# @@ -951,8 +951,8 @@ class ImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
#  
#  // Convenience wrapper for ImmLeaf to use timm/TargetConstant instead
#  // of imm/Constant.
# -class TImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
# -  SDNode ImmNode = timm> : ImmLeaf<vt, pred, xform, ImmNode>;
# +class TImmLeaf<dag ops, ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
# +  SDNode ImmNode = timm> : ImmLeaf<ops, vt, pred, xform, ImmNode>;
#  
#  // An ImmLeaf except that Imm is an APInt. This is useful when you need to
#  // zero-extend the immediate instead of sign-extend it.
# @@ -961,8 +961,8 @@ class TImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm,
#  // generate code for rules that make use of it. As such, it does not make sense
#  // to replace ImmLeaf with IntImmLeaf. However, replacing PatLeaf with an
#  // IntImmLeaf will allow GlobalISel to import the rule.
# -class IntImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm>
# -    : ImmLeaf<vt, pred, xform> {
# +class IntImmLeaf<dag ops, ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm>
# +    : ImmLeaf<ops, vt, pred, xform> {
#    let IsAPInt = true;
#    let FastIselShouldIgnore = true;
#  }
# @@ -971,16 +971,16 @@ class IntImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm>
#  //
#  // Note that FastISel does not currently understand FPImmLeaf and will not
#  // generate code for rules that make use of it.
# -class FPImmLeaf<ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm>
# -  : ImmLeaf<vt, pred, xform, fpimm> {
# +class FPImmLeaf<dag ops, ValueType vt, code pred, SDNodeXForm xform = NOOP_SDNodeXForm>
# +  : ImmLeaf<ops, vt, pred, xform, fpimm> {
#    let IsAPFloat = true;
#    let FastIselShouldIgnore = true;
#  }
#  
#  // Leaf fragments.
#  
# -def vtInt      : PatLeaf<(vt),  [{ return N->getVT().isInteger(); }]>;
# -def vtFP       : PatLeaf<(vt),  [{ return N->getVT().isFloatingPoint(); }]>;
# +def vtInt      : PatLeaf<(ops), (vt),  [{ return N->getVT().isInteger(); }]>;
# +def vtFP       : PatLeaf<(ops), (vt),  [{ return N->getVT().isFloatingPoint(); }]>;
#  
#  // Use ISD::isConstantSplatVectorAllOnes or ISD::isConstantSplatVectorAllZeros
#  // to look for the corresponding build_vector or splat_vector. Will look through

# https://chromium-review.googlesource.com/c/chromiumos/overlays/chromiumos-overlay/+/4888522/3/dev-util/lldb-server/files/671af65d003bb0e26d29ee63469f8ea7e65ecfee.patch
# diff --git a/llvm/cmake/modules/TableGen.cmake b/llvm/cmake/modules/TableGen.cmake
# index 7fd6628ef55d..ca428428d2bf 100644
# --- a/llvm/cmake/modules/TableGen.cmake
# +++ b/llvm/cmake/modules/TableGen.cmake
# @@ -155,11 +155,11 @@ macro(add_tablegen target project)
#    endif()
#  
#    # FIXME: Quick fix to reflect LLVM_TABLEGEN to llvm-min-tblgen
# -  if("${target}" STREQUAL "llvm-min-tblgen"
# -      AND NOT "${LLVM_TABLEGEN}" STREQUAL ""
# -      AND NOT "${LLVM_TABLEGEN}" STREQUAL "llvm-tblgen")
# -    set(${project}_TABLEGEN_DEFAULT "${LLVM_TABLEGEN}")
# -  endif()
# +  # if("${target}" STREQUAL "llvm-min-tblgen"
# +  #     AND NOT "${LLVM_TABLEGEN}" STREQUAL ""
# +  #     AND NOT "${LLVM_TABLEGEN}" STREQUAL "llvm-tblgen")
# +  #   set(${project}_TABLEGEN_DEFAULT "${LLVM_TABLEGEN}")
# +  # endif()
#  
#    if(ADD_TABLEGEN_EXPORT)
#      set(${project}_TABLEGEN "${${project}_TABLEGEN_DEFAULT}" CACHE


# diff --git a/mlir/CMakeLists.txt b/mlir/CMakeLists.txt
# index c91e9cd93dc8..269f7342cee8 100644
# --- a/mlir/CMakeLists.txt
# +++ b/mlir/CMakeLists.txt
# @@ -15,7 +15,33 @@ endif()
#  
#  # Must go below project(..)
#  include(GNUInstallDirs)
# -set(CMAKE_CXX_STANDARD 17)
# +set(CMAKE_CXX_STANDARD 23)
# +
# +set(CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
# +set(CMAKE_CXX_FLAGS " \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
# +message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_C_COMPILER}    = ${CMAKE_C_COMPILER}")
# +message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_CXX_COMPILER}  = ${CMAKE_CXX_COMPILER}")
# +message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_C_FLAGS}       = ${CMAKE_C_FLAGS}")
# +message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_CXX_FLAGS}     = ${CMAKE_CXX_FLAGS}")
# +
# +set(SAFE_CMAKE_REQUIRED_DEFINITIONS "${CMAKE_REQUIRED_DEFINITIONS}")
# +list(APPEND CMAKE_REQUIRED_FLAGS ${CMAKE_C_FLAGS} ${CMAKE_CXX_FLAGS})
# +list(APPEND CMAKE_REQUIRED_INCLUDES
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/clang/${CLANG_VERSION}/include
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
# +$ENV{MAKE_DIR}/libcxx/include
# +$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include
# +)
#  
#  if(MLIR_STANDALONE_BUILD)
#    find_package(LLVM CONFIG REQUIRED)


diff --git a/mlir/CMakeLists.txt b/mlir/CMakeLists.txt
index c91e9cd93dc8..a8402a292a01 100644
--- a/mlir/CMakeLists.txt
+++ b/mlir/CMakeLists.txt
@@ -15,7 +15,23 @@ endif()
 
 # Must go below project(..)
 include(GNUInstallDirs)
-set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD 23)
+
+set(CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set(CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
+message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_C_COMPILER}    = ${CMAKE_C_COMPILER}")
+message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_CXX_COMPILER}  = ${CMAKE_CXX_COMPILER}")
+message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_C_FLAGS}       = ${CMAKE_C_FLAGS}")
+message(WARNING "mlir/lib/ExecutionEngine/CMakeLists.txt \${CMAKE_CXX_FLAGS}     = ${CMAKE_CXX_FLAGS}")
 
 if(MLIR_STANDALONE_BUILD)
   find_package(LLVM CONFIG REQUIRED)


diff --git a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
index d1833759917a..67f818edb5b6 100644
--- a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
+++ b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
@@ -333,18 +333,6 @@ bool DirectoryBasedGlobalCompilationDatabase::DirectoryCache::load(
   return true;
 }
 
-DirectoryBasedGlobalCompilationDatabase::
-    DirectoryBasedGlobalCompilationDatabase(const Options &Opts)
-    : Opts(Opts), Broadcaster(std::make_unique<BroadcastThread>(*this)) {
-  if (!this->Opts.ContextProvider)
-    this->Opts.ContextProvider = [](llvm::StringRef) {
-      return Context::current().clone();
-    };
-}
-
-DirectoryBasedGlobalCompilationDatabase::
-    ~DirectoryBasedGlobalCompilationDatabase() = default;
-
 std::optional<tooling::CompileCommand>
 DirectoryBasedGlobalCompilationDatabase::getCompileCommand(PathRef File) const {
   CDBLookupRequest Req;
@@ -817,5 +805,17 @@ bool DelegatingCDB::blockUntilIdle(Deadline D) const {
   return Base->blockUntilIdle(D);
 }
 
+DirectoryBasedGlobalCompilationDatabase::
+    DirectoryBasedGlobalCompilationDatabase(const Options &Opts)
+    : Opts(Opts), Broadcaster(std::make_unique<BroadcastThread>(*this)) {
+  if (!this->Opts.ContextProvider)
+    this->Opts.ContextProvider = [](llvm::StringRef) {
+      return Context::current().clone();
+    };
+}
+
+DirectoryBasedGlobalCompilationDatabase::
+    ~DirectoryBasedGlobalCompilationDatabase() = default;
+
 } // namespace clangd
 } // namespace clang


diff --git a/llvm/tools/dsymutil/DebugMap.h b/llvm/tools/dsymutil/DebugMap.h
index 86cb88d32492..f591bdd16276 100644
--- a/llvm/tools/dsymutil/DebugMap.h
+++ b/llvm/tools/dsymutil/DebugMap.h
@@ -46,89 +46,6 @@ class raw_ostream;
 namespace dsymutil {
 
 class DebugMapObject;
-
-/// The DebugMap object stores the list of object files to query for debug
-/// information along with the mapping between the symbols' addresses in the
-/// object file to their linked address in the linked binary.
-///
-/// A DebugMap producer could look like this:
-/// DebugMap *DM = new DebugMap();
-/// for (const auto &Obj: LinkedObjects) {
-///     DebugMapObject &DMO = DM->addDebugMapObject(Obj.getPath());
-///     for (const auto &Sym: Obj.getLinkedSymbols())
-///         DMO.addSymbol(Sym.getName(), Sym.getObjectFileAddress(),
-///                       Sym.getBinaryAddress());
-/// }
-///
-/// A DebugMap consumer can then use the map to link the debug
-/// information. For example something along the lines of:
-/// for (const auto &DMO: DM->objects()) {
-///     auto Obj = createBinary(DMO.getObjectFilename());
-///     for (auto &DIE: Obj.getDwarfDIEs()) {
-///         if (SymbolMapping *Sym = DMO.lookup(DIE.getName()))
-///             DIE.relocate(Sym->ObjectAddress, Sym->BinaryAddress);
-///         else
-///             DIE.discardSubtree();
-///     }
-/// }
-class DebugMap {
-  Triple BinaryTriple;
-  std::string BinaryPath;
-  std::vector<uint8_t> BinaryUUID;
-  using ObjectContainer = std::vector<std::unique_ptr<DebugMapObject>>;
-
-  ObjectContainer Objects;
-
-  /// For YAML IO support.
-  ///@{
-  friend yaml::MappingTraits<std::unique_ptr<DebugMap>>;
-  friend yaml::MappingTraits<DebugMap>;
-
-  DebugMap() = default;
-  ///@}
-
-public:
-  DebugMap(const Triple &BinaryTriple, StringRef BinaryPath,
-           ArrayRef<uint8_t> BinaryUUID = ArrayRef<uint8_t>())
-      : BinaryTriple(BinaryTriple), BinaryPath(std::string(BinaryPath)),
-        BinaryUUID(BinaryUUID.begin(), BinaryUUID.end()) {}
-
-  using const_iterator = ObjectContainer::const_iterator;
-
-  iterator_range<const_iterator> objects() const {
-    return make_range(begin(), end());
-  }
-
-  const_iterator begin() const { return Objects.begin(); }
-
-  const_iterator end() const { return Objects.end(); }
-
-  unsigned getNumberOfObjects() const { return Objects.size(); }
-
-  /// This function adds an DebugMapObject to the list owned by this
-  /// debug map.
-  DebugMapObject &
-  addDebugMapObject(StringRef ObjectFilePath,
-                    sys::TimePoint<std::chrono::seconds> Timestamp,
-                    uint8_t Type = llvm::MachO::N_OSO);
-
-  const Triple &getTriple() const { return BinaryTriple; }
-
-  ArrayRef<uint8_t> getUUID() const { return ArrayRef<uint8_t>(BinaryUUID); }
-
-  StringRef getBinaryPath() const { return BinaryPath; }
-
-  void print(raw_ostream &OS) const;
-
-#ifndef NDEBUG
-  void dump() const;
-#endif
-
-  /// Read a debug map for \a InputFile.
-  static ErrorOr<std::vector<std::unique_ptr<DebugMap>>>
-  parseYAMLDebugMap(StringRef InputFile, StringRef PrependPath, bool Verbose);
-};
-
 /// The DebugMapObject represents one object file described by the DebugMap. It
 /// contains a list of mappings between addresses in the object file and in the
 /// linked binary for all the linked atoms in this object file.
@@ -215,6 +132,89 @@ public:
   ///@}
 };
 
+/// The DebugMap object stores the list of object files to query for debug
+/// information along with the mapping between the symbols' addresses in the
+/// object file to their linked address in the linked binary.
+///
+/// A DebugMap producer could look like this:
+/// DebugMap *DM = new DebugMap();
+/// for (const auto &Obj: LinkedObjects) {
+///     DebugMapObject &DMO = DM->addDebugMapObject(Obj.getPath());
+///     for (const auto &Sym: Obj.getLinkedSymbols())
+///         DMO.addSymbol(Sym.getName(), Sym.getObjectFileAddress(),
+///                       Sym.getBinaryAddress());
+/// }
+///
+/// A DebugMap consumer can then use the map to link the debug
+/// information. For example something along the lines of:
+/// for (const auto &DMO: DM->objects()) {
+///     auto Obj = createBinary(DMO.getObjectFilename());
+///     for (auto &DIE: Obj.getDwarfDIEs()) {
+///         if (SymbolMapping *Sym = DMO.lookup(DIE.getName()))
+///             DIE.relocate(Sym->ObjectAddress, Sym->BinaryAddress);
+///         else
+///             DIE.discardSubtree();
+///     }
+/// }
+class DebugMap {
+  Triple BinaryTriple;
+  std::string BinaryPath;
+  std::vector<uint8_t> BinaryUUID;
+  using ObjectContainer = std::vector<std::unique_ptr<DebugMapObject>>;
+
+  ObjectContainer Objects;
+
+  /// For YAML IO support.
+  ///@{
+  friend yaml::MappingTraits<std::unique_ptr<DebugMap>>;
+  friend yaml::MappingTraits<DebugMap>;
+
+  DebugMap() = default;
+  ///@}
+
+public:
+  DebugMap(const Triple &BinaryTriple, StringRef BinaryPath,
+           ArrayRef<uint8_t> BinaryUUID = ArrayRef<uint8_t>())
+      : BinaryTriple(BinaryTriple), BinaryPath(std::string(BinaryPath)),
+        BinaryUUID(BinaryUUID.begin(), BinaryUUID.end()) {}
+
+  using const_iterator = ObjectContainer::const_iterator;
+
+  iterator_range<const_iterator> objects() const {
+    return make_range(begin(), end());
+  }
+
+  const_iterator begin() const { return Objects.begin(); }
+
+  const_iterator end() const { return Objects.end(); }
+
+  unsigned getNumberOfObjects() const { return Objects.size(); }
+
+  /// This function adds an DebugMapObject to the list owned by this
+  /// debug map.
+  DebugMapObject &
+  addDebugMapObject(StringRef ObjectFilePath,
+                    sys::TimePoint<std::chrono::seconds> Timestamp,
+                    uint8_t Type = llvm::MachO::N_OSO);
+
+  const Triple &getTriple() const { return BinaryTriple; }
+
+  ArrayRef<uint8_t> getUUID() const { return ArrayRef<uint8_t>(BinaryUUID); }
+
+  StringRef getBinaryPath() const { return BinaryPath; }
+
+  void print(raw_ostream &OS) const;
+
+#ifndef NDEBUG
+  void dump() const;
+#endif
+
+  /// Read a debug map for \a InputFile.
+  static ErrorOr<std::vector<std::unique_ptr<DebugMap>>>
+  parseYAMLDebugMap(StringRef InputFile, StringRef PrependPath, bool Verbose);
+};
+
+
 } // end namespace dsymutil
 } // end namespace llvm
 


diff --git a/llvm/include/llvm/DebugInfo/PDB/ConcreteSymbolEnumerator.h b/llvm/include/llvm/DebugInfo/PDB/ConcreteSymbolEnumerator.h
index 49ba20af7263..0b2814067dfc 100644
--- a/llvm/include/llvm/DebugInfo/PDB/ConcreteSymbolEnumerator.h
+++ b/llvm/include/llvm/DebugInfo/PDB/ConcreteSymbolEnumerator.h
@@ -11,6 +11,7 @@
 
 #include "llvm/DebugInfo/PDB/IPDBEnumChildren.h"
 #include "llvm/DebugInfo/PDB/PDBTypes.h"
+#include "llvm/DebugInfo/PDB/PDBSymbol.h"
 #include "llvm/Support/Casting.h"
 #include <algorithm>
 #include <cstdint>



diff --git a/clang/tools/libclang/CIndexDiagnostic.cpp b/clang/tools/libclang/CIndexDiagnostic.cpp
index 34792d5bdfaa..72ba50ee8512 100644
--- a/clang/tools/libclang/CIndexDiagnostic.cpp
+++ b/clang/tools/libclang/CIndexDiagnostic.cpp
@@ -36,6 +36,9 @@ CXDiagnosticSetImpl::appendDiagnostic(std::unique_ptr<CXDiagnosticImpl> D) {
 
 CXDiagnosticImpl::~CXDiagnosticImpl() {}
 
+CXDiagnosticSetImpl::CXDiagnosticSetImpl(bool isManaged)
+: IsExternallyManaged(isManaged) {}
+
 namespace {
 class CXDiagnosticCustomNoteImpl : public CXDiagnosticImpl {
   std::string Message;
diff --git a/clang/tools/libclang/CIndexDiagnostic.h b/clang/tools/libclang/CIndexDiagnostic.h
index 25589bb57474..547da4662afe 100644
--- a/clang/tools/libclang/CIndexDiagnostic.h
+++ b/clang/tools/libclang/CIndexDiagnostic.h
@@ -23,13 +23,13 @@ namespace clang {
 class LangOptions;
 class StoredDiagnostic;
 class CXDiagnosticImpl;
+class CXDiagnosticSetImpl;
   
 class CXDiagnosticSetImpl {
   std::vector<std::unique_ptr<CXDiagnosticImpl>> Diagnostics;
   const bool IsExternallyManaged;
 public:
-  CXDiagnosticSetImpl(bool isManaged = false)
-    : IsExternallyManaged(isManaged) {}
+  CXDiagnosticSetImpl(bool isManaged = false);
 
   virtual ~CXDiagnosticSetImpl();
 


diff --git a/llvm/tools/llvm-cov/SourceCoverageView.cpp b/llvm/tools/llvm-cov/SourceCoverageView.cpp
index ea86acadf001..2361a5278bc1 100644
--- a/llvm/tools/llvm-cov/SourceCoverageView.cpp
+++ b/llvm/tools/llvm-cov/SourceCoverageView.cpp
@@ -279,3 +279,27 @@ void SourceCoverageView::print(raw_ostream &OS, bool WholeFile,
 
   renderViewFooter(OS);
 }
+
+ExpansionView::ExpansionView(const CounterMappingRegion &Region,
+            std::unique_ptr<SourceCoverageView> View)
+  : Region(Region), View(std::move(View)) {}
+
+ExpansionView::ExpansionView(ExpansionView &&RHS)
+  : Region(std::move(RHS.Region)), View(std::move(RHS.View)) {}
+
+ExpansionView &ExpansionView::operator=(ExpansionView &&RHS) {
+  Region = std::move(RHS.Region);
+  View = std::move(RHS.View);
+  return *this;
+}
+
+InstantiationView::InstantiationView(StringRef FunctionName, unsigned Line,
+                std::unique_ptr<SourceCoverageView> View)
+  : FunctionName(FunctionName), Line(Line), View(std::move(View)) {}
+
+BranchView::BranchView(unsigned Line, ArrayRef<CountedRegion> Regions,
+         std::unique_ptr<SourceCoverageView> View)
+  : Regions(Regions), View(std::move(View)), Line(Line) {}
+
+
+
diff --git a/llvm/tools/llvm-cov/SourceCoverageView.h b/llvm/tools/llvm-cov/SourceCoverageView.h
index 5a9fcdd15761..aec65942ae00 100644
--- a/llvm/tools/llvm-cov/SourceCoverageView.h
+++ b/llvm/tools/llvm-cov/SourceCoverageView.h
@@ -32,16 +32,9 @@ struct ExpansionView {
   std::unique_ptr<SourceCoverageView> View;
 
   ExpansionView(const CounterMappingRegion &Region,
-                std::unique_ptr<SourceCoverageView> View)
-      : Region(Region), View(std::move(View)) {}
-  ExpansionView(ExpansionView &&RHS)
-      : Region(std::move(RHS.Region)), View(std::move(RHS.View)) {}
-  ExpansionView &operator=(ExpansionView &&RHS) {
-    Region = std::move(RHS.Region);
-    View = std::move(RHS.View);
-    return *this;
-  }
-
+                std::unique_ptr<SourceCoverageView> View);
+  ExpansionView(ExpansionView &&RHS);
+  ExpansionView &operator=(ExpansionView &&RHS);
   unsigned getLine() const { return Region.LineStart; }
   unsigned getStartCol() const { return Region.ColumnStart; }
   unsigned getEndCol() const { return Region.ColumnEnd; }
@@ -58,8 +51,7 @@ struct InstantiationView {
   std::unique_ptr<SourceCoverageView> View;
 
   InstantiationView(StringRef FunctionName, unsigned Line,
-                    std::unique_ptr<SourceCoverageView> View)
-      : FunctionName(FunctionName), Line(Line), View(std::move(View)) {}
+                    std::unique_ptr<SourceCoverageView> View);
 
   friend bool operator<(const InstantiationView &LHS,
                         const InstantiationView &RHS) {
@@ -74,8 +66,7 @@ struct BranchView {
   unsigned Line;
 
   BranchView(unsigned Line, ArrayRef<CountedRegion> Regions,
-             std::unique_ptr<SourceCoverageView> View)
-      : Regions(Regions), View(std::move(View)), Line(Line) {}
+             std::unique_ptr<SourceCoverageView> View);
 
   unsigned getLine() const { return Line; }
 


diff --git a/compiler-rt/lib/orc/CMakeLists.txt b/compiler-rt/lib/orc/CMakeLists.txt
index 38dd233f5e33..5fa4b6b48732 100644
--- a/compiler-rt/lib/orc/CMakeLists.txt
+++ b/compiler-rt/lib/orc/CMakeLists.txt
@@ -65,6 +65,11 @@ include_directories(../../include)
 set(ORC_CFLAGS
   ${COMPILER_RT_COMMON_CFLAGS}
   ${COMPILER_RT_CXX_CFLAGS})
+set(CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/tirpc \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include \
+")
 set(ORC_LINK_FLAGS ${COMPILER_RT_COMMON_LINK_FLAGS})
 set(ORC_LINK_LIBS
   ${COMPILER_RT_UNWINDER_LINK_LIBS}


diff --git a/compiler-rt/lib/fuzzer/CMakeLists.txt b/compiler-rt/lib/fuzzer/CMakeLists.txt
index a9a10f724d1a..83d065e58fdc 100644
--- a/compiler-rt/lib/fuzzer/CMakeLists.txt
+++ b/compiler-rt/lib/fuzzer/CMakeLists.txt
@@ -57,9 +57,10 @@ CHECK_CXX_SOURCE_COMPILES("
   }
   " HAS_THREAD_LOCAL)
 
+set(CMAKE_CXX_FLAGS "")
 set(LIBFUZZER_CFLAGS ${COMPILER_RT_COMMON_CFLAGS})
 
-if(OS_NAME MATCHES "Linux|Fuchsia" AND
+if(CMAKE_SYSTEM_NAME MATCHES "Linux|Fuchsia" AND
    COMPILER_RT_LIBCXX_PATH AND
    COMPILER_RT_LIBCXXABI_PATH)
   list(APPEND LIBFUZZER_CFLAGS -D_LIBCPP_ABI_VERSION=Fuzzer)
@@ -135,7 +136,7 @@ add_compiler_rt_runtime(clang_rt.fuzzer_interceptors
   CFLAGS ${LIBFUZZER_CFLAGS}
   PARENT_TARGET fuzzer)
 
-if(OS_NAME MATCHES "Linux|Fuchsia" AND
+if(CMAKE_SYSTEM_NAME MATCHES "Linux|Fuchsia" AND
    COMPILER_RT_LIBCXX_PATH AND
    COMPILER_RT_LIBCXXABI_PATH)
   macro(partially_link_libcxx name dir arch)


# diff --git a/compiler-rt/lib/CMakeLists.txt b/compiler-rt/lib/CMakeLists.txt
# index 1437e37b8..6cf957e48 100644
# --- a/compiler-rt/lib/CMakeLists.txt
# +++ b/compiler-rt/lib/CMakeLists.txt
# @@ -17,9 +17,9 @@ if(COMPILER_RT_BUILD_BUILTINS)
#    add_subdirectory(builtins)
#  endif()
# 
# -if(COMPILER_RT_BUILD_CRT)
# +#if(COMPILER_RT_BUILD_CRT)
#    add_subdirectory(crt)
# -endif()
# +#endif()
# 
#  function(compiler_rt_build_runtime runtime)
#    string(TOUPPER ${runtime} runtime_uppercase)


diff --git a/compiler-rt/lib/CMakeLists.txt b/compiler-rt/lib/CMakeLists.txt
index 43ba9a102c84..bfd44ac605e6 100644
--- a/compiler-rt/lib/CMakeLists.txt
+++ b/compiler-rt/lib/CMakeLists.txt
@@ -4,6 +4,9 @@
 include(AddCompilerRT)
 include(SanitizerUtils)
 
+message(WARNING "\${COMPILER_RT_HAS_SANITIZER_COMMON} = ${COMPILER_RT_HAS_SANITIZER_COMMON}")
+message(WARNING "\${COMPILER_RT_BUILD_SANITIZERS} = ${COMPILER_RT_BUILD_SANITIZERS}")
+
 # Hoist the building of sanitizer_common on whether we're building either the
 # sanitizers or xray (or both).
 #
@@ -11,6 +14,8 @@ include(SanitizerUtils)
 if (COMPILER_RT_HAS_SANITIZER_COMMON AND
     (COMPILER_RT_BUILD_SANITIZERS OR COMPILER_RT_BUILD_XRAY OR COMPILER_RT_BUILD_MEMPROF))
   add_subdirectory(sanitizer_common)
+else()
+  message(WARNING "add_subdirectory(sanitizer_common) won't perform")
 endif()
 
 if(COMPILER_RT_BUILD_BUILTINS)
@@ -42,6 +47,14 @@ if(COMPILER_RT_BUILD_SANITIZERS)
     add_subdirectory(ubsan)
   endif()
 
+  if(COMPILER_RT_SANITIZERS_TO_BUILD STREQUAL "all")
+    include(config-ix)
+    message(WARNING "\${ALL_SANITIZERS} = ${ALL_SANITIZERS}")
+    message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
+  else()
+    message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
+  endif()
+
   foreach(sanitizer ${COMPILER_RT_SANITIZERS_TO_BUILD})
     compiler_rt_build_runtime(${sanitizer})
   endforeach()


# diff --git a/compiler-rt/lib/CMakeLists.txt b/compiler-rt/lib/CMakeLists.txt
# index 43ba9a102c84..23031edcb477 100644
# --- a/compiler-rt/lib/CMakeLists.txt
# +++ b/compiler-rt/lib/CMakeLists.txt
# @@ -4,6 +4,19 @@
#  include(AddCompilerRT)
#  include(SanitizerUtils)
#  
# +set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
# +set (CMAKE_CXX_FLAGS " \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
# +message(WARNING "\${COMPILER_RT_HAS_SANITIZER_COMMON} = ${COMPILER_RT_HAS_SANITIZER_COMMON}")
# +message(WARNING "\${COMPILER_RT_BUILD_SANITIZERS} = ${COMPILER_RT_BUILD_SANITIZERS}")
#  # Hoist the building of sanitizer_common on whether we're building either the
#  # sanitizers or xray (or both).
#  #
# @@ -11,6 +24,8 @@ include(SanitizerUtils)
#  if (COMPILER_RT_HAS_SANITIZER_COMMON AND
#      (COMPILER_RT_BUILD_SANITIZERS OR COMPILER_RT_BUILD_XRAY OR COMPILER_RT_BUILD_MEMPROF))
#    add_subdirectory(sanitizer_common)
# +else()
# +  message(WARNING "add_subdirectory(sanitizer_common) won't perform")
#  endif()
#  
#  if(COMPILER_RT_BUILD_BUILTINS)
# @@ -42,6 +57,14 @@ if(COMPILER_RT_BUILD_SANITIZERS)
#      add_subdirectory(ubsan)
#    endif()
#  
# +  if(COMPILER_RT_SANITIZERS_TO_BUILD STREQUAL "all")
# +    include(config-ix)
# +    message(WARNING "\${ALL_SANITIZERS} = ${ALL_SANITIZERS}")
# +    message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
# +  else()
# +    message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
# +  endif()
# +
#    foreach(sanitizer ${COMPILER_RT_SANITIZERS_TO_BUILD})
#      compiler_rt_build_runtime(${sanitizer})
#    endforeach()


diff --git a/compiler-rt/lib/tsan/CMakeLists.txt b/compiler-rt/lib/tsan/CMakeLists.txt
index c5ec6b0ddfd2..10a46abaf056 100644
--- a/compiler-rt/lib/tsan/CMakeLists.txt
+++ b/compiler-rt/lib/tsan/CMakeLists.txt
@@ -1,5 +1,16 @@
 # Build for the ThreadSanitizer runtime support library.
 
+set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set (CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
 set(TSAN_CFLAGS ${SANITIZER_COMMON_CFLAGS})
 # SANITIZER_COMMON_CFLAGS contains -fPIC, but it's performance-critical for
 # TSan runtime to be built with -fPIE to reduce the number of register spills.


diff --git a/compiler-rt/test/CMakeLists.txt b/compiler-rt/test/CMakeLists.txt
index bc37c85a140a..dc06482e9a78 100644
--- a/compiler-rt/test/CMakeLists.txt
+++ b/compiler-rt/test/CMakeLists.txt
@@ -84,6 +84,14 @@ if(COMPILER_RT_CAN_EXECUTE_TESTS)
       add_subdirectory(metadata)
     endif()
 
+    if(COMPILER_RT_SANITIZERS_TO_BUILD STREQUAL "all")
+      include(config-ix)
+      message(WARNING "\${ALL_SANITIZERS} = ${ALL_SANITIZERS}")
+      message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
+    else()
+      message(WARNING "\${COMPILER_RT_SANITIZERS_TO_BUILD} = ${COMPILER_RT_SANITIZERS_TO_BUILD}")
+    endif()
+
     foreach(sanitizer ${COMPILER_RT_SANITIZERS_TO_BUILD})
       # cfi testing is gated on ubsan
       if(NOT ${sanitizer} STREQUAL cfi)


diff --git a/mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp b/mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp
index ebbe88ee9029..21e128d61cc6 100644
--- a/mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp
+++ b/mlir/lib/Dialect/SparseTensor/Transforms/SparseTensorRewriting.cpp
@@ -1094,7 +1094,7 @@ private:
         });
     rewriter.setInsertionPointAfter(op);
     src = rewriter.create<LoadOp>(loc, foreachOp.getResult(0), true);
-    if (bufferTp != dstTp) {
+    if (bufferTp != dstTp.getRankedTensorType()) {
       rewriter.replaceOpWithNewOp<ConvertOp>(op, dstTp.getRankedTensorType(),
                                              src);
       rewriter.create<DeallocTensorOp>(loc, src);


diff --git a/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp b/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp
index 120c00b14a36..30e4a1e043ee 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp
@@ -1289,7 +1289,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
     .scalarize(0)
     .custom();
 
-  const auto needToSplitMemOp = [=](const LegalityQuery &Query,
+  const auto needToSplitMemOp = [=, this](const LegalityQuery &Query,
                                     bool IsLoad) -> bool {
     const LLT DstTy = Query.Types[0];
 
@@ -1362,7 +1362,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
                                       {S64, ConstantPtr, S64, GlobalAlign32},
                                       {V2S32, ConstantPtr, V2S32, GlobalAlign32}});
     Actions.legalIf(
-      [=](const LegalityQuery &Query) -> bool {
+      [=, this](const LegalityQuery &Query) -> bool {
         return isLoadStoreLegal(ST, Query);
       });
 
@@ -1392,7 +1392,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
     // For odd 16-bit element vectors, prefer to split those into pieces with
     // 16-bit vector parts.
     Actions.bitcastIf(
-      [=](const LegalityQuery &Query) -> bool {
+      [=, this](const LegalityQuery &Query) -> bool {
         return shouldBitcastLoadStoreType(ST, Query.Types[0],
                                           Query.MMODescrs[0].MemoryTy);
       }, bitcastToRegisterType(0));
@@ -1400,7 +1400,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
     if (!IsStore) {
       // Widen suitably aligned loads by loading extra bytes. The standard
       // legalization actions can't properly express widening memory operands.
-      Actions.customIf([=](const LegalityQuery &Query) -> bool {
+      Actions.customIf([=, this](const LegalityQuery &Query) -> bool {
         return shouldWidenLoad(ST, Query, G_LOAD);
       });
     }
@@ -1412,7 +1412,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
               return !Query.Types[0].isVector() &&
                      needToSplitMemOp(Query, Op == G_LOAD);
             },
-            [=](const LegalityQuery &Query) -> std::pair<unsigned, LLT> {
+            [=, this](const LegalityQuery &Query) -> std::pair<unsigned, LLT> {
               const LLT DstTy = Query.Types[0];
               const LLT PtrTy = Query.Types[1];
 
@@ -1437,7 +1437,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
               return Query.Types[0].isVector() &&
                      needToSplitMemOp(Query, Op == G_LOAD);
             },
-            [=](const LegalityQuery &Query) -> std::pair<unsigned, LLT> {
+            [=, this](const LegalityQuery &Query) -> std::pair<unsigned, LLT> {
               const LLT DstTy = Query.Types[0];
               const LLT PtrTy = Query.Types[1];
 
@@ -1511,7 +1511,7 @@ AMDGPULegalizerInfo::AMDGPULegalizerInfo(const GCNSubtarget &ST_,
                                                   {S32, ConstantPtr, S8, 8},
                                                   {S32, ConstantPtr, S16, 2 * 8}})
                        .legalIf(
-                         [=](const LegalityQuery &Query) -> bool {
+                         [=, this](const LegalityQuery &Query) -> bool {
                            return isLoadStoreLegal(ST, Query);
                          });
 


diff --git a/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp b/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp
index 747f9fe2f8ae..67207b803e31 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp
@@ -3556,7 +3556,7 @@ AMDGPUInstructionSelector::selectVOP3Mods0(MachineOperand &Root) const {
   std::tie(Src, Mods) = selectVOP3ModsImpl(Root);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(copyToVGPRIfSrcFolded(Src, Mods, Root, MIB));
       },
       [=](MachineInstrBuilder &MIB) { MIB.addImm(Mods); }, // src0_mods
@@ -3574,7 +3574,7 @@ AMDGPUInstructionSelector::selectVOP3BMods0(MachineOperand &Root) const {
                                            /*AllowAbs=*/false);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(copyToVGPRIfSrcFolded(Src, Mods, Root, MIB));
       },
       [=](MachineInstrBuilder &MIB) { MIB.addImm(Mods); }, // src0_mods
@@ -3599,7 +3599,7 @@ AMDGPUInstructionSelector::selectVOP3Mods(MachineOperand &Root) const {
   std::tie(Src, Mods) = selectVOP3ModsImpl(Root);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(copyToVGPRIfSrcFolded(Src, Mods, Root, MIB));
       },
       [=](MachineInstrBuilder &MIB) { MIB.addImm(Mods); } // src_mods
@@ -3614,7 +3614,7 @@ AMDGPUInstructionSelector::selectVOP3ModsNonCanonicalizing(
   std::tie(Src, Mods) = selectVOP3ModsImpl(Root, /*IsCanonicalizing=*/false);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(copyToVGPRIfSrcFolded(Src, Mods, Root, MIB));
       },
       [=](MachineInstrBuilder &MIB) { MIB.addImm(Mods); } // src_mods
@@ -3629,7 +3629,7 @@ AMDGPUInstructionSelector::selectVOP3BMods(MachineOperand &Root) const {
                                            /*AllowAbs=*/false);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(copyToVGPRIfSrcFolded(Src, Mods, Root, MIB));
       },
       [=](MachineInstrBuilder &MIB) { MIB.addImm(Mods); } // src_mods
@@ -3755,7 +3755,7 @@ AMDGPUInstructionSelector::selectVINTERPMods(MachineOperand &Root) const {
                                            /*OpSel=*/false);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(
             copyToVGPRIfSrcFolded(Src, Mods, Root, MIB, /* ForceVGPR */ true));
       },
@@ -3773,7 +3773,7 @@ AMDGPUInstructionSelector::selectVINTERPModsHi(MachineOperand &Root) const {
                                            /*OpSel=*/true);
 
   return {{
-      [=](MachineInstrBuilder &MIB) {
+      [=, this](MachineInstrBuilder &MIB) {
         MIB.addReg(
             copyToVGPRIfSrcFolded(Src, Mods, Root, MIB, /* ForceVGPR */ true));
       },


diff --git a/llvm/lib/Transforms/Scalar/GVNSink.cpp b/llvm/lib/Transforms/Scalar/GVNSink.cpp
index 26a6978656e6..36ab60750027 100644
--- a/llvm/lib/Transforms/Scalar/GVNSink.cpp
+++ b/llvm/lib/Transforms/Scalar/GVNSink.cpp
@@ -501,7 +501,7 @@ public:
 
     uint32_t e = ExpressionNumbering[exp];
     if (!e) {
-      hash_code H = exp->getHashValue([=](Value *V) { return lookupOrAdd(V); });
+      hash_code H = exp->getHashValue([=, this](Value *V) { return lookupOrAdd(V); });
       auto I = HashNumbering.find(H);
       if (I != HashNumbering.end()) {
         e = I->second;


diff --git a/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp b/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
index cc7fb3ee1109..5698ae42e70e 100644
--- a/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
+++ b/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp
@@ -2269,7 +2269,7 @@ bool CombinerHelper::matchCombineFAbsOfFNeg(MachineInstr &MI,
   if (!mi_match(Src, MRI, m_GFNeg(m_Reg(NegSrc))))
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     Observer.changingInstr(MI);
     MI.getOperand(1).setReg(NegSrc);
     Observer.changedInstr(MI);
@@ -2901,7 +2901,7 @@ bool CombinerHelper::matchOverlappingAnd(
           m_GAnd(m_GAnd(m_Reg(R), m_ICst(C1)), m_ICst(C2))))
     return false;
 
-  MatchInfo = [=](MachineIRBuilder &B) {
+  MatchInfo = [=, this](MachineIRBuilder &B) {
     if (C1 & C2) {
       B.buildAnd(Dst, R, B.buildConstant(Ty, C1 & C2));
       return;
@@ -3638,7 +3638,7 @@ bool CombinerHelper::matchLoadOrCombine(
       !Fast)
     return false;
 
-  MatchInfo = [=](MachineIRBuilder &MIB) {
+  MatchInfo = [=, this](MachineIRBuilder &MIB) {
     MIB.setInstrAndDebugLoc(*LatestLoad);
     Register LoadDst = NeedsBSwap ? MRI.cloneVirtualRegister(Dst) : Dst;
     MIB.buildLoad(LoadDst, Ptr, *NewMMO);
@@ -4094,7 +4094,7 @@ bool CombinerHelper::matchAndOrDisjointMask(
   if (AndMaskBits & OrMaskBits)
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     Observer.changingInstr(MI);
     // Canonicalize the result to have the constant on the RHS.
     if (MI.getOperand(1).getReg() == AndMaskReg)
@@ -4357,7 +4357,7 @@ bool CombinerHelper::matchReassocConstantInnerRHS(GPtrAdd &MI,
   if (!C2)
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     LLT PtrTy = MRI.getType(MI.getOperand(0).getReg());
 
     auto NewBase =
@@ -4383,7 +4383,7 @@ bool CombinerHelper::matchReassocConstantInnerLHS(GPtrAdd &MI,
     return false;
 
   auto *LHSPtrAdd = cast<GPtrAdd>(LHS);
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     // When we change LHSPtrAdd's offset register we might cause it to use a reg
     // before its def. Sink the instruction so the outer PTR_ADD to ensure this
     // doesn't happen.
@@ -4420,7 +4420,7 @@ bool CombinerHelper::matchReassocFoldConstantsInSubTree(GPtrAdd &MI,
   if (!C2)
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     auto NewCst = B.buildConstant(MRI.getType(Src2Reg), *C1 + *C2);
     Observer.changingInstr(MI);
     MI.getOperand(1).setReg(LHSSrc1);
@@ -4607,7 +4607,7 @@ bool CombinerHelper::matchNarrowBinopFeedingAnd(
     return false;
   Register BinOpLHS = LHSInst->getOperand(1).getReg();
   Register BinOpRHS = LHSInst->getOperand(2).getReg();
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     auto NarrowLHS = Builder.buildTrunc(NarrowTy, BinOpLHS);
     auto NarrowRHS = Builder.buildTrunc(NarrowTy, BinOpRHS);
     auto NarrowBinOp =
@@ -4627,7 +4627,7 @@ bool CombinerHelper::matchMulOBy2(MachineInstr &MI, BuildFnTy &MatchInfo) {
   if (!mi_match(MI.getOperand(3).getReg(), MRI, m_SpecificICstOrSplat(2)))
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     Observer.changingInstr(MI);
     unsigned NewOpc = Opc == TargetOpcode::G_UMULO ? TargetOpcode::G_UADDO
                                                    : TargetOpcode::G_SADDO;
@@ -4741,7 +4741,7 @@ bool CombinerHelper::matchSubAddSameReg(MachineInstr &MI,
                         mi_match(Y, MRI, m_SpecificICstOrSplat(CstX))))
       ReplaceReg = Z;
     if (ReplaceReg) {
-      MatchInfo = [=](MachineIRBuilder &B) {
+      MatchInfo = [=, this](MachineIRBuilder &B) {
         auto Zero = B.buildConstant(MRI.getType(Dst), 0);
         B.buildSub(Dst, Zero, ReplaceReg);
       };
@@ -5075,7 +5075,7 @@ bool CombinerHelper::matchRedundantNegOperands(MachineInstr &MI,
   } else
     return false;
 
-  MatchInfo = [=, &MI](MachineIRBuilder &B) {
+  MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
     Observer.changingInstr(MI);
     MI.setDesc(B.getTII().get(Opc));
     MI.getOperand(1).setReg(X);
@@ -5326,7 +5326,7 @@ bool CombinerHelper::matchCombineFAddFMAFMulToFMadOrFMA(
     Register U = FMulMI->getOperand(1).getReg();
     Register V = FMulMI->getOperand(2).getReg();
 
-    MatchInfo = [=, &MI](MachineIRBuilder &B) {
+    MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
       Register InnerFMA = MRI.createGenericVirtualRegister(DstTy);
       B.buildInstr(PreferredFusedOpcode, {InnerFMA}, {U, V, Z});
       B.buildInstr(PreferredFusedOpcode, {MI.getOperand(0).getReg()},
@@ -5647,7 +5647,7 @@ bool CombinerHelper::matchCombineFSubFpExtFNegFMulToFMadOrFMA(
       isContractableFMul(*FMulMI, AllowFusionGlobally) &&
       TLI.isFPExtFoldable(MI, PreferredFusedOpcode, DstTy,
                           MRI.getType(FMulMI->getOperand(0).getReg()))) {
-    MatchInfo = [=, &MI](MachineIRBuilder &B) {
+    MatchInfo = [=, &MI, this](MachineIRBuilder &B) {
       Register FMAReg = MRI.createGenericVirtualRegister(DstTy);
       buildMatchInfo(FMAReg, FMulMI->getOperand(1).getReg(),
                      FMulMI->getOperand(2).getReg(), RHSReg, B);
@@ -6001,7 +6001,7 @@ bool CombinerHelper::matchRedundantBinOpInEquality(MachineInstr &MI,
       return false;
     Y = X == OpLHS ? OpRHS : X == OpRHS ? OpLHS : Register();
   }
-  MatchInfo = [=](MachineIRBuilder &B) {
+  MatchInfo = [=, this](MachineIRBuilder &B) {
     auto Zero = B.buildConstant(MRI.getType(Y), 0);
     B.buildICmp(Pred, Dst, Y, Zero);
   };


diff --git a/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp b/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
index f0da0d88140f..1050544fc369 100644
--- a/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
+++ b/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp
@@ -4092,7 +4092,7 @@ LegalizerHelper::reduceLoadStoreWidth(GLoadStore &LdStMI, unsigned TypeIdx,
   // handled.
   bool isBigEndian = MIRBuilder.getDataLayout().isBigEndian();
   auto MMO = LdStMI.getMMO();
-  auto splitTypePieces = [=](LLT PartTy, SmallVectorImpl<Register> &ValRegs,
+  auto splitTypePieces = [=, this](LLT PartTy, SmallVectorImpl<Register> &ValRegs,
                              unsigned NumParts, unsigned Offset) -> unsigned {
     MachineFunction &MF = MIRBuilder.getMF();
     unsigned PartSize = PartTy.getSizeInBits();


diff --git a/llvm/lib/Target/X86/X86LegalizerInfo.cpp b/llvm/lib/Target/X86/X86LegalizerInfo.cpp
index a4a247f85f3d..a19352d90b51 100644
--- a/llvm/lib/Target/X86/X86LegalizerInfo.cpp
+++ b/llvm/lib/Target/X86/X86LegalizerInfo.cpp
@@ -259,7 +259,7 @@ X86LegalizerInfo::X86LegalizerInfo(const X86Subtarget &STI,
 
   // bswap
   getActionDefinitionsBuilder(G_BSWAP)
-      .legalIf([=](const LegalityQuery &Query) {
+      .legalIf([=, this](const LegalityQuery &Query) {
         return Query.Types[0] == s32 ||
                (Subtarget.is64Bit() && Query.Types[0] == s64);
       })
@@ -268,7 +268,7 @@ X86LegalizerInfo::X86LegalizerInfo(const X86Subtarget &STI,
 
   // popcount
   getActionDefinitionsBuilder(G_CTPOP)
-      .legalIf([=](const LegalityQuery &Query) -> bool {
+      .legalIf([=, this](const LegalityQuery &Query) -> bool {
         return Subtarget.hasPOPCNT() &&
                (typePairInSet(0, 1, {{s16, s16}, {s32, s32}})(Query) ||
                 (Is64Bit && typePairInSet(0, 1, {{s64, s64}})(Query)));
@@ -279,7 +279,7 @@ X86LegalizerInfo::X86LegalizerInfo(const X86Subtarget &STI,
 
   // count leading zeros (LZCNT)
   getActionDefinitionsBuilder(G_CTLZ)
-      .legalIf([=](const LegalityQuery &Query) -> bool {
+      .legalIf([=, this](const LegalityQuery &Query) -> bool {
         return Subtarget.hasLZCNT() &&
                (typePairInSet(0, 1, {{s16, s16}, {s32, s32}})(Query) ||
                 (Is64Bit && typePairInSet(0, 1, {{s64, s64}})(Query)));
@@ -290,7 +290,7 @@ X86LegalizerInfo::X86LegalizerInfo(const X86Subtarget &STI,
 
   // count trailing zeros
   getActionDefinitionsBuilder({G_CTTZ_ZERO_UNDEF, G_CTTZ})
-      .legalIf([=](const LegalityQuery &Query) -> bool {
+      .legalIf([=, this](const LegalityQuery &Query) -> bool {
         return (Query.Opcode == G_CTTZ_ZERO_UNDEF || Subtarget.hasBMI()) &&
                (typePairInSet(0, 1, {{s16, s16}, {s32, s32}})(Query) ||
                 (Is64Bit && typePairInSet(0, 1, {{s64, s64}})(Query)));


diff --git a/clang/lib/Sema/SemaExpr.cpp b/clang/lib/Sema/SemaExpr.cpp
index 2716b6677105..faa6c6cb0d10 100644
--- a/clang/lib/Sema/SemaExpr.cpp
+++ b/clang/lib/Sema/SemaExpr.cpp
@@ -2424,7 +2424,7 @@ bool Sema::DiagnoseEmptyLookup(Scope *S, CXXScopeSpec &SS, LookupResult &R,
            "Diagnosing an empty lookup with explicit template args!");
     *Out = CorrectTypoDelayed(
         R.getLookupNameInfo(), R.getLookupKind(), S, &SS, CCC,
-        [=](const TypoCorrection &TC) {
+        [=, this](const TypoCorrection &TC) {
           emitEmptyLookupTypoDiagnostic(TC, *this, SS, Name, TypoLoc, Args,
                                         diagnostic, diagnostic_suggest);
         },


diff --git a/clang/lib/Sema/SemaChecking.cpp b/clang/lib/Sema/SemaChecking.cpp
index f8e48728da66..3e770dd71d02 100644
--- a/clang/lib/Sema/SemaChecking.cpp
+++ b/clang/lib/Sema/SemaChecking.cpp
@@ -8153,7 +8153,7 @@ bool Sema::SemaBuiltinVAStart(unsigned BuiltinID, CallExpr *TheCall) {
     Diag(TheCall->getArg(1)->getBeginLoc(),
          diag::warn_second_arg_of_va_start_not_last_named_param);
   else if (IsCRegister || Type->isReferenceType() ||
-           Type->isSpecificBuiltinType(BuiltinType::Float) || [=] {
+           Type->isSpecificBuiltinType(BuiltinType::Float) || [=, this] {
              // Promotable integers are UB, but enumerations need a bit of
              // extra checking to see what their promotable type actually is.
              if (!Context.isPromotableIntegerType(Type))


diff --git a/clang/lib/AST/JSONNodeDumper.cpp b/clang/lib/AST/JSONNodeDumper.cpp
index 958b0e6cf2ef..d94525a3f8e8 100644
--- a/clang/lib/AST/JSONNodeDumper.cpp
+++ b/clang/lib/AST/JSONNodeDumper.cpp
@@ -944,7 +944,7 @@ void JSONNodeDumper::VisitTemplateTypeParmDecl(const TemplateTypeParmDecl *D) {
   attributeOnlyIfTrue("isParameterPack", D->isParameterPack());
 
   if (D->hasDefaultArgument())
-    JOS.attributeObject("defaultArg", [=] {
+    JOS.attributeObject("defaultArg", [=, this] {
       Visit(D->getDefaultArgument(), SourceRange(),
             D->getDefaultArgStorage().getInheritedFrom(),
             D->defaultArgumentWasInherited() ? "inherited from" : "previous");
@@ -960,7 +960,7 @@ void JSONNodeDumper::VisitNonTypeTemplateParmDecl(
   attributeOnlyIfTrue("isParameterPack", D->isParameterPack());
 
   if (D->hasDefaultArgument())
-    JOS.attributeObject("defaultArg", [=] {
+    JOS.attributeObject("defaultArg", [=, this] {
       Visit(D->getDefaultArgument(), SourceRange(),
             D->getDefaultArgStorage().getInheritedFrom(),
             D->defaultArgumentWasInherited() ? "inherited from" : "previous");
@@ -975,7 +975,7 @@ void JSONNodeDumper::VisitTemplateTemplateParmDecl(
   attributeOnlyIfTrue("isParameterPack", D->isParameterPack());
 
   if (D->hasDefaultArgument())
-    JOS.attributeObject("defaultArg", [=] {
+    JOS.attributeObject("defaultArg", [=, this] {
       const auto *InheritedFrom = D->getDefaultArgStorage().getInheritedFrom();
       Visit(D->getDefaultArgument().getArgument(),
             InheritedFrom ? InheritedFrom->getSourceRange() : SourceLocation{},


diff --git a/clang/lib/AST/TextNodeDumper.cpp b/clang/lib/AST/TextNodeDumper.cpp
index a174faa6635e..92d12d4ce7cf 100644
--- a/clang/lib/AST/TextNodeDumper.cpp
+++ b/clang/lib/AST/TextNodeDumper.cpp
@@ -264,7 +264,7 @@ void TextNodeDumper::Visit(const Decl *D) {
   if (auto *ND = dyn_cast<NamedDecl>(D))
     for (Module *M : D->getASTContext().getModulesWithMergedDefinition(
              const_cast<NamedDecl *>(ND)))
-      AddChild([=] { OS << "also in " << M->getFullModuleName(); });
+      AddChild([=, this] { OS << "also in " << M->getFullModuleName(); });
   if (const NamedDecl *ND = dyn_cast<NamedDecl>(D))
     if (!ND->isUnconditionallyVisible())
       OS << " hidden";
@@ -467,7 +467,7 @@ void TextNodeDumper::dumpAPValueChildren(
     J = std::max(I + 1, J);
 
     // Print [I,J) on a single line.
-    AddChild(J - I > 1 ? LabelPlurial : LabelSingular, [=]() {
+    AddChild(J - I > 1 ? LabelPlurial : LabelSingular, [=, this]() {
       for (unsigned X = I; X < J; ++X) {
         Visit(IdxToChildFun(Value, X), Ty);
         if (X + 1 != J)
@@ -553,7 +553,7 @@ void TextNodeDumper::Visit(const APValue &Value, QualType Ty) {
         NumInitializedElements, "element", "elements");
 
     if (Value.hasArrayFiller()) {
-      AddChild("filler", [=] {
+      AddChild("filler", [=, this] {
         {
           ColorScope Color(OS, ShowColors, ValueColor);
           OS << ArraySize - NumInitializedElements << " x ";
@@ -597,7 +597,7 @@ void TextNodeDumper::Visit(const APValue &Value, QualType Ty) {
       OS << ' ';
       Visit(UnionValue, Ty);
     } else {
-      AddChild([=] { Visit(UnionValue, Ty); });
+      AddChild([=, this] { Visit(UnionValue, Ty); });
     }
 
     return;
@@ -722,7 +722,7 @@ void TextNodeDumper::dumpCleanupObject(
   if (auto *BD = C.dyn_cast<BlockDecl *>())
     dumpDeclRef(BD, "cleanup");
   else if (auto *CLE = C.dyn_cast<CompoundLiteralExpr *>())
-    AddChild([=] {
+    AddChild([=, this] {
       OS << "cleanup ";
       {
         ColorScope Color(OS, ShowColors, StmtColor);
@@ -738,7 +738,7 @@ void TextNodeDumper::dumpDeclRef(const Decl *D, StringRef Label) {
   if (!D)
     return;
 
-  AddChild([=] {
+  AddChild([=, this] {
     if (!Label.empty())
       OS << Label << ' ';
     dumpBareDeclRef(D);
@@ -998,7 +998,7 @@ void TextNodeDumper::VisitCaseStmt(const CaseStmt *Node) {
 void TextNodeDumper::VisitConstantExpr(const ConstantExpr *Node) {
   if (Node->hasAPValueResult())
     AddChild("value",
-             [=] { Visit(Node->getAPValueResult(), Node->getType()); });
+             [=, this] { Visit(Node->getAPValueResult(), Node->getType()); });
 }
 
 void TextNodeDumper::VisitCallExpr(const CallExpr *Node) {
@@ -1729,13 +1729,13 @@ void TextNodeDumper::VisitFunctionDecl(const FunctionDecl *D) {
 
   if (const auto *MD = dyn_cast<CXXMethodDecl>(D)) {
     if (MD->size_overridden_methods() != 0) {
-      auto dumpOverride = [=](const CXXMethodDecl *D) {
+      auto dumpOverride = [=, this](const CXXMethodDecl *D) {
         SplitQualType T_split = D->getType().split();
         OS << D << " " << D->getParent()->getName() << "::" << D->getDeclName()
            << " '" << QualType::getAsString(T_split, PrintPolicy) << "'";
       };
 
-      AddChild([=] {
+      AddChild([=, this] {
         auto Overrides = MD->overridden_methods();
         OS << "Overrides: [ ";
         dumpOverride(*Overrides.begin());
@@ -1831,7 +1831,7 @@ void TextNodeDumper::VisitVarDecl(const VarDecl *D) {
         !D->getType()->isDependentType()) {
       const APValue *Value = D->evaluateValue();
       if (Value)
-        AddChild("value", [=] { Visit(*Value, E->getType()); });
+        AddChild("value", [=, this] { Visit(*Value, E->getType()); });
     }
   }
 }
@@ -1915,7 +1915,7 @@ void TextNodeDumper::VisitOMPDeclareReductionDecl(
 
 void TextNodeDumper::VisitOMPRequiresDecl(const OMPRequiresDecl *D) {
   for (const auto *C : D->clauselists()) {
-    AddChild([=] {
+    AddChild([=, this] {
       if (!C) {
         ColorScope Color(OS, ShowColors, NullColor);
         OS << "<<<NULL>>> OMPClause";
@@ -1974,7 +1974,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
   if (!D->isCompleteDefinition())
     return;
 
-  AddChild([=] {
+  AddChild([=, this] {
     {
       ColorScope Color(OS, ShowColors, DeclKindNameColor);
       OS << "DefinitionData";
@@ -2005,7 +2005,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
     FLAG(hasVariantMembers, has_variant_members);
     FLAG(allowConstDefaultInit, can_const_default_init);
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "DefaultConstructor";
@@ -2019,7 +2019,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
       FLAG(defaultedDefaultConstructorIsConstexpr, defaulted_is_constexpr);
     });
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "CopyConstructor";
@@ -2037,7 +2037,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
       FLAG(implicitCopyConstructorHasConstParam, implicit_has_const_param);
     });
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "MoveConstructor";
@@ -2054,7 +2054,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
         FLAG(defaultedMoveConstructorIsDeleted, defaulted_is_deleted);
     });
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "CopyAssignment";
@@ -2069,7 +2069,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
       FLAG(implicitCopyAssignmentHasConstParam, implicit_has_const_param);
     });
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "MoveAssignment";
@@ -2083,7 +2083,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
       FLAG(needsOverloadResolutionForMoveAssignment, needs_overload_resolution);
     });
 
-    AddChild([=] {
+    AddChild([=, this] {
       {
         ColorScope Color(OS, ShowColors, DeclKindNameColor);
         OS << "Destructor";
@@ -2102,7 +2102,7 @@ void TextNodeDumper::VisitCXXRecordDecl(const CXXRecordDecl *D) {
   });
 
   for (const auto &I : D->bases()) {
-    AddChild([=] {
+    AddChild([=, this] {
       if (I.isVirtual())
         OS << "virtual ";
       dumpAccessSpecifier(I.getAccessSpecifier());
@@ -2204,19 +2204,19 @@ void TextNodeDumper::VisitConstructorUsingShadowDecl(
   if (D->constructsVirtualBase())
     OS << " virtual";
 
-  AddChild([=] {
+  AddChild([=, this] {
     OS << "target ";
     dumpBareDeclRef(D->getTargetDecl());
   });
 
-  AddChild([=] {
+  AddChild([=, this] {
     OS << "nominated ";
     dumpBareDeclRef(D->getNominatedBaseClass());
     OS << ' ';
     dumpBareDeclRef(D->getNominatedBaseClassShadowDecl());
   });
 
-  AddChild([=] {
+  AddChild([=, this] {
     OS << "constructed ";
     dumpBareDeclRef(D->getConstructedBaseClass());
     OS << ' ';


diff --git a/clang/lib/Format/UnwrappedLineParser.cpp b/clang/lib/Format/UnwrappedLineParser.cpp
index 32619bc56f7a..59613f1f64f2 100644
--- a/clang/lib/Format/UnwrappedLineParser.cpp
+++ b/clang/lib/Format/UnwrappedLineParser.cpp
@@ -808,7 +808,7 @@ FormatToken *UnwrappedLineParser::parseBlock(
   const bool IsFunctionRBrace =
       FormatTok->is(tok::r_brace) && Tok->is(TT_FunctionLBrace);
 
-  auto RemoveBraces = [=]() mutable {
+  auto RemoveBraces = [=, this]() mutable {
     if (!SimpleBlock)
       return false;
     assert(Tok->isOneOf(TT_ControlStatementLBrace, TT_ElseLBrace));


diff --git a/llvm/lib/BinaryFormat/AMDGPUMetadataVerifier.cpp b/llvm/lib/BinaryFormat/AMDGPUMetadataVerifier.cpp
index 35a79ec04b6e..decc0c4d2b4e 100644
--- a/llvm/lib/BinaryFormat/AMDGPUMetadataVerifier.cpp
+++ b/llvm/lib/BinaryFormat/AMDGPUMetadataVerifier.cpp
@@ -78,7 +78,7 @@ bool MetadataVerifier::verifyScalarEntry(
     msgpack::MapDocNode &MapNode, StringRef Key, bool Required,
     msgpack::Type SKind,
     function_ref<bool(msgpack::DocNode &)> verifyValue) {
-  return verifyEntry(MapNode, Key, Required, [=](msgpack::DocNode &Node) {
+  return verifyEntry(MapNode, Key, Required, [=, this](msgpack::DocNode &Node) {
     return verifyScalar(Node, SKind, verifyValue);
   });
 }


diff --git a/llvm/lib/Support/Parallel.cpp b/llvm/lib/Support/Parallel.cpp
index 9b14b05b5211..3991dd5196c3 100644
--- a/llvm/lib/Support/Parallel.cpp
+++ b/llvm/lib/Support/Parallel.cpp
@@ -61,7 +61,7 @@ public:
     auto &Thread0 = Threads[0];
     Thread0 = std::thread([this, S] {
       for (unsigned I = 1; I < ThreadCount; ++I) {
-        Threads.emplace_back([=] { work(S, I); });
+        Threads.emplace_back([=, this] { work(S, I); });
         if (Stop)
           break;
       }


diff --git a/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp b/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp
index 536fb02cb4ec..26a02cf0bf18 100644
--- a/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp
+++ b/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp
@@ -266,7 +266,7 @@ bool AMDGPUPostLegalizerCombinerImpl::matchRcpSqrtToRsq(
     MachineInstr &MI,
     std::function<void(MachineIRBuilder &)> &MatchInfo) const {
 
-  auto getRcpSrc = [=](const MachineInstr &MI) {
+  auto getRcpSrc = [=, this](const MachineInstr &MI) {
     MachineInstr *ResMI = nullptr;
     if (MI.getOpcode() == TargetOpcode::G_INTRINSIC &&
         MI.getIntrinsicID() == Intrinsic::amdgcn_rcp)
@@ -275,7 +275,7 @@ bool AMDGPUPostLegalizerCombinerImpl::matchRcpSqrtToRsq(
     return ResMI;
   };
 
-  auto getSqrtSrc = [=](const MachineInstr &MI) {
+  auto getSqrtSrc = [=, this](const MachineInstr &MI) {
     MachineInstr *SqrtSrcMI = nullptr;
     auto Match =
         mi_match(MI.getOperand(0).getReg(), MRI, m_GFSqrt(m_MInstr(SqrtSrcMI)));


diff --git a/llvm/lib/Target/AMDGPU/GCNMinRegStrategy.cpp b/llvm/lib/Target/AMDGPU/GCNMinRegStrategy.cpp
index 04a6f2a7f4fd..597a2ed17d7d 100644
--- a/llvm/lib/Target/AMDGPU/GCNMinRegStrategy.cpp
+++ b/llvm/lib/Target/AMDGPU/GCNMinRegStrategy.cpp
@@ -142,7 +142,7 @@ GCNMinRegScheduler::Candidate* GCNMinRegScheduler::pickCandidate() {
 
     LLVM_DEBUG(dbgs() << "\nSelecting min non-ready producing candidate among "
                       << Num << '\n');
-    Num = findMax(Num, [=](const Candidate &C) {
+    Num = findMax(Num, [=, this](const Candidate &C) {
       auto SU = C.SU;
       int Res = getNotReadySuccessors(SU);
       LLVM_DEBUG(dbgs() << "SU(" << SU->NodeNum << ") would left non-ready "
@@ -153,7 +153,7 @@ GCNMinRegScheduler::Candidate* GCNMinRegScheduler::pickCandidate() {
 
     LLVM_DEBUG(dbgs() << "\nSelecting most producing candidate among " << Num
                       << '\n');
-    Num = findMax(Num, [=](const Candidate &C) {
+    Num = findMax(Num, [=, this](const Candidate &C) {
       auto SU = C.SU;
       auto Res = getReadySuccessors(SU);
       LLVM_DEBUG(dbgs() << "SU(" << SU->NodeNum << ") would make ready " << Res


diff --git a/llvm/lib/Analysis/CallGraph.cpp b/llvm/lib/Analysis/CallGraph.cpp
index 58ccf2bd664b..a8134b7c0b65 100644
--- a/llvm/lib/Analysis/CallGraph.cpp
+++ b/llvm/lib/Analysis/CallGraph.cpp
@@ -105,7 +105,7 @@ void CallGraph::populateCallGraphNode(CallGraphNode *Node) {
           Node->addCalledFunction(Call, getOrInsertFunction(Callee));
 
         // Add reference to callback functions.
-        forEachCallbackFunction(*Call, [=](Function *CB) {
+        forEachCallbackFunction(*Call, [=, this](Function *CB) {
           Node->addCalledFunction(nullptr, getOrInsertFunction(CB));
         });
       }
@@ -215,7 +215,7 @@ void CallGraphNode::removeCallEdgeFor(CallBase &Call) {
       CalledFunctions.pop_back();
 
       // Remove all references to callback functions if there are any.
-      forEachCallbackFunction(Call, [=](Function *CB) {
+      forEachCallbackFunction(Call, [=, this](Function *CB) {
         removeOneAbstractEdgeTo(CG->getOrInsertFunction(CB));
       });
       return;


diff --git a/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp b/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
index 9bbef11067ae..ec851adb01b6 100644
--- a/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
+++ b/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp
@@ -92,7 +92,7 @@ bool InstructionSelect::runOnMachineFunction(MachineFunction &MF) {
   InstructionSelector *ISel = MF.getSubtarget().getInstructionSelector();
 
   CodeGenOpt::Level OldOptLevel = OptLevel;
-  auto RestoreOptLevel = make_scope_exit([=]() { OptLevel = OldOptLevel; });
+  auto RestoreOptLevel = make_scope_exit([=, this]() { OptLevel = OldOptLevel; });
   OptLevel = MF.getFunction().hasOptNone() ? CodeGenOpt::None
                                            : MF.getTarget().getOptLevel();
 


# diff --git a/compiler-rt/lib/sanitizer_common/CMakeLists.txt b/compiler-rt/lib/sanitizer_common/CMakeLists.txt
# index 59ab17317f93..5bad892657a7 100644
# --- a/compiler-rt/lib/sanitizer_common/CMakeLists.txt
# +++ b/compiler-rt/lib/sanitizer_common/CMakeLists.txt
# @@ -1,6 +1,28 @@
#  # Build system for the common Sanitizer runtime support library components.
#  # These components are shared between AddressSanitizer and ThreadSanitizer.
#  
# +message(WARNING "CMAKE_CXX_FLAGS        = ${CMAKE_CXX_FLAGS}")
# +message(WARNING "COMPILER_RESOURCE_DIR  = ${COMPILER_RESOURCE_DIR}")
# +message(WARNING "CLANG_RESOURCE_DIR     = ${CLANG_RESOURCE_DIR}")
# +message(WARNING "\$ENV{DESTDIR}         = $ENV{DESTDIR}")
# +message(WARNING "\$ENV{CXXFLAGS}        = $ENV{CXXFLAGS}")
# +message(WARNING "\$ENV{CFLAGS}          = $ENV{CFLAGS}")
# +message(WARNING "\$ENV{LDFLAGS}         = $ENV{LDFLAGS}")
# +
# +# Remove -stdlib= which is unused when passing -nostdinc++.
# +string(REGEX REPLACE "-stdlib=[a-zA-Z+]*" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
# +
# +set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
# +set (CMAKE_CXX_FLAGS " \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
# +-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
# +$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
# +")
# +
# +set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
# +set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
# +set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
# +
#  set(SANITIZER_SOURCES_NOTERMINATION
#    sanitizer_allocator.cpp
#    sanitizer_common.cpp


diff --git a/llvm/tools/llvm-readobj/ObjDumper.cpp b/llvm/tools/llvm-readobj/ObjDumper.cpp
index 6dde3725b4d6..18fbe139d611 100644
--- a/llvm/tools/llvm-readobj/ObjDumper.cpp
+++ b/llvm/tools/llvm-readobj/ObjDumper.cpp
@@ -30,7 +30,7 @@ static inline Error createError(const Twine &Msg) {
 ObjDumper::ObjDumper(ScopedPrinter &Writer, StringRef ObjName) : W(Writer) {
   // Dumper reports all non-critical errors as warnings.
   // It does not print the same warning more than once.
-  WarningHandler = [=](const Twine &Msg) {
+  WarningHandler = [=, this](const Twine &Msg) {
     if (Warnings.insert(Msg.str()).second)
       reportWarning(createError(Msg), ObjName);
     return Error::success();


diff --git a/compiler-rt/lib/tsan/rtl/CMakeLists.txt b/compiler-rt/lib/tsan/rtl/CMakeLists.txt
index 4107e04b87d8..014e178f2d19 100644
--- a/compiler-rt/lib/tsan/rtl/CMakeLists.txt
+++ b/compiler-rt/lib/tsan/rtl/CMakeLists.txt
@@ -1,5 +1,16 @@
 include_directories(../..)
 
+set (CMAKE_C_FLAGS " $ENV{RUNTIMES_TARGET_CMAKE_C_FLAGS} ")
+set (CMAKE_CXX_FLAGS " \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/$ENV{LLVM_TARGET_TRIPLE}/c++/v1 \
+-isystem $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/c++/v1 \
+$ENV{RUNTIMES_TARGET_CMAKE_CXX_FLAGS} \
+")
+
+set(CMAKE_EXE_LINKER_FLAGS    "$ENV{LDFLAGS}")
+set(CMAKE_SHARED_LINKER_FLAGS "$ENV{LDFLAGS}")
+set(CMAKE_MODULE_LINKER_FLAGS "$ENV{LDFLAGS}")
+
 set(TSAN_RTL_CFLAGS ${TSAN_CFLAGS})
 append_list_if(COMPILER_RT_HAS_MSSE4_2_FLAG -msse4.2 TSAN_RTL_CFLAGS)
 append_list_if(SANITIZER_LIMIT_FRAME_SIZE -Wframe-larger-than=530


diff --git a/llvm/lib/Demangle/CMakeLists.txt b/llvm/lib/Demangle/CMakeLists.txt
index eb7d212a0244..4c9bee03c8fb 100644
--- a/llvm/lib/Demangle/CMakeLists.txt
+++ b/llvm/lib/Demangle/CMakeLists.txt
@@ -9,4 +9,5 @@ add_llvm_component_library(LLVMDemangle
   ADDITIONAL_HEADER_DIRS
   "${LLVM_MAIN_INCLUDE_DIR}/llvm/Demangle"
 
+  LINK_LIBS "--unwindlib=libunwind"
 )


diff --git a/llvm/lib/TargetParser/CMakeLists.txt b/llvm/lib/TargetParser/CMakeLists.txt
index 3a911aa12f8e..81f7e9aba9cc 100644
--- a/llvm/lib/TargetParser/CMakeLists.txt
+++ b/llvm/lib/TargetParser/CMakeLists.txt
@@ -28,6 +28,8 @@ add_llvm_component_library(LLVMTargetParser
   LINK_COMPONENTS
   Support
 
+  LINK_LIBS "--unwindlib=libunwind"
+
   DEPENDS
   RISCVTargetParserTableGen
   )


diff --git a/lldb/utils/TableGen/CMakeLists.txt b/lldb/utils/TableGen/CMakeLists.txt
index 47a6400b4287..d20942956a0e 100644
--- a/lldb/utils/TableGen/CMakeLists.txt
+++ b/lldb/utils/TableGen/CMakeLists.txt
@@ -7,6 +7,15 @@ if (NOT DEFINED LLDB_TABLEGEN_EXE)
   else()
     set(LLVM_LINK_COMPONENTS Support)
 
+    message(WARNING "\${CMAKE_BUILD_TYPE} = ${CMAKE_BUILD_TYPE}")
+    string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
+
+    if(uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
+      add_definitions(-DLLDB_CONFIGURATION_DEBUG)
+    # else()
+    #   set(LLVM_DISABLE_ABI_BREAKING_CHECKS_ENFORCING 1 CACHE INTERNAL "" )
+    endif()
+
     add_tablegen(lldb-tblgen LLDB
       LLDBOptionDefEmitter.cpp
       LLDBPropertyDefEmitter.cpp
@@ -14,5 +23,47 @@ if (NOT DEFINED LLDB_TABLEGEN_EXE)
       LLDBTableGenUtils.cpp
       )
     set_target_properties(lldb-tblgen PROPERTIES FOLDER "LLDB tablegenning")
+    set(LDFLAGS "$ENV{LDFLAGS}")
+    # set_target_properties(lldb-tblgen PROPERTIES LINK_OPTIONS $ENV{LDFLAGS})
+    message(WARNING "\${LDFLAGS} = ${LDFLAGS}")
+    target_link_directories(lldb-tblgen
+      PUBLIC
+      $ENV{OUTPUT_DIR}/lib/clang/${CLANG_VERSION}/lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      $ENV{OUTPUT_DIR}/lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      $ENV{RESOURCE_DIR}/lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      $ENV{RESOURCE_DIR}/lib/linux
+      $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      $ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/lib
+      )
+    target_link_options(lldb-tblgen
+      PUBLIC
+      -resource-dir=$ENV{RESOURCE_DIR}
+      -Wl,-rpath=\${ORIGIN}/../lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      -Wl,-rpath=\${ORIGIN}/../lib/clang/${CLANG_VERSION}/lib/${LLVM_DEFAULT_TARGET_TRIPLE}
+      -Wl,-rpath=\${ORIGIN}/../lib/clang/${CLANG_VERSION}/lib/linux
+      -Wl,-rpath=\${ORIGIN}/../lib
+      -fuse-ld=lld
+      -stdlib=libc++
+      -rtlib=compiler-rt
+      --unwindlib=libunwind
+      --warn-backrefs
+      -rdynamic -v
+      LINKER:-z,relro
+      LINKER:--undefined-version
+      LINKER:--as-needed
+      LINKER:--no-keep-memory
+      # PUBLIC ${LDFLAGS}
+      )
+    target_link_libraries(lldb-tblgen
+      PUBLIC
+      -lc++
+      -lc++abi
+      -lc
+      -lexecinfo
+      -lrt -ldl -lz -lm
+      -lc++experimental -lpthread
+      )
+	  set_target_properties(lldb-tblgen PROPERTIES LINK_FLAGS "${LDFLAGS}")
+    # target_link_options(lldb-tblgen PUBLIC "${LDFLAGS}")
   endif()
 endif()


diff --git a/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.cpp b/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.cpp
index 5235cd2a1461..6fadd59009c0 100644
--- a/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.cpp
+++ b/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.cpp
@@ -209,6 +209,8 @@ ClangFunctionCaller::CompileFunction(lldb::ThreadSP thread_to_use_sp,
 
 char ClangFunctionCaller::ClangFunctionCallerHelper::ID;
 
+ClangFunctionCaller::ClangFunctionCallerHelper::~ClangFunctionCallerHelper() = default;
+
 clang::ASTConsumer *
 ClangFunctionCaller::ClangFunctionCallerHelper::ASTTransformer(
     clang::ASTConsumer *passthrough) {
@@ -217,3 +219,8 @@ ClangFunctionCaller::ClangFunctionCallerHelper::ASTTransformer(
 
   return m_struct_extractor.get();
 }
+
+ClangFunctionCaller::ClangFunctionCallerHelper::ClangFunctionCallerHelper(ClangFunctionCaller &owner) : m_owner(owner) {}
+
+
+ClangExpressionDeclMap *ClangFunctionCaller::ClangFunctionCallerHelper::DeclMap() { return nullptr; }
diff --git a/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h b/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h
index 2a5c863b51a2..85375b28ecdb 100644
--- a/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h
+++ b/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h
@@ -64,11 +64,13 @@ class ClangFunctionCaller : public FunctionCaller {
     // LLVM RTTI support
     static char ID;
 
-    ClangFunctionCallerHelper(ClangFunctionCaller &owner) : m_owner(owner) {}
+	~ClangFunctionCallerHelper();
+
+    ClangFunctionCallerHelper(ClangFunctionCaller &owner);
 
     /// Return the object that the parser should use when resolving external
     /// values.  May be NULL if everything should be self-contained.
-    ClangExpressionDeclMap *DeclMap() override { return nullptr; }
+    ClangExpressionDeclMap *DeclMap() override;
 
     /// Return the object that the parser should allow to access ASTs. May be
     /// NULL if the ASTs do not need to be transformed.


diff --git a/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp b/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
index 371605d427ad..64abb4de21d0 100644
--- a/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
+++ b/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.cpp
@@ -178,6 +178,19 @@ bool ClangUtilityFunction::Install(DiagnosticManager &diagnostic_manager,
 
 char ClangUtilityFunction::ClangUtilityFunctionHelper::ID;
 
+ClangUtilityFunction::ClangUtilityFunctionHelper::~ClangUtilityFunctionHelper() = default;
+
+ClangExpressionDeclMap *ClangUtilityFunction::ClangUtilityFunctionHelper::DeclMap() {
+  return m_expr_decl_map_up.get();
+}
+
+void ClangUtilityFunction::ClangUtilityFunctionHelper::ResetDeclMap() { m_expr_decl_map_up.reset(); }
+
+clang::ASTConsumer *
+ClangUtilityFunction::ClangUtilityFunctionHelper::ASTTransformer(clang::ASTConsumer *passthrough) {
+  return nullptr;
+}
+
 void ClangUtilityFunction::ClangUtilityFunctionHelper::ResetDeclMap(
     ExecutionContext &exe_ctx, bool keep_result_in_memory) {
   std::shared_ptr<ClangASTImporter> ast_importer;
diff --git a/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.h b/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.h
index 72ff84f3ceaf..425bd897628d 100644
--- a/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.h
+++ b/lldb/source/Plugins/ExpressionParser/Clang/ClangUtilityFunction.h
@@ -79,13 +79,13 @@ private:
     // LLVM RTTI support
     static char ID;
 
+	~ClangUtilityFunctionHelper();
+
     /// Return the object that the parser should use when resolving external
     /// values.  May be NULL if everything should be self-contained.
-    ClangExpressionDeclMap *DeclMap() override {
-      return m_expr_decl_map_up.get();
-    }
+    ClangExpressionDeclMap *DeclMap() override;
 
-    void ResetDeclMap() { m_expr_decl_map_up.reset(); }
+    void ResetDeclMap();
 
     void ResetDeclMap(ExecutionContext &exe_ctx, bool keep_result_in_memory);
 
@@ -96,9 +96,7 @@ private:
     ///     The ASTConsumer that the returned transformer should send
     ///     the ASTs to after transformation.
     clang::ASTConsumer *
-    ASTTransformer(clang::ASTConsumer *passthrough) override {
-      return nullptr;
-    }
+    ASTTransformer(clang::ASTConsumer *passthrough) override;
 
   private:
     std::unique_ptr<ClangExpressionDeclMap> m_expr_decl_map_up;


diff --git a/lldb/cmake/modules/LLDBGenerateConfig.cmake b/lldb/cmake/modules/LLDBGenerateConfig.cmake
index 5acb7d873db4..2df26b4ad544 100644
--- a/lldb/cmake/modules/LLDBGenerateConfig.cmake
+++ b/lldb/cmake/modules/LLDBGenerateConfig.cmake
@@ -18,6 +18,11 @@ check_cxx_symbol_exists(process_vm_readv "sys/uio.h" HAVE_PROCESS_VM_READV)
 check_cxx_symbol_exists(__NR_process_vm_readv "sys/syscall.h" HAVE_NR_PROCESS_VM_READV)
 
 check_library_exists(compression compression_encode_buffer "" HAVE_LIBCOMPRESSION)
+if(NOT EXISTS "$ENV{SYSROOT}/$ENV{INSTALL_PREFIX}/include/compression.h")
+  unset(HAVE_LIBCOMPRESSION)
+  unset(HAVE_LIBCOMPRESSION CACHE)
+endif()
+message(WARNING "\${HAVE_LIBCOMPRESSION} = ${HAVE_LIBCOMPRESSION}")
 
 set(LLDB_INSTALL_LIBDIR_BASENAME "lib${LLDB_LIBDIR_SUFFIX}")
 


diff --git a/compiler-rt/lib/tsan/go/buildgo.sh b/compiler-rt/lib/tsan/go/buildgo.sh
index 0bd59368cc46..e13a8b371c8a 100755
--- a/compiler-rt/lib/tsan/go/buildgo.sh
+++ b/compiler-rt/lib/tsan/go/buildgo.sh
@@ -79,6 +79,7 @@ SRCS="
 "
 
 if [ "$GOOS" = "linux" ]; then
+	DEPENDS_ON_LIBC=1
 	OSCFLAGS="-fPIC -Wno-maybe-uninitialized"
 	OSLDFLAGS="-lpthread -fPIC -fpie"
 	SRCS="
@@ -184,7 +185,7 @@ else
 	exit 1
 fi
 
-CC=${CC:-gcc}
+CC=${CC:-cc}
 IN_TMPDIR=${IN_TMPDIR:-0}
 SILENT=${SILENT:-0}
 
@@ -204,9 +205,10 @@ for F in $SRCS; do
 	cat $F
 done > $DIR/gotsan.cpp
 
-FLAGS=" -I../rtl -I../.. -I../../sanitizer_common -I../../../include -std=c++17 -Wall -fno-exceptions -fno-rtti -DSANITIZER_GO=1 -DSANITIZER_DEADLOCK_DETECTOR_VERSION=2 $OSCFLAGS $ARCHCFLAGS $EXTRA_CFLAGS"
+FLAGS=" -I../rtl -I../.. -I../../sanitizer_common -I../../../include -std=c++23 -Wall -fno-exceptions -fno-rtti -DSANITIZER_GO=1 -DSANITIZER_DEADLOCK_DETECTOR_VERSION=2 $OSCFLAGS $ARCHCFLAGS $EXTRA_CFLAGS"
 DEBUG_FLAGS="$FLAGS -DSANITIZER_DEBUG=1 -g"
 FLAGS="$FLAGS -DSANITIZER_DEBUG=0 -O3 -fomit-frame-pointer"
+CFLAGS="${CFLAGS_ORIGIN-}"
 
 if [ "$DEBUG" = "" ]; then
 	# Do a build test with debug flags.


diff --git a/compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp b/compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp
index c921da980cad..4ac648b9f9d6 100644
--- a/compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp
+++ b/compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp
@@ -243,6 +243,7 @@ TEST(ScudoWrappersCDeathTest, Realloc) {
   }
 }
 
+#ifdef __GLIBC__
 #if !SCUDO_FUCHSIA
 TEST(ScudoWrappersCTest, MallOpt) {
   errno = 0;
@@ -264,6 +265,7 @@ TEST(ScudoWrappersCTest, MallOpt) {
   }
 }
 #endif
+#endif
 
 TEST(ScudoWrappersCTest, OtherAlloc) {
 #if HAVE_PVALLOC
@@ -288,6 +290,7 @@ TEST(ScudoWrappersCTest, OtherAlloc) {
 #endif
 }
 
+#ifdef __GLIBC__
 #if !SCUDO_FUCHSIA
 TEST(ScudoWrappersCTest, MallInfo) {
   // mallinfo is deprecated.
@@ -308,6 +311,7 @@ TEST(ScudoWrappersCTest, MallInfo) {
 #pragma clang diagnostic pop
 }
 #endif
+#endif
 
 #if __GLIBC_PREREQ(2, 33)
 TEST(ScudoWrappersCTest, MallInfo2) {
@@ -392,6 +396,7 @@ TEST(ScudoWrappersCTest, MallocIterateBoundary) {
   }
 }
 
+#ifdef __GLIBC__
 // Fuchsia doesn't have alarm, fork or malloc_info.
 #if !SCUDO_FUCHSIA
 TEST(ScudoWrappersCDeathTest, MallocDisableDeadlock) {
@@ -508,3 +513,4 @@ TEST(ScudoWrappersCTest, DisableForkEnable) {
 }
 
 #endif // SCUDO_FUCHSIA
+#endif // __GLIBC__


diff --git a/clang/lib/Driver/ToolChain.cpp b/clang/lib/Driver/ToolChain.cpp
index d60fdbc17968..947f6bf98ded 100644
--- a/clang/lib/Driver/ToolChain.cpp
+++ b/clang/lib/Driver/ToolChain.cpp
@@ -673,6 +673,14 @@ const char *ToolChain::getCompilerRTArgString(const llvm::opt::ArgList &Args,
 
 ToolChain::path_list ToolChain::getRuntimePaths() const {
   path_list Paths;
+
+  std::string arch  = Triple.getArchName().lower();
+  std::string os    = Triple.getOSName().lower();
+  std::string abi   = Triple.getEnvironmentTypeName(Triple.getEnvironment()).str();
+  SmallString<1024> P(D.ResourceDir);
+  llvm::sys::path::append(P, "lib", arch + "-" + os + "-" + abi);
+  Paths.push_back(std::string(P.str()));
+
   auto addPathForTriple = [this, &Paths](const llvm::Triple &Triple) {
     SmallString<128> P(D.ResourceDir);
     llvm::sys::path::append(P, "lib", Triple.str());


diff --git a/compiler-rt/lib/msan/tests/CMakeLists.txt b/compiler-rt/lib/msan/tests/CMakeLists.txt
index 6c0520d98426..ff8fcafc52d9 100644
--- a/compiler-rt/lib/msan/tests/CMakeLists.txt
+++ b/compiler-rt/lib/msan/tests/CMakeLists.txt
@@ -143,8 +143,11 @@ if(COMPILER_RT_CAN_EXECUTE_TESTS AND
       DEPS ${MSAN_RUNTIME_LIBRARIES}
       CFLAGS ${MSAN_LIBCXX_CFLAGS} ${TARGET_CFLAGS}
       USE_TOOLCHAIN)
-    set(MSAN_LIBCXX_DIR ${LIBCXX_PREFIX}/lib/)
-
+    if(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR)
+      set(MSAN_LIBCXX_DIR $ENV{OUTPUT_DIR}/lib/${LLVM_TARGET_TRIPLE})
+    else()
+      set(MSAN_LIBCXX_DIR $ENV{OUTPUT_DIR}/lib)
+    endif()
     add_msan_tests_for_arch(${arch} "" "")
     add_msan_tests_for_arch(${arch} "-with-call"
                             "-mllvm;-msan-instrumentation-with-call-threshold=0")


diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index 229f6141c750..6a8e80e3863f 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -4436,7 +4436,10 @@ def print_ivar_layout : Flag<["-"], "print-ivar-layout">, Flags<[CC1Option]>,
   MarshallingInfoFlag<LangOpts<"ObjCGCBitmapPrint">>;
 def print_libgcc_file_name : Flag<["-", "--"], "print-libgcc-file-name">,
   HelpText<"Print the library path for the currently used compiler runtime "
-           "library (\"libgcc.a\" or \"libclang_rt.builtins.*.a\")">;
+           "library (\"libgcc.a\" or \"libclang_rt.builtins.a\")">;
+def print_rtlib_file_name : Flag<["-", "--"], "print-rtlib-file-name">,
+  HelpText<"Print the library path for the currently used compiler runtime "
+           "library (\"libgcc.a\" or \"libclang_rt.builtins.a\")">;
 def print_multi_directory : Flag<["-", "--"], "print-multi-directory">;
 def print_multi_lib : Flag<["-", "--"], "print-multi-lib">;
 def print_multi_flags : Flag<["-", "--"], "print-multi-flags-experimental">,
@@ -4527,6 +4530,7 @@ def segs__read__only__addr : Separate<["-"], "segs_read_only_addr">;
 def segs__read__write__addr : Separate<["-"], "segs_read_write_addr">;
 def segs__read__ : Joined<["-"], "segs_read_">;
 def shared_libgcc : Flag<["-"], "shared-libgcc">;
+def shared_rtlib : Flag<["-"], "shared-rtlib">;
 def shared : Flag<["-", "--"], "shared">, Group<Link_Group>;
 def single__module : Flag<["-"], "single_module">;
 def specs_EQ : Joined<["-", "--"], "specs=">, Group<Link_Group>;
@@ -4534,6 +4538,7 @@ def specs : Separate<["-", "--"], "specs">, Flags<[Unsupported]>;
 def start_no_unused_arguments : Flag<["--"], "start-no-unused-arguments">, Flags<[CoreOption]>,
   HelpText<"Don't emit warnings about unused arguments for the following arguments">;
 def static_libgcc : Flag<["-"], "static-libgcc">;
+def static_rtlib : Flag<["-"], "static-rtlib">;
 def static_libstdcxx : Flag<["-"], "static-libstdc++">;
 def static : Flag<["-", "--"], "static">, Group<Link_Group>, Flags<[NoArgumentUnused]>;
 def std_default_EQ : Joined<["-"], "std-default=">;


diff --git a/compiler-rt/test/builtins/Unit/lit.cfg.py b/compiler-rt/test/builtins/Unit/lit.cfg.py
index f63d15919888..3764c192c502 100644
--- a/compiler-rt/test/builtins/Unit/lit.cfg.py
+++ b/compiler-rt/test/builtins/Unit/lit.cfg.py
@@ -47,9 +47,9 @@ def get_library_path(file):
     return dir
 
 
-def get_libgcc_file_name():
+def get_rtlib_file_name():
     cmd = subprocess.Popen(
-        [config.clang.strip(), "-print-libgcc-file-name"]
+        [config.clang.strip(), "-print-rtlib-file-name"]
         + shlex.split(config.target_cflags),
         stdout=subprocess.PIPE,
         env=config.environment,
@@ -122,7 +122,7 @@ if builtins_build_crt:
     config.substitutions.append(("%crti", get_library_path("crti.o")))
     config.substitutions.append(("%crtn", get_library_path("crtn.o")))
 
-    config.substitutions.append(("%libgcc", get_libgcc_file_name()))
+    config.substitutions.append(("%compiler_rt", get_rtlib_file_name()))
 
     config.substitutions.append(
         ("%libstdcxx", "-l" + config.sanitizer_cxx_lib.lstrip("lib"))


diff --git a/clang/test/Driver/print-libgcc-file-name-clangrt.c b/clang/test/Driver/print-libgcc-file-name-clangrt.c
index 19f9a3c28c31..c3bf043db44b 100644
--- a/clang/test/Driver/print-libgcc-file-name-clangrt.c
+++ b/clang/test/Driver/print-libgcc-file-name-clangrt.c
@@ -1,63 +1,63 @@
-// Test that -print-libgcc-file-name correctly respects -rtlib=compiler-rt.
+// Test that -print-rtlib-file-name correctly respects -rtlib=compiler-rt.
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=x86_64-pc-linux \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-X8664 %s
-// CHECK-CLANGRT-X8664: libclang_rt.builtins-x86_64.a
+// CHECK-CLANGRT-X8664: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=i386-pc-linux \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-I386 %s
-// CHECK-CLANGRT-I386: libclang_rt.builtins-i386.a
+// CHECK-CLANGRT-I386: libclang_rt.builtins.a
 
 // Check whether alternate arch values map to the correct library.
 //
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=i686-pc-linux \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-I386 %s
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=arm-linux-gnueabi \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-ARM %s
-// CHECK-CLANGRT-ARM: libclang_rt.builtins-arm.a
+// CHECK-CLANGRT-ARM: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=arm-linux-androideabi \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-ARM-ANDROID %s
-// CHECK-CLANGRT-ARM-ANDROID: libclang_rt.builtins-arm-android.a
+// CHECK-CLANGRT-ARM-ANDROID: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=arm-linux-gnueabihf \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-ARMHF %s
-// CHECK-CLANGRT-ARMHF: libclang_rt.builtins-armhf.a
+// CHECK-CLANGRT-ARMHF: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=arm-linux-gnueabi -mfloat-abi=hard \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-ARM-ABI %s
-// CHECK-CLANGRT-ARM-ABI: libclang_rt.builtins-armhf.a
+// CHECK-CLANGRT-ARM-ABI: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=armv7m-none-eabi \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_arch_subdir 2>&1 \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-ARM-BAREMETAL %s
-// CHECK-CLANGRT-ARM-BAREMETAL: libclang_rt.builtins-armv7m.a
+// CHECK-CLANGRT-ARM-BAREMETAL: libclang_rt.builtins.a
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name \
 // RUN:     --target=armv7m-vendor-none-eabi \
 // RUN:     --sysroot=%S/Inputs/resource_dir_with_arch_subdir \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_per_target_subdir 2>&1 \


diff --git a/clang/test/Driver/aix-rtlib.c b/clang/test/Driver/aix-rtlib.c
index e0466b166bb7..ff7810cb1de2 100644
--- a/clang/test/Driver/aix-rtlib.c
+++ b/clang/test/Driver/aix-rtlib.c
@@ -1,8 +1,8 @@
 // Check the default rtlib for AIX.
-// RUN: %clang --target=powerpc-ibm-aix -print-libgcc-file-name \
+// RUN: %clang --target=powerpc-ibm-aix -print-rtlib-file-name \
 // RUN:        -resource-dir=%S/Inputs/resource_dir \
 // RUN:   | FileCheck -check-prefix=CHECK32 %s
-// RUN: %clang --target=powerpc64-ibm-aix -print-libgcc-file-name \
+// RUN: %clang --target=powerpc64-ibm-aix -print-rtlib-file-name \
 // RUN:        -resource-dir=%S/Inputs/resource_dir \
 // RUN:   | FileCheck -check-prefix=CHECK64 %s
 


diff --git a/clang/test/Driver/linux-per-target-runtime-dir.c b/clang/test/Driver/linux-per-target-runtime-dir.c
index 016269106c01..1968a37cb5af 100644
--- a/clang/test/Driver/linux-per-target-runtime-dir.c
+++ b/clang/test/Driver/linux-per-target-runtime-dir.c
@@ -14,7 +14,7 @@
 // CHECK-PER-TARGET-RUNTIME: "--sysroot=[[SYSROOT]]"
 // CHECK-PER-TARGET-RUNTIME: "-L{{.*}}{{/|\\\\}}..{{/|\\\\}}lib{{/|\\\\}}x86_64-unknown-linux-gnu"
 
-// RUN: %clang -rtlib=compiler-rt -print-libgcc-file-name 2>&1 \
+// RUN: %clang -rtlib=compiler-rt -print-rtlib-file-name 2>&1 \
 // RUN:     --target=x86_64-unknown-linux-gnu \
 // RUN:     -resource-dir=%S/Inputs/resource_dir_with_per_target_subdir \
 // RUN:   | FileCheck --check-prefix=CHECK-CLANGRT-X8664 %s


diff --git a/clang/lib/Driver/ToolChains/CommonArgs.cpp b/clang/lib/Driver/ToolChains/CommonArgs.cpp
index 358d7565f47c..23b4d6b535d8 100644
--- a/clang/lib/Driver/ToolChains/CommonArgs.cpp
+++ b/clang/lib/Driver/ToolChains/CommonArgs.cpp
@@ -1753,18 +1753,24 @@ bool tools::isObjCAutoRefCount(const ArgList &Args) {
   return Args.hasFlag(options::OPT_fobjc_arc, options::OPT_fno_objc_arc, false);
 }
 
-enum class LibGccType { UnspecifiedLibGcc, StaticLibGcc, SharedLibGcc };
+enum class RtlibType { UnspecifiedRtlib, StaticRtlib, SharedRtlib };
 
-static LibGccType getLibGccType(const ToolChain &TC, const Driver &D,
+static RtlibType getRtlibType(const ToolChain &TC, const Driver &D,
                                 const ArgList &Args) {
-  if (Args.hasArg(options::OPT_static_libgcc) ||
-      Args.hasArg(options::OPT_static) || Args.hasArg(options::OPT_static_pie) ||
-      // The Android NDK only provides libunwind.a, not libunwind.so.
-      TC.getTriple().isAndroid())
-    return LibGccType::StaticLibGcc;
-  if (Args.hasArg(options::OPT_shared_libgcc))
-    return LibGccType::SharedLibGcc;
-  return LibGccType::UnspecifiedLibGcc;
+  if (
+  Args.hasArg(options::OPT_static_libgcc) ||
+  Args.hasArg(options::OPT_static_rtlib) ||
+  Args.hasArg(options::OPT_static) ||
+  Args.hasArg(options::OPT_static_pie) ||
+  // The Android NDK only provides libunwind.a, not libunwind.so.
+  TC.getTriple().isAndroid())
+    return RtlibType::StaticRtlib;
+  if (
+  Args.hasArg(options::OPT_shared_libgcc) ||
+  Args.hasArg(options::OPT_shared_rtlib)
+  )
+    return RtlibType::SharedRtlib;
+  return RtlibType::UnspecifiedRtlib;
 }
 
 // Gcc adds libgcc arguments in various ways:
@@ -1795,8 +1801,8 @@ static void AddUnwindLibrary(const ToolChain &TC, const Driver &D,
       TC.getTriple().isWindowsMSVCEnvironment() || UNW == ToolChain::UNW_None)
     return;
 
-  LibGccType LGT = getLibGccType(TC, D, Args);
-  bool AsNeeded = LGT == LibGccType::UnspecifiedLibGcc &&
+  RtlibType LGT = getRtlibType(TC, D, Args);
+  bool AsNeeded = LGT == RtlibType::UnspecifiedRtlib &&
                   (UNW == ToolChain::UNW_CompilerRT || !D.CCCIsCXX()) &&
                   !TC.getTriple().isAndroid() &&
                   !TC.getTriple().isOSCygMing() && !TC.getTriple().isOSAIX();
@@ -1807,7 +1813,7 @@ static void AddUnwindLibrary(const ToolChain &TC, const Driver &D,
   case ToolChain::UNW_None:
     return;
   case ToolChain::UNW_Libgcc: {
-    if (LGT == LibGccType::StaticLibGcc)
+    if (LGT == RtlibType::StaticRtlib)
       CmdArgs.push_back("-lgcc_eh");
     else
       CmdArgs.push_back("-lgcc_s");
@@ -1817,11 +1823,11 @@ static void AddUnwindLibrary(const ToolChain &TC, const Driver &D,
     if (TC.getTriple().isOSAIX()) {
       // AIX only has libunwind as a shared library. So do not pass
       // anything in if -static is specified.
-      if (LGT != LibGccType::StaticLibGcc)
+      if (LGT != RtlibType::StaticRtlib)
         CmdArgs.push_back("-lunwind");
-    } else if (LGT == LibGccType::StaticLibGcc) {
+    } else if (LGT == RtlibType::StaticRtlib) {
       CmdArgs.push_back("-l:libunwind.a");
-    } else if (LGT == LibGccType::SharedLibGcc) {
+    } else if (LGT == RtlibType::SharedRtlib) {
       if (TC.getTriple().isOSCygMing())
         CmdArgs.push_back("-l:libunwind.dll.a");
       else
@@ -1838,15 +1844,15 @@ static void AddUnwindLibrary(const ToolChain &TC, const Driver &D,
     CmdArgs.push_back(getAsNeededOption(TC, false));
 }
 
-static void AddLibgcc(const ToolChain &TC, const Driver &D,
+static void AddRtlib(const ToolChain &TC, const Driver &D,
                       ArgStringList &CmdArgs, const ArgList &Args) {
-  LibGccType LGT = getLibGccType(TC, D, Args);
-  if (LGT == LibGccType::StaticLibGcc ||
-      (LGT == LibGccType::UnspecifiedLibGcc && !D.CCCIsCXX()))
+  RtlibType LGT = getRtlibType(TC, D, Args);
+  if (LGT == RtlibType::StaticRtlib ||
+      (LGT == RtlibType::UnspecifiedRtlib && !D.CCCIsCXX()))
     CmdArgs.push_back("-lgcc");
   AddUnwindLibrary(TC, D, CmdArgs, Args);
-  if (LGT == LibGccType::SharedLibGcc ||
-      (LGT == LibGccType::UnspecifiedLibGcc && D.CCCIsCXX()))
+  if (LGT == RtlibType::SharedRtlib ||
+      (LGT == RtlibType::UnspecifiedRtlib && D.CCCIsCXX()))
     CmdArgs.push_back("-lgcc");
 }
 
@@ -1871,7 +1877,7 @@ void tools::AddRunTimeLibs(const ToolChain &TC, const Driver &D,
             << A->getValue() << "MSVC";
       }
     } else
-      AddLibgcc(TC, D, CmdArgs, Args);
+      AddRtlib(TC, D, CmdArgs, Args);
     break;
   }
 
diff --git a/clang/lib/Driver/ToolChains/Darwin.cpp b/clang/lib/Driver/ToolChains/Darwin.cpp
index 65bd6c6a7eb3..48af4feda8a6 100644
--- a/clang/lib/Driver/ToolChains/Darwin.cpp
+++ b/clang/lib/Driver/ToolChains/Darwin.cpp
@@ -1456,13 +1456,17 @@ void DarwinClang::AddLinkRuntimeLibArgs(const ArgList &Args,
     return;
   }
 
-  // Reject -static-libgcc for now, we can deal with this when and if someone
+  // Reject -static-rtlib for now, we can deal with this when and if someone
   // cares. This is useful in situations where someone wants to statically link
   // something like libstdc++, and needs its runtime support routines.
   if (const Arg *A = Args.getLastArg(options::OPT_static_libgcc)) {
     getDriver().Diag(diag::err_drv_unsupported_opt) << A->getAsString(Args);
     return;
   }
+  if (const Arg *B = Args.getLastArg(options::OPT_static_rtlib)) {
+    getDriver().Diag(diag::err_drv_unsupported_opt) << B->getAsString(Args);
+    return;
+  }
 
   const SanitizerArgs &Sanitize = getSanitizerArgs(Args);
 
@@ -3280,7 +3284,10 @@ void Darwin::addStartObjectFileArgs(const ArgList &Args,
   else
     addDefaultCRTLinkArgs(*this, Args, CmdArgs);
 
-  if (isTargetMacOS() && Args.hasArg(options::OPT_shared_libgcc) &&
+  if (isTargetMacOS() && (
+  Args.hasArg(options::OPT_shared_libgcc) ||
+  Args.hasArg(options::OPT_shared_rtlib)
+  ) &&
       isMacosxVersionLT(10, 5)) {
     const char *Str = Args.MakeArgString(GetFilePath("crt3.o"));
     CmdArgs.push_back(Str);
diff --git a/clang/lib/Driver/ToolChains/DragonFly.cpp b/clang/lib/Driver/ToolChains/DragonFly.cpp
index ba901407715f..c867dd45a482 100644
--- a/clang/lib/Driver/ToolChains/DragonFly.cpp
+++ b/clang/lib/Driver/ToolChains/DragonFly.cpp
@@ -142,12 +142,18 @@ void dragonfly::Linker::ConstructJob(Compilation &C, const JobAction &JA,
       CmdArgs.push_back("-lc");
     }
 
-    if (Args.hasArg(options::OPT_static) ||
-        Args.hasArg(options::OPT_static_libgcc)) {
+    if (
+    Args.hasArg(options::OPT_static) ||
+    Args.hasArg(options::OPT_static_libgcc) ||
+    Args.hasArg(options::OPT_static_rtlib)
+    ) {
         CmdArgs.push_back("-lgcc");
         CmdArgs.push_back("-lgcc_eh");
     } else {
-      if (Args.hasArg(options::OPT_shared_libgcc)) {
+      if (
+      Args.hasArg(options::OPT_shared_libgcc) ||
+      Args.hasArg(options::OPT_shared_rtlib)
+      ) {
           CmdArgs.push_back("-lgcc_pic");
           if (!Args.hasArg(options::OPT_shared))
             CmdArgs.push_back("-lgcc");


diff --git a/clang/lib/Driver/ToolChains/Hexagon.cpp b/clang/lib/Driver/ToolChains/Hexagon.cpp
index 7acc600a6aa4..8d301367d963 100644
--- a/clang/lib/Driver/ToolChains/Hexagon.cpp
+++ b/clang/lib/Driver/ToolChains/Hexagon.cpp
@@ -312,6 +312,7 @@ constructHexagonLinkArgs(Compilation &C, const JobAction &JA,
   Args.ClaimAllArgs(options::OPT_w); // Other warning options are already
                                      // handled somewhere else.
   Args.ClaimAllArgs(options::OPT_static_libgcc);
+  Args.ClaimAllArgs(options::OPT_static_rtlib);
 
   //----------------------------------------------------------------------------
   //
diff --git a/clang/lib/Driver/ToolChains/MinGW.cpp b/clang/lib/Driver/ToolChains/MinGW.cpp
index b47041dcca70..74cf768e4799 100644
--- a/clang/lib/Driver/ToolChains/MinGW.cpp
+++ b/clang/lib/Driver/ToolChains/MinGW.cpp
@@ -68,7 +68,8 @@ void tools::MinGW::Linker::AddLibGCC(const ArgList &Args,
   ToolChain::RuntimeLibType RLT = getToolChain().GetRuntimeLibType(Args);
   if (RLT == ToolChain::RLT_Libgcc) {
     bool Static = Args.hasArg(options::OPT_static_libgcc) ||
-                  Args.hasArg(options::OPT_static);
+    Args.hasArg(options::OPT_static_rtlib) ||
+    Args.hasArg(options::OPT_static);
     bool Shared = Args.hasArg(options::OPT_shared);
     bool CXX = getToolChain().getDriver().CCCIsCXX();
 
diff --git a/clang/lib/Driver/ToolChains/Myriad.cpp b/clang/lib/Driver/ToolChains/Myriad.cpp
index 30424ff49e64..a37180c26718 100644
--- a/clang/lib/Driver/ToolChains/Myriad.cpp
+++ b/clang/lib/Driver/ToolChains/Myriad.cpp
@@ -147,6 +147,7 @@ void tools::Myriad::Linker::ConstructJob(Compilation &C, const JobAction &JA,
   Args.ClaimAllArgs(options::OPT_g_Group);
   Args.ClaimAllArgs(options::OPT_w);
   Args.ClaimAllArgs(options::OPT_static_libgcc);
+  Args.ClaimAllArgs(options::OPT_static_rtlib);
 
   if (Args.hasArg(options::OPT_s)) // Pass the 'strip' option.
     CmdArgs.push_back("-s");


diff --git a/clang/docs/CommandGuide/clang.rst b/clang/docs/CommandGuide/clang.rst
index 139c8f25137d..0e7d2c9fcb3c 100644
--- a/clang/docs/CommandGuide/clang.rst
+++ b/clang/docs/CommandGuide/clang.rst
@@ -587,7 +587,12 @@ Driver Options
 .. option:: -print-libgcc-file-name
 
   Print the library path for the currently used compiler runtime library
-  ("libgcc.a" or "libclang_rt.builtins.*.a").
+  ("libgcc.a" or "libclang_rt.builtins.a").
+
+.. option:: -print-rtlib-file-name
+
+  Print the library path for the currently used compiler runtime library
+  ("libgcc.a" or "libclang_rt.builtins.a").
 
 .. option:: -print-prog-name=<name>
 


diff --git a/compiler-rt/lib/hwasan/CMakeLists.txt b/compiler-rt/lib/hwasan/CMakeLists.txt
index 1b5775d9435d..409e7dd6d5a6 100644
--- a/compiler-rt/lib/hwasan/CMakeLists.txt
+++ b/compiler-rt/lib/hwasan/CMakeLists.txt
@@ -49,7 +49,7 @@ set(HWASAN_RTL_HEADERS
   hwasan_thread_list.h
   )
 
-set(HWASAN_DEFINITIONS)
+set(HWASAN_DEFINITIONS $ENV{LIBUNWIND_ADDITIONAL_COMPILE_FLAGS})
 append_list_if(COMPILER_RT_HWASAN_WITH_INTERCEPTORS HWASAN_WITH_INTERCEPTORS=1 HWASAN_DEFINITIONS)
 
 if(FUCHSIA)


# diff --git a/compiler-rt/lib/gwp_asan/CMakeLists.txt b/compiler-rt/lib/gwp_asan/CMakeLists.txt
# index bb5b2902f99d..a3bec1281dfc 100644
# --- a/compiler-rt/lib/gwp_asan/CMakeLists.txt
# +++ b/compiler-rt/lib/gwp_asan/CMakeLists.txt
# @@ -1,6 +1,3 @@
# -add_compiler_rt_component(gwp_asan)
# -
# -include_directories(..)
#  
#  set(GWP_ASAN_SOURCES
#    common.cpp
# @@ -30,6 +27,8 @@ set(GWP_ASAN_HEADERS
#    utilities.h
#  )
#  
# +include_directories(..)
# +
#  # Ensure that GWP-ASan meets the delegated requirements of some supporting
#  # allocators. Some supporting allocators (e.g. scudo standalone) cannot use any
#  # parts of the C++ standard library.
# @@ -65,6 +64,8 @@ set(GWP_ASAN_SEGV_HANDLER_HEADERS
#  set(GWP_ASAN_OPTIONS_PARSER_CFLAGS
#      ${GWP_ASAN_CFLAGS})
#  
# +add_compiler_rt_component(gwp_asan)
# +
#  if (COMPILER_RT_HAS_GWP_ASAN)
#    foreach(arch ${GWP_ASAN_SUPPORTED_ARCH})
#      add_compiler_rt_runtime(
# @@ -72,6 +73,12 @@ if (COMPILER_RT_HAS_GWP_ASAN)
#        STATIC
#        ARCHS ${arch}
#        SOURCES ${GWP_ASAN_SOURCES}
# +      OBJECT_LIBS RTSanitizerCommon
# +              RTSanitizerCommonLibc
# +              RTSanitizerCommonCoverage
# +              RTSanitizerCommonSymbolizer
# +              RTUbsan
# +              RTInterception
#        ADDITIONAL_HEADERS ${GWP_ASAN_HEADERS}
#        CFLAGS ${GWP_ASAN_CFLAGS}
#        PARENT_TARGET gwp_asan


diff --git a/compiler-rt/lib/gwp_asan/CMakeLists.txt b/compiler-rt/lib/gwp_asan/CMakeLists.txt
index bb5b2902f99d..9b734349a9eb 100644
--- a/compiler-rt/lib/gwp_asan/CMakeLists.txt
+++ b/compiler-rt/lib/gwp_asan/CMakeLists.txt
@@ -1,6 +1,3 @@
-add_compiler_rt_component(gwp_asan)
-
-include_directories(..)
 
 set(GWP_ASAN_SOURCES
   common.cpp
@@ -30,6 +27,8 @@ set(GWP_ASAN_HEADERS
   utilities.h
 )
 
+include_directories(..)
+
 # Ensure that GWP-ASan meets the delegated requirements of some supporting
 # allocators. Some supporting allocators (e.g. scudo standalone) cannot use any
 # parts of the C++ standard library.
@@ -65,6 +64,8 @@ set(GWP_ASAN_SEGV_HANDLER_HEADERS
 set(GWP_ASAN_OPTIONS_PARSER_CFLAGS
     ${GWP_ASAN_CFLAGS})
 
+add_compiler_rt_component(gwp_asan)
+
 if (COMPILER_RT_HAS_GWP_ASAN)
   foreach(arch ${GWP_ASAN_SUPPORTED_ARCH})
     add_compiler_rt_runtime(


diff --git a/compiler-rt/lib/asan/tests/CMakeLists.txt b/compiler-rt/lib/asan/tests/CMakeLists.txt
index 3c0d2d41e4d1..3927dbc35666 100644
--- a/compiler-rt/lib/asan/tests/CMakeLists.txt
+++ b/compiler-rt/lib/asan/tests/CMakeLists.txt
@@ -192,7 +192,7 @@ function(add_asan_tests arch test_runtime)
     SUBDIR "${CONFIG_NAME}"
     LINK_FLAGS ${ASAN_UNITTEST_INSTRUMENTED_LINK_FLAGS} ${TARGET_LINK_FLAGS}
     SOURCES ${ASAN_INST_TEST_SOURCES}
-    CFLAGS ${ASAN_UNITTEST_INSTRUMENTED_CFLAGS} ${TEST_CFLAGS})
+    CFLAGS ${ASAN_UNITTEST_INSTRUMENTED_CFLAGS} ${COMPILER_RT_UNITTEST_CFLAGS})
 
   if(COMPILER_RT_ASAN_HAS_STATIC_RUNTIME)
     set(dynamic_test_name "Asan-${arch}${TEST_KIND}-Dynamic-Test")


# diff --git a/compiler-rt/lib/builtins/fp_extend.h b/compiler-rt/lib/builtins/fp_extend.h
# index eee4722bf90e..bd279424394b 100644
# --- a/compiler-rt/lib/builtins/fp_extend.h
# +++ b/compiler-rt/lib/builtins/fp_extend.h
# @@ -40,7 +40,7 @@ static __inline int src_rep_t_clz(src_rep_t a) {
#  }
#  
#  #elif defined SRC_HALF
# -#ifdef COMPILER_RT_HAS_FLOAT16
# +#if defined(__FLT16_MAX__)
#  typedef _Float16 src_t;
#  #else
#  typedef uint16_t src_t;
# diff --git a/compiler-rt/lib/builtins/fp_trunc.h b/compiler-rt/lib/builtins/fp_trunc.h
# index 91f614528ab3..bf19949515cb 100644
# --- a/compiler-rt/lib/builtins/fp_trunc.h
# +++ b/compiler-rt/lib/builtins/fp_trunc.h
# @@ -50,7 +50,7 @@ typedef uint32_t dst_rep_t;
#  static const int dstSigBits = 23;
#  
#  #elif defined DST_HALF
# -#ifdef COMPILER_RT_HAS_FLOAT16
# +#ifdef defined(__FLT16_MAX__)
#  typedef _Float16 dst_t;
#  #else
#  typedef uint16_t dst_t;
# diff --git a/compiler-rt/test/builtins/Unit/fp_test.h b/compiler-rt/test/builtins/Unit/fp_test.h
# index e54dfc108e71..efb44ce630c0 100644
# --- a/compiler-rt/test/builtins/Unit/fp_test.h
# +++ b/compiler-rt/test/builtins/Unit/fp_test.h
# @@ -3,7 +3,7 @@
#  #include <string.h>
#  #include <stdint.h>
#  
# -#ifdef COMPILER_RT_HAS_FLOAT16
# +#if defined(__FLT16_MAX__)
#  #define TYPE_FP16 _Float16
#  #else
#  #define TYPE_FP16 uint16_t
# @@ -15,7 +15,7 @@ enum EXPECTED_RESULT {
#  
#  static inline TYPE_FP16 fromRep16(uint16_t x)
#  {
# -#ifdef COMPILER_RT_HAS_FLOAT16
# +#if defined(__FLT16_MAX__)
#      TYPE_FP16 ret;
#      memcpy(&ret, &x, sizeof(ret));
#      return ret;
# @@ -50,7 +50,7 @@ static inline long double fromRep128(uint64_t hi, uint64_t lo)
#  
#  static inline uint16_t toRep16(TYPE_FP16 x)
#  {
# -#ifdef COMPILER_RT_HAS_FLOAT16
# +#if defined(__FLT16_MAX__)
#      uint16_t ret;
#      memcpy(&ret, &x, sizeof(ret));
#      return ret;


# diff --git a/libunwind/src/DwarfParser.hpp b/libunwind/src/DwarfParser.hpp
# index 0682942ce137..087e78b5f1a2 100644
# --- a/libunwind/src/DwarfParser.hpp
# +++ b/libunwind/src/DwarfParser.hpp
# @@ -173,6 +173,7 @@ template <typename A>
#  const char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,
#                                       FDE_Info *fdeInfo, CIE_Info *cieInfo,
#                                       bool useCIEInfo) {
# +  bool use_cie_info_impl = useCIEInfo;
#    pint_t p = fdeStart;
#    pint_t cfiLength = (pint_t)addressSpace.get32(p);
#    p += 4;
# @@ -184,11 +185,13 @@ const char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,
#    if (cfiLength == 0)
#      return "FDE has zero length"; // zero terminator
#    uint32_t ciePointer = addressSpace.get32(p);
# -  if (ciePointer == 0)
# -    return "FDE is really a CIE"; // this is a CIE not an FDE
# +  if (ciePointer == 0) {
# +    use_cie_info_impl = true;
# +    // return "FDE is really a CIE"; // this is a CIE not an FDE
# +  }
#    pint_t nextCFI = p + cfiLength;
#    pint_t cieStart = p - ciePointer;
# -  if (useCIEInfo) {
# +  if (use_cie_info_impl) {
#      if (cieInfo->cieStart != cieStart)
#        return "CIE start does not match";
#    } else {


















